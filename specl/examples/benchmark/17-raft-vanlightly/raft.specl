module RaftVanlightly
// Use: -c N=2 -c MaxVal=1 -c MaxElections=1 -c MaxRestarts=0 -c MaxLogLen=2

// ============================================================================
// Vanlightly's Model-Checking Optimized Raft Specification
// ============================================================================
// Translated from https://github.com/Vanlightly/raft-tlaplus
//
// Message encoding (term at [0], src at [1], dest at [2] for all types):
//   ReqVoteReq:  [term, src, dest, lastLogTerm, lastLogIndex]
//   ReqVoteResp: [term, src, dest, voteGranted(0/1)]
//   AEReq:       [term, src, dest, prevLogIndex, prevLogTerm,
//                  hasEntry(0/1), entryTerm, entryValue, commitIndex]
//   AEResp:      [term, src, dest, success(0/1), matchIndex]
//
// Usage: specl check raft.specl -c N=2 -c MaxVal=0 -c MaxElections=2 -c MaxRestarts=0 -c MaxLogLen=1

const N: Int
const MaxVal: Int
const MaxElections: Int
const MaxRestarts: Int
const MaxLogLen: Int  // must be >= MaxVal + 1 (max possible log entries)

// Per-server state
var currentTerm: Dict[Int, Int]
var state: Dict[Int, Int]              // 0=Follower, 1=Candidate, 2=Leader
var votedFor: Dict[Int, Int]           // -1 = Nil
var logTerm: Dict[Int, Seq[Int]]       // logTerm[i][k] = term of k-th entry (0-based)
var logValue: Dict[Int, Seq[Int]]      // logValue[i][k] = value of k-th entry (0-based)
var commitIndex: Dict[Int, Int]

// Candidate state
var votesGranted: Dict[Int, Dict[Int, Bool]]

// Leader state
var nextIndex: Dict[Int, Dict[Int, Int]]
var matchIndex: Dict[Int, Dict[Int, Int]]
var pendingResponse: Dict[Int, Dict[Int, Bool]]

// Auxiliary state
var acked: Dict[Int, Int]    // -1=Nil, 0=FALSE(submitted), 1=TRUE(committed)
var electionCtr: Int
var restartCtr: Int

// Message sets (separate per type)
var reqVoteReqs: Set[Seq[Int]]
var reqVoteResps: Set[Seq[Int]]
var aeReqs: Set[Seq[Int]]
var aeResps: Set[Seq[Int]]

// Helpers

func LastTerm(lt) {
    if len(lt) == 0 then 0 else lt[len(lt) - 1]
}

func Min(a, b) {
    if a <= b then a else b
}

func Max(a, b) {
    if a >= b then a else b
}

init {
    currentTerm = {i: 1 for i in 0..N}
    and state = {i: 0 for i in 0..N}
    and votedFor = {i: -1 for i in 0..N}
    and logTerm = {i: [] for i in 0..N}
    and logValue = {i: [] for i in 0..N}
    and commitIndex = {i: 0 for i in 0..N}
    and votesGranted = {i: {j: false for j in 0..N} for i in 0..N}
    and nextIndex = {i: {j: 1 for j in 0..N} for i in 0..N}
    and matchIndex = {i: {j: 0 for j in 0..N} for i in 0..N}
    and pendingResponse = {i: {j: false for j in 0..N} for i in 0..N}
    and acked = {v: -1 for v in 0..MaxVal}
    and electionCtr = 0
    and restartCtr = 0
    and reqVoteReqs = {}
    and reqVoteResps = {}
    and aeReqs = {}
    and aeResps = {}
}

// ============================================================================
// Actions
// ============================================================================

// Server i restarts from stable storage (loses volatile state)
action Restart(i: 0..N) {
    require restartCtr < MaxRestarts

    state = state | {i: 0}
    and votesGranted = votesGranted | {i: {j: false for j in 0..N}}
    and nextIndex = nextIndex | {i: {j: 1 for j in 0..N}}
    and matchIndex = matchIndex | {i: {j: 0 for j in 0..N}}
    and pendingResponse = pendingResponse | {i: {j: false for j in 0..N}}
    and commitIndex = commitIndex | {i: 0}
    and restartCtr = restartCtr + 1
}

// Combined Timeout + RequestVote: server i starts election
action RequestVote(i: 0..N) {
    require electionCtr < MaxElections
    require state[i] == 0 or state[i] == 1

    state = state | {i: 1}
    and currentTerm = currentTerm | {i: currentTerm[i] + 1}
    and votedFor = votedFor | {i: i}
    and votesGranted = votesGranted | {i: {j: j == i for j in 0..N}}
    and electionCtr = electionCtr + 1
    and reqVoteReqs = reqVoteReqs union {
        [currentTerm[i] + 1, i, j, LastTerm(logTerm[i]), len(logTerm[i])]
        for j in 0..N if j != i
    }
}

// Candidate i becomes leader with quorum
action BecomeLeader(i: 0..N) {
    require state[i] == 1
    require len({k in 0..N if votesGranted[i][k]}) * 2 > N + 1

    state = state | {i: 2}
    and nextIndex = nextIndex | {i: {j: len(logTerm[i]) + 1 for j in 0..N}}
    and matchIndex = matchIndex | {i: {j: 0 for j in 0..N}}
    and pendingResponse = pendingResponse | {i: {j: false for j in 0..N}}
}

// Leader i receives client request to add value v
action ClientRequest(i: 0..N, v: 0..MaxVal) {
    require state[i] == 2
    require acked[v] == -1

    logTerm = logTerm | {i: logTerm[i] ++ [currentTerm[i]]}
    and logValue = logValue | {i: logValue[i] ++ [v]}
    and acked = acked | {v: 0}
}

// Leader i sends AppendEntries to follower j
action AppendEntries(i: 0..N, j: 0..N) {
    require i != j
    require state[i] == 2
    require pendingResponse[i][j] == false

    pendingResponse = pendingResponse | {i: pendingResponse[i] | {j: true}}
    and aeReqs = aeReqs union {[
        currentTerm[i],
        i,
        j,
        nextIndex[i][j] - 1,
        if nextIndex[i][j] - 1 > 0 then logTerm[i][nextIndex[i][j] - 2] else 0,
        if nextIndex[i][j] <= len(logTerm[i]) then 1 else 0,
        if nextIndex[i][j] <= len(logTerm[i]) then logTerm[i][nextIndex[i][j] - 1] else 0,
        if nextIndex[i][j] <= len(logTerm[i]) then logValue[i][nextIndex[i][j] - 1] else 0,
        Min(commitIndex[i], Min(len(logTerm[i]), nextIndex[i][j]))
    ]}
}

// Leader i advances commitIndex
action AdvanceCommitIndex(i: 0..N, k: 1..MaxLogLen) {
    require state[i] == 2
    require k <= len(logTerm[i])
    require k > commitIndex[i]
    require logTerm[i][k - 1] == currentTerm[i]
    require len({j in 0..N if matchIndex[i][j] >= k or j == i}) * 2 > N + 1
    // k must be maximum valid index
    require all k2 in 1..MaxLogLen:
        (k2 > k and k2 <= len(logTerm[i]) and logTerm[i][k2 - 1] == currentTerm[i]
         and len({j in 0..N if matchIndex[i][j] >= k2 or j == i}) * 2 > N + 1)
        implies false

    commitIndex = commitIndex | {i: k}
    and acked = {v:
        if acked[v] == 0
           and len({idx in 0..k if idx >= commitIndex[i] and idx < k
                     and idx < len(logValue[i]) and logValue[i][idx] == v}) > 0
        then 1
        else acked[v]
        for v in 0..MaxVal
    }
}

// ============================================================================
// UpdateTerm: any message with higher term causes recipient to step down
// ============================================================================

action UpdateTermReqVoteReq(msg: Seq[Int]) {
    require msg in reqVoteReqs
    require msg[0] > currentTerm[msg[2]]
    currentTerm = currentTerm | {msg[2]: msg[0]}
    and state = state | {msg[2]: 0}
    and votedFor = votedFor | {msg[2]: -1}
}

action UpdateTermReqVoteResp(msg: Seq[Int]) {
    require msg in reqVoteResps
    require msg[0] > currentTerm[msg[2]]
    currentTerm = currentTerm | {msg[2]: msg[0]}
    and state = state | {msg[2]: 0}
    and votedFor = votedFor | {msg[2]: -1}
}

action UpdateTermAEReq(msg: Seq[Int]) {
    require msg in aeReqs
    require msg[0] > currentTerm[msg[2]]
    currentTerm = currentTerm | {msg[2]: msg[0]}
    and state = state | {msg[2]: 0}
    and votedFor = votedFor | {msg[2]: -1}
}

action UpdateTermAEResp(msg: Seq[Int]) {
    require msg in aeResps
    require msg[0] > currentTerm[msg[2]]
    currentTerm = currentTerm | {msg[2]: msg[0]}
    and state = state | {msg[2]: 0}
    and votedFor = votedFor | {msg[2]: -1}
}

// ============================================================================
// HandleRequestVoteRequest: server receives vote request (LessOrEqualTerm)
// ============================================================================

action HandleRequestVoteRequest(msg: Seq[Int]) {
    require msg in reqVoteReqs
    require msg[0] <= currentTerm[msg[2]]

    votedFor = votedFor | {msg[2]:
        if msg[0] == currentTerm[msg[2]]
           and (msg[3] > LastTerm(logTerm[msg[2]])
                or (msg[3] == LastTerm(logTerm[msg[2]])
                    and msg[4] >= len(logTerm[msg[2]])))
           and (votedFor[msg[2]] == -1 or votedFor[msg[2]] == msg[1])
        then msg[1]
        else votedFor[msg[2]]
    }
    and reqVoteReqs = reqVoteReqs diff {msg}
    and reqVoteResps = reqVoteResps union {[
        currentTerm[msg[2]],
        msg[2],
        msg[1],
        if msg[0] == currentTerm[msg[2]]
           and (msg[3] > LastTerm(logTerm[msg[2]])
                or (msg[3] == LastTerm(logTerm[msg[2]])
                    and msg[4] >= len(logTerm[msg[2]])))
           and (votedFor[msg[2]] == -1 or votedFor[msg[2]] == msg[1])
        then 1 else 0
    ]}
}

// ============================================================================
// HandleRequestVoteResponse: candidate tallies votes (EqualTerm)
// ============================================================================

action HandleRequestVoteResponse(msg: Seq[Int]) {
    require msg in reqVoteResps
    require msg[0] == currentTerm[msg[2]]

    votesGranted = votesGranted | {msg[2]:
        if msg[3] == 1
        then votesGranted[msg[2]] | {msg[1]: true}
        else votesGranted[msg[2]]
    }
    and reqVoteResps = reqVoteResps diff {msg}
}

// ============================================================================
// RejectAppendEntriesRequest (LessOrEqualTerm, stale term or log mismatch)
// ============================================================================

action RejectAppendEntriesRequest(msg: Seq[Int]) {
    require msg in aeReqs
    require msg[0] <= currentTerm[msg[2]]
    // Reject if: stale term, OR equal term + follower + log mismatch
    require msg[0] < currentTerm[msg[2]]
         or (msg[0] == currentTerm[msg[2]]
             and state[msg[2]] == 0
             and msg[3] > 0
             and (msg[3] > len(logTerm[msg[2]])
                  or logTerm[msg[2]][msg[3] - 1] != msg[4]))

    aeReqs = aeReqs diff {msg}
    and aeResps = aeResps union {[
        currentTerm[msg[2]], msg[2], msg[1], 0, 0
    ]}
}

// ============================================================================
// AcceptAppendEntriesRequest (EqualTerm, log matches)
// ============================================================================

action AcceptAppendEntriesRequest(msg: Seq[Int]) {
    require msg in aeReqs
    require msg[0] == currentTerm[msg[2]]
    require state[msg[2]] == 0 or state[msg[2]] == 1
    // logOk
    require msg[3] == 0
         or (msg[3] > 0 and msg[3] <= len(logTerm[msg[2]])
             and logTerm[msg[2]][msg[3] - 1] == msg[4])

    state = state | {msg[2]: 0}
    and logTerm = logTerm | {msg[2]:
        if msg[5] == 1 then
            logTerm[msg[2]][0..msg[3]] ++ [msg[6]]
        else if len(logTerm[msg[2]]) > msg[3] then
            logTerm[msg[2]][0..msg[3]]
        else
            logTerm[msg[2]]
    }
    and logValue = logValue | {msg[2]:
        if msg[5] == 1 then
            logValue[msg[2]][0..msg[3]] ++ [msg[7]]
        else if len(logValue[msg[2]]) > msg[3] then
            logValue[msg[2]][0..msg[3]]
        else
            logValue[msg[2]]
    }
    and commitIndex = commitIndex | {msg[2]: msg[8]}
    and aeReqs = aeReqs diff {msg}
    and aeResps = aeResps union {[
        currentTerm[msg[2]], msg[2], msg[1], 1, msg[3] + msg[5]
    ]}
}

// ============================================================================
// HandleAppendEntriesResponse (EqualTerm)
// ============================================================================

action HandleAppendEntriesResponse(msg: Seq[Int]) {
    require msg in aeResps
    require msg[0] == currentTerm[msg[2]]

    nextIndex = nextIndex | {msg[2]:
        if msg[3] == 1
        then nextIndex[msg[2]] | {msg[1]: msg[4] + 1}
        else nextIndex[msg[2]] | {msg[1]: Max(nextIndex[msg[2]][msg[1]] - 1, 1)}
    }
    and matchIndex = matchIndex | {msg[2]:
        if msg[3] == 1
        then matchIndex[msg[2]] | {msg[1]: msg[4]}
        else matchIndex[msg[2]]
    }
    and pendingResponse = pendingResponse | {msg[2]: pendingResponse[msg[2]] | {msg[1]: false}}
    and aeResps = aeResps diff {msg}
}

// ============================================================================
// Invariants
// ============================================================================

// Committed log entries don't diverge across servers
invariant NoLogDivergence {
    all s1 in 0..N: all s2 in 0..N:
        (s1 != s2 and commitIndex[s1] > 0 and commitIndex[s2] > 0)
        implies (all idx in 1..MaxLogLen:
            (idx <= commitIndex[s1] and idx <= commitIndex[s2]
             and idx <= len(logTerm[s1]) and idx <= len(logTerm[s2]))
            implies (logTerm[s1][idx - 1] == logTerm[s2][idx - 1]
                     and logValue[s1][idx - 1] == logValue[s2][idx - 1]))
}

// A non-stale leader has all acknowledged values
invariant LeaderHasAllAckedValues {
    all v in 0..MaxVal:
        acked[v] == 1
        implies not (any i in 0..N:
            state[i] == 2
            and not (any l in 0..N: l != i and currentTerm[l] > currentTerm[i])
            and not (any idx in 0..N:
                idx < len(logValue[i]) and logValue[i][idx] == v))
}
