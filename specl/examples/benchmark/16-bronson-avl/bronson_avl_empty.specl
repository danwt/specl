module BronsonAVL

// Bronson et al. concurrent AVL tree (PPOPP 2010) - writer-only model
// Starts from EMPTY tree. Writers loop, inserting/erasing keys 1..MaxKey.
// Use: specl check bronson_avl_empty.specl --no-deadlock

const MaxAddr: Int   // node address space: 1..MaxAddr (0 = RootHolder)
const MaxKey: Int    // operation key range: 1..MaxKey

// --- Special values ---
// Null = 101, Shrinking = 102, Unlinked = 103, Retry = 104
// DirectionLeft = 105, DirectionRite = 106
// NoRepair = 107, UnlinkReq = 108, RebalanceReq = 109

// --- PC values ---
// Done=0, WriteInv=1, WriteResp=2
// update: 10-19
// attemptUpdate: 20-39
// attemptNodeUpdate: 50-69
// attemptUnlink_nl: 80-85
// nodeCondition: 90-93
// fixHeightAndRebalance: 100-115
// fixHeight_nl: 120-125
// rebalance_nl: 130-145
// rebalanceToRite_nl: 150-169
// rebalanceToLeft_nl: 170-189
// rotateRite_nl: 190-199
// rotateLeft_nl: 210-219
// rotateRiteOverLeft_nl: 230-239
// rotateLeftOverRite_nl: 250-259

// ======== Tree state (indexed by node address 0..14, 0=RootHolder) ========
var ver: Dict[Int, Int]
var key: Dict[Int, Int]
var val: Dict[Int, Int]
var height: Dict[Int, Int]
var parent: Dict[Int, Int]
var left: Dict[Int, Int]
var rite: Dict[Int, Int]
var locked: Dict[Int, Int]

// ======== Process state (indexed by writer id 0..1) ========
var pc: Dict[Int, Int]
var ret: Dict[Int, Int]
var retStack: Dict[Int, Seq[Int]]
var auSaveStack: Dict[Int, Seq[Int]]

// ======== Per-procedure locals (indexed by writer id) ========
// update
var U_k: Dict[Int, Int]
var U_newValue: Dict[Int, Int]
// attemptUpdate
var AU_k: Dict[Int, Int]
var AU_newValue: Dict[Int, Int]
var AU_parent: Dict[Int, Int]
var AU_node: Dict[Int, Int]
var AU_nodeVer: Dict[Int, Int]
var AU_dirToC: Dict[Int, Int]
var AU_child: Dict[Int, Int]
var AU_success: Dict[Int, Int]
var AU_damaged: Dict[Int, Int]
// attemptNodeUpdate
var ANU_newValue: Dict[Int, Int]
var ANU_parent: Dict[Int, Int]
var ANU_node: Dict[Int, Int]
var ANU_prev: Dict[Int, Int]
var ANU_damaged: Dict[Int, Int]
// attemptUnlink_nl
var AUL_parent: Dict[Int, Int]
var AUL_node: Dict[Int, Int]
// nodeCondition
var NC_node: Dict[Int, Int]
// fixHeightAndRebalance
var FHR_node: Dict[Int, Int]
var FHR_condition: Dict[Int, Int]
var FHR_nParent: Dict[Int, Int]
// fixHeight_nl
var FH_node: Dict[Int, Int]
// rebalance_nl
var REB_nParent: Dict[Int, Int]
var REB_n: Dict[Int, Int]
var REB_nL: Dict[Int, Int]
var REB_nR: Dict[Int, Int]
// rebalanceToRite_nl
var REBR_nParent: Dict[Int, Int]
var REBR_n: Dict[Int, Int]
var REBR_nL: Dict[Int, Int]
var REBR_hR0: Dict[Int, Int]
var REBR_nLR: Dict[Int, Int]
var REBR_hLL0: Dict[Int, Int]
var REBR_hLR0: Dict[Int, Int]
// rebalanceToLeft_nl
var REBL_nParent: Dict[Int, Int]
var REBL_n: Dict[Int, Int]
var REBL_nR: Dict[Int, Int]
var REBL_hL0: Dict[Int, Int]
var REBL_nRL: Dict[Int, Int]
var REBL_hRR0: Dict[Int, Int]
var REBL_hRL0: Dict[Int, Int]
// rotateRite_nl
var ROTR_nParent: Dict[Int, Int]
var ROTR_n: Dict[Int, Int]
var ROTR_nL: Dict[Int, Int]
var ROTR_hR: Dict[Int, Int]
var ROTR_hLL: Dict[Int, Int]
var ROTR_nLR: Dict[Int, Int]
var ROTR_hLR: Dict[Int, Int]
// rotateLeft_nl
var ROTL_nParent: Dict[Int, Int]
var ROTL_n: Dict[Int, Int]
var ROTL_hL: Dict[Int, Int]
var ROTL_nR: Dict[Int, Int]
var ROTL_nRL: Dict[Int, Int]
var ROTL_hRL: Dict[Int, Int]
var ROTL_hRR: Dict[Int, Int]
// rotateRiteOverLeft_nl
var ROTROL_nParent: Dict[Int, Int]
var ROTROL_n: Dict[Int, Int]
var ROTROL_nL: Dict[Int, Int]
var ROTROL_hR: Dict[Int, Int]
var ROTROL_hLL: Dict[Int, Int]
var ROTROL_nLR: Dict[Int, Int]
var ROTROL_hLRL: Dict[Int, Int]
// rotateLeftOverRite_nl
var ROTLOR_nParent: Dict[Int, Int]
var ROTLOR_n: Dict[Int, Int]
var ROTLOR_hL: Dict[Int, Int]
var ROTLOR_nR: Dict[Int, Int]
var ROTLOR_nRL: Dict[Int, Int]
var ROTLOR_hRR: Dict[Int, Int]
var ROTLOR_hRLR: Dict[Int, Int]

// ======== Helper functions ========

func NullSafeHeight(e) { if e == 101 then 0 else height[e] }
func MaxPlusOne(x, y) { if y < x then x + 1 else y + 1 }
func Child(addr, dir) { if dir == 105 then left[addr] else rite[addr] }

// Unrolled true height computation (max depth 6 for 14-node tree)
// Workaround: inline max+1 logic to avoid Specl bytecode VM bug with
// nested function calls as arguments to other function calls
func TH5(e5) { if e5 == 101 then 0 else 1 }
func LH5(n5) { TH5(left[n5]) }
func RH5(n5) { TH5(rite[n5]) }
func TH4(e4) { if e4 == 101 then 0 else if RH5(e4) < LH5(e4) then LH5(e4) + 1 else RH5(e4) + 1 }
func LH4(n4) { TH4(left[n4]) }
func RH4(n4) { TH4(rite[n4]) }
func TH3(e3) { if e3 == 101 then 0 else if RH4(e3) < LH4(e3) then LH4(e3) + 1 else RH4(e3) + 1 }
func LH3(n3) { TH3(left[n3]) }
func RH3(n3) { TH3(rite[n3]) }
func TH2(e2) { if e2 == 101 then 0 else if RH3(e2) < LH3(e2) then LH3(e2) + 1 else RH3(e2) + 1 }
func LH2(n2) { TH2(left[n2]) }
func RH2(n2) { TH2(rite[n2]) }
func TH1(e1) { if e1 == 101 then 0 else if RH2(e1) < LH2(e1) then LH2(e1) + 1 else RH2(e1) + 1 }
func LH1(n1) { TH1(left[n1]) }
func RH1(n1) { TH1(rite[n1]) }
func TrueHeight(e0) { if e0 == 101 then 0 else if RH1(e0) < LH1(e0) then LH1(e0) + 1 else RH1(e0) + 1 }

// Find first unused node address (key == Null)
func UnusedAddr() {
    if key[1] == 101 then 1 else if key[2] == 101 then 2 else if key[3] == 101 then 3
    else if key[4] == 101 then 4 else if key[5] == 101 then 5 else if key[6] == 101 then 6
    else if key[7] == 101 then 7 else if key[8] == 101 then 8 else if key[9] == 101 then 9
    else if key[10] == 101 then 10 else if key[11] == 101 then 11 else if key[12] == 101 then 12
    else if key[13] == 101 then 13 else 14
}

// ======== Initial state ========
// Empty tree: RootHolder (0) has no children, all node addresses unused.

init {
    key = {a: 101 for a in 0..MaxAddr}
    and val = {a: 101 for a in 0..MaxAddr}
    and left = {a: 101 for a in 0..MaxAddr}
    and rite = {a: 101 for a in 0..MaxAddr}
    and height = {a: 0 for a in 0..MaxAddr}
    and parent = {a: 101 for a in 0..MaxAddr}
    and ver = {a: 0 for a in 0..MaxAddr}
    and locked = {a: -1 for a in 0..MaxAddr}
    and pc = {0: 1, 1: 1}
    and ret = {0: 101, 1: 101}
    and retStack = {0: [], 1: []}
    and auSaveStack = {0: [], 1: []}
    and U_k = {0: 101, 1: 101}
    and U_newValue = {0: 101, 1: 101}
    and AU_k = {0: 101, 1: 101}
    and AU_newValue = {0: 101, 1: 101}
    and AU_parent = {0: 101, 1: 101}
    and AU_node = {0: 101, 1: 101}
    and AU_nodeVer = {0: 101, 1: 101}
    and AU_dirToC = {0: 101, 1: 101}
    and AU_child = {0: 101, 1: 101}
    and AU_success = {0: 0, 1: 0}
    and AU_damaged = {0: 101, 1: 101}
    and ANU_newValue = {0: 101, 1: 101}
    and ANU_parent = {0: 101, 1: 101}
    and ANU_node = {0: 101, 1: 101}
    and ANU_prev = {0: 101, 1: 101}
    and ANU_damaged = {0: 101, 1: 101}
    and AUL_parent = {0: 101, 1: 101}
    and AUL_node = {0: 101, 1: 101}
    and NC_node = {0: 101, 1: 101}
    and FHR_node = {0: 101, 1: 101}
    and FHR_condition = {0: 101, 1: 101}
    and FHR_nParent = {0: 101, 1: 101}
    and FH_node = {0: 101, 1: 101}
    and REB_nParent = {0: 101, 1: 101}
    and REB_n = {0: 101, 1: 101}
    and REB_nL = {0: 101, 1: 101}
    and REB_nR = {0: 101, 1: 101}
    and REBR_nParent = {0: 101, 1: 101}
    and REBR_n = {0: 101, 1: 101}
    and REBR_nL = {0: 101, 1: 101}
    and REBR_hR0 = {0: 0, 1: 0}
    and REBR_nLR = {0: 101, 1: 101}
    and REBR_hLL0 = {0: 0, 1: 0}
    and REBR_hLR0 = {0: 0, 1: 0}
    and REBL_nParent = {0: 101, 1: 101}
    and REBL_n = {0: 101, 1: 101}
    and REBL_nR = {0: 101, 1: 101}
    and REBL_hL0 = {0: 0, 1: 0}
    and REBL_nRL = {0: 101, 1: 101}
    and REBL_hRR0 = {0: 0, 1: 0}
    and REBL_hRL0 = {0: 0, 1: 0}
    and ROTR_nParent = {0: 101, 1: 101}
    and ROTR_n = {0: 101, 1: 101}
    and ROTR_nL = {0: 101, 1: 101}
    and ROTR_hR = {0: 0, 1: 0}
    and ROTR_hLL = {0: 0, 1: 0}
    and ROTR_nLR = {0: 101, 1: 101}
    and ROTR_hLR = {0: 0, 1: 0}
    and ROTL_nParent = {0: 101, 1: 101}
    and ROTL_n = {0: 101, 1: 101}
    and ROTL_hL = {0: 0, 1: 0}
    and ROTL_nR = {0: 101, 1: 101}
    and ROTL_nRL = {0: 101, 1: 101}
    and ROTL_hRL = {0: 0, 1: 0}
    and ROTL_hRR = {0: 0, 1: 0}
    and ROTROL_nParent = {0: 101, 1: 101}
    and ROTROL_n = {0: 101, 1: 101}
    and ROTROL_nL = {0: 101, 1: 101}
    and ROTROL_hR = {0: 0, 1: 0}
    and ROTROL_hLL = {0: 0, 1: 0}
    and ROTROL_nLR = {0: 101, 1: 101}
    and ROTROL_hLRL = {0: 0, 1: 0}
    and ROTLOR_nParent = {0: 101, 1: 101}
    and ROTLOR_n = {0: 101, 1: 101}
    and ROTLOR_hL = {0: 0, 1: 0}
    and ROTLOR_nR = {0: 101, 1: 101}
    and ROTLOR_nRL = {0: 101, 1: 101}
    and ROTLOR_hRR = {0: 0, 1: 0}
    and ROTLOR_hRLR = {0: 0, 1: 0}
}

// ======================================================================
// WRITER ENTRY/EXIT
// ======================================================================

// writeInv: choose erase operation and key (small key range for empty-tree exploration)
action writeInv_erase(p: 0..1, k: 1..MaxKey) {
    require pc[p] == 1
    U_k = U_k | {p: k}
    and U_newValue = U_newValue | {p: 101}
    and retStack = retStack | {p: retStack[p] ++ [2]}
    and pc = pc | {p: 10}
}

// writeInv: choose insert operation and key
action writeInv_insert(p: 0..1, k: 1..MaxKey) {
    require pc[p] == 1
    U_k = U_k | {p: k}
    and U_newValue = U_newValue | {p: k}
    and retStack = retStack | {p: retStack[p] ++ [2]}
    and pc = pc | {p: 10}
}

// writeResp -> loop back to writeInv
action writeResp(p: 0..1) {
    require pc[p] == 2
    pc = pc | {p: 1}
}

// ======================================================================
// UPDATE (pc 10-19)
// u0=10: loop start. u1=11: erase-fail return. uLock0=12: lock RH.
// u2=13: locked body. u3=14: unlock retry. u4=15: after attemptUpdate. u5=16: return.
// ======================================================================

// u0: tree empty, erase -> return fail
action u0_emptyErase(p: 0..1) {
    require pc[p] == 10
    require rite[0] == 101
    require U_newValue[p] == 101
    ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// u0: tree empty, insert -> lock RH
action u0_emptyInsert(p: 0..1) {
    require pc[p] == 10
    require rite[0] == 101
    require U_newValue[p] != 101
    pc = pc | {p: 12}
}

// u0: tree not empty, ver OK -> call attemptUpdate
action u0_navigate(p: 0..1) {
    require pc[p] == 10
    require rite[0] != 101
    require ver[rite[0]] != 102 and ver[rite[0]] != 103
    retStack = retStack | {p: retStack[p] ++ [15]}
    and AU_k = AU_k | {p: U_k[p]}
    and AU_newValue = AU_newValue | {p: U_newValue[p]}
    and AU_parent = AU_parent | {p: 0}
    and AU_node = AU_node | {p: rite[0]}
    and AU_nodeVer = AU_nodeVer | {p: ver[rite[0]]}
    and pc = pc | {p: 20}
}

// uLock0: lock RootHolder
action uLock0(p: 0..1) {
    require pc[p] == 12
    require locked[0] == -1 or locked[0] == p
    locked = locked | {0: p}
    and pc = pc | {p: 13}
}

// u2: locked body - check if still empty, write new leaf under RH
action u2_writeLeaf(p: 0..1) {
    require pc[p] == 13
    require rite[0] == 101
    // write_new_leaf_under_RootHolder
    key = key | {UnusedAddr(): U_k[p]}
    and val = val | {UnusedAddr(): U_newValue[p]}
    and parent = parent | {UnusedAddr(): 0}
    and height = height | {UnusedAddr(): 1, 0: 2}
    and left = left | {UnusedAddr(): 101}
    and rite = rite | {0: UnusedAddr(), UnusedAddr(): 101}
    and ver = ver | {UnusedAddr(): 0}
    and locked = locked | {0: -1}
    and ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// u2: locked body - rite[RH] no longer null, unlock and retry
action u2_retry(p: 0..1) {
    require pc[p] == 13
    require rite[0] != 101
    locked = locked | {0: -1}
    and pc = pc | {p: 10}
}

// u4: after attemptUpdate returns
action u4(p: 0..1) {
    require pc[p] == 15
    pc = pc | {p: (if ret[p] != 104 then 16 else 10)}
}

// u5: return from update
action u5(p: 0..1) {
    require pc[p] == 16
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ATTEMPT UPDATE (pc 20-39)
// au0=20: read key. au2=22: set direction.
// au3=23: while loop - read child, ver check. au4=24: retry.
// au5=25: child null check. au6=26: erase null child -> fail.
// auLock0=27: lock node. au7=28: locked ver check. au8=29: retry+unlock.
// au9=30: locked - child still null? write leaf or set success=false.
// auT1=31: after fixHeight_nl. auT2=32: unlock, branch.
// au10=33: call fixHeightAndRebalance. au11=34: return success.
// au12=35: not-null child, ver stale -> retry.
// au13=36: call recursive attemptUpdate. au14=37: after recursive return.
// au15=38: return.
// au1=39: key match -> call attemptNodeUpdate. auT3=40: return after.
// ======================================================================

// au0: read key of node, check if matches
action au0(p: 0..1) {
    require pc[p] == 20
    pc = pc | {p: (if key[AU_node[p]] == AU_k[p] then 39 else 22)}
}

// au1 (pc=39): key matches -> call attemptNodeUpdate
action au1(p: 0..1) {
    require pc[p] == 39
    retStack = retStack | {p: retStack[p] ++ [40]}
    and ANU_newValue = ANU_newValue | {p: AU_newValue[p]}
    and ANU_parent = ANU_parent | {p: AU_parent[p]}
    and ANU_node = ANU_node | {p: AU_node[p]}
    and pc = pc | {p: 50}
}

// auT3 (pc=40): return after attemptNodeUpdate
action auT3(p: 0..1) {
    require pc[p] == 40
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// au2 (pc=22): compute direction
action au2(p: 0..1) {
    require pc[p] == 22
    AU_dirToC = AU_dirToC | {p: (if AU_k[p] < key[AU_node[p]] then 105 else 106)}
    and pc = pc | {p: 23}
}

// au3 (pc=23): read child, check ver
action au3(p: 0..1) {
    require pc[p] == 23
    AU_child = AU_child | {p: Child(AU_node[p], AU_dirToC[p])}
    and pc = pc | {p: (if ver[AU_node[p]] != AU_nodeVer[p] then 24 else 25)}
}

// au4 (pc=24): retry (ver changed)
action au4(p: 0..1) {
    require pc[p] == 24
    ret = ret | {p: 104}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// au5 (pc=25): check if child is null
action au5_childNull_erase(p: 0..1) {
    require pc[p] == 25
    require AU_child[p] == 101
    require AU_newValue[p] == 101
    // Erase, element absent -> fail return
    ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

action au5_childNull_insert(p: 0..1) {
    require pc[p] == 25
    require AU_child[p] == 101
    require AU_newValue[p] != 101
    pc = pc | {p: 27}
}

// au5: child not null, check ver
action au5_childNotNull_navigate(p: 0..1) {
    require pc[p] == 25
    require AU_child[p] != 101
    require ver[AU_child[p]] != 102 and ver[AU_child[p]] != 103
    require ver[AU_node[p]] == AU_nodeVer[p]
    // Call recursive attemptUpdate
    auSaveStack = auSaveStack | {p: auSaveStack[p] ++ [AU_k[p], AU_newValue[p], AU_parent[p], AU_node[p], AU_nodeVer[p], AU_dirToC[p]]}
    and retStack = retStack | {p: retStack[p] ++ [37]}
    and AU_parent = AU_parent | {p: AU_node[p]}
    and AU_nodeVer = AU_nodeVer | {p: ver[AU_child[p]]}
    and AU_node = AU_node | {p: AU_child[p]}
    and pc = pc | {p: 20}
}

// au5: child not null, shrinking -> wait (loop back to au3 when not shrinking)
action au5_childNotNull_shrinking(p: 0..1) {
    require pc[p] == 25
    require AU_child[p] != 101
    require ver[AU_child[p]] == 102 or ver[AU_child[p]] == 103
    // Version of child is bad, loop back to au3 to retry
    pc = pc | {p: 23}
}

// au5: child not null, ver OK but node ver changed -> retry
action au5_childNotNull_verStale(p: 0..1) {
    require pc[p] == 25
    require AU_child[p] != 101
    require ver[AU_child[p]] != 102 and ver[AU_child[p]] != 103
    require ver[AU_node[p]] != AU_nodeVer[p]
    ret = ret | {p: 104}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// auLock0 (pc=27): lock AU_node for insert
action auLock0(p: 0..1) {
    require pc[p] == 27
    require locked[AU_node[p]] == -1 or locked[AU_node[p]] == p
    locked = locked | {AU_node[p]: p}
    and pc = pc | {p: 28}
}

// au7 (pc=28): locked - check ver
action au7(p: 0..1) {
    require pc[p] == 28
    pc = pc | {p: (if ver[AU_node[p]] != AU_nodeVer[p] then 29 else 30)}
}

// au8 (pc=29): retry + unlock
action au8(p: 0..1) {
    require pc[p] == 29
    ret = ret | {p: 104}
    and locked = locked | {AU_node[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// au9 (pc=30): locked body - check child still null, write leaf or fail
action au9_childAppeared(p: 0..1) {
    require pc[p] == 30
    require Child(AU_node[p], AU_dirToC[p]) != 101
    AU_success = AU_success | {p: 0}
    and AU_damaged = AU_damaged | {p: 101}
    and pc = pc | {p: 32}
}

action au9_writeLeaf(p: 0..1) {
    require pc[p] == 30
    require Child(AU_node[p], AU_dirToC[p]) == 101
    // write_new_leaf: allocate new node
    key = key | {UnusedAddr(): AU_k[p]}
    and val = val | {UnusedAddr(): AU_newValue[p]}
    and parent = parent | {UnusedAddr(): AU_node[p]}
    and height = height | {UnusedAddr(): 1}
    and ver = ver | {UnusedAddr(): 0}
    and left = left | {UnusedAddr(): 101,
        AU_node[p]: (if AU_k[p] < key[AU_node[p]] then UnusedAddr() else left[AU_node[p]])}
    and rite = rite | {UnusedAddr(): 101,
        AU_node[p]: (if AU_k[p] < key[AU_node[p]] then rite[AU_node[p]] else UnusedAddr())}
    and AU_success = AU_success | {p: 1}
    // call fixHeight_nl(AU_node)
    and retStack = retStack | {p: retStack[p] ++ [31]}
    and FH_node = FH_node | {p: AU_node[p]}
    and pc = pc | {p: 120}
}

// auT1 (pc=31): after fixHeight_nl returns
action auT1(p: 0..1) {
    require pc[p] == 31
    AU_damaged = AU_damaged | {p: ret[p]}
    and pc = pc | {p: 32}
}

// auT2 (pc=32): unlock AU_node, branch on success
action auT2(p: 0..1) {
    require pc[p] == 32
    locked = locked | {AU_node[p]: -1}
    and pc = pc | {p: (if AU_success[p] == 1 then 33 else 23)}
}

// au10 (pc=33): call fixHeightAndRebalance(AU_damaged)
action au10(p: 0..1) {
    require pc[p] == 33
    retStack = retStack | {p: retStack[p] ++ [34]}
    and FHR_node = FHR_node | {p: AU_damaged[p]}
    and pc = pc | {p: 100}
}

// au11 (pc=34): return success
action au11(p: 0..1) {
    require pc[p] == 34
    ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// au14 (pc=37): after recursive attemptUpdate returns - restore AU locals
action au14(p: 0..1) {
    require pc[p] == 37
    AU_k = AU_k | {p: auSaveStack[p][len(auSaveStack[p]) - 6]}
    and AU_newValue = AU_newValue | {p: auSaveStack[p][len(auSaveStack[p]) - 5]}
    and AU_parent = AU_parent | {p: auSaveStack[p][len(auSaveStack[p]) - 4]}
    and AU_node = AU_node | {p: auSaveStack[p][len(auSaveStack[p]) - 3]}
    and AU_nodeVer = AU_nodeVer | {p: auSaveStack[p][len(auSaveStack[p]) - 2]}
    and AU_dirToC = AU_dirToC | {p: auSaveStack[p][len(auSaveStack[p]) - 1]}
    and auSaveStack = auSaveStack | {p: auSaveStack[p][0..len(auSaveStack[p]) - 6]}
    and pc = pc | {p: (if ret[p] != 104 then 38 else 23)}
}

// au15 (pc=38): non-retry return
action au15(p: 0..1) {
    require pc[p] == 38
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ATTEMPT NODE UPDATE (pc 50-69)
// anu0=50: check if erase and val already null
// anu1=51: check if can unlink (single child + erase)
// anuLock0=52: lock parent. anu2=53: check parent valid.
// anu3=54: retry+unlock parent. anuLock1=55: lock node.
// anu4=56: check val. anu5=57: val null -> fail, unlock both.
// anu7=58: call attemptUnlink_nl. anuT0=59: after unlink.
// anu8=60: unlink failed -> retry, unlock both.
// anu10=61: unlock node. anu11=62: call fixHeight_nl(parent).
// anu12=63: after fixHeight_nl. anu13=64: call fixHeightAndRebalance.
// anu14=65: return prev, done.
// anuLock2=66: lock node (update-in-place path).
// anu15=67: check not unlinked. anu16=68: unlinked -> retry+unlock.
// anu17=69: read prev, check conditions. anu18=70: retry+unlock.
// anu19=71: do update-in-place, unlock, return.
// ======================================================================

// anu0: erase and val already null -> fail
action anu0_alreadyNull(p: 0..1) {
    require pc[p] == 50
    require ANU_newValue[p] == 101
    require val[ANU_node[p]] == 101
    ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anu0 -> anu1: not already null (or insert)
action anu0_continue(p: 0..1) {
    require pc[p] == 50
    require ANU_newValue[p] != 101 or val[ANU_node[p]] != 101
    pc = pc | {p: 51}
}

// anu1: erase + can unlink (at most one child) -> lock parent path
action anu1_unlinkPath(p: 0..1) {
    require pc[p] == 51
    require ANU_newValue[p] == 101
    require left[ANU_node[p]] == 101 or rite[ANU_node[p]] == 101
    pc = pc | {p: 52}
}

// anu1: not unlinkable -> update-in-place path
action anu1_updatePath(p: 0..1) {
    require pc[p] == 51
    require ANU_newValue[p] != 101 or (left[ANU_node[p]] != 101 and rite[ANU_node[p]] != 101)
    pc = pc | {p: 66}
}

// anuLock0 (pc=52): lock parent
action anuLock0(p: 0..1) {
    require pc[p] == 52
    require locked[ANU_parent[p]] == -1 or locked[ANU_parent[p]] == p
    locked = locked | {ANU_parent[p]: p}
    and pc = pc | {p: 53}
}

// anu2 (pc=53): check parent still valid
action anu2(p: 0..1) {
    require pc[p] == 53
    pc = pc | {p: (
        if ver[ANU_parent[p]] == 103 or parent[ANU_node[p]] != ANU_parent[p]
        then 54
        else 55
    )}
}

// anu3 (pc=54): retry + unlock parent
action anu3(p: 0..1) {
    require pc[p] == 54
    ret = ret | {p: 104}
    and locked = locked | {ANU_parent[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anuLock1 (pc=55): lock node
action anuLock1(p: 0..1) {
    require pc[p] == 55
    require locked[ANU_node[p]] == -1 or locked[ANU_node[p]] == p
    locked = locked | {ANU_node[p]: p}
    and pc = pc | {p: 56}
}

// anu4 (pc=56): read prev val, check if null
action anu4(p: 0..1) {
    require pc[p] == 56
    ANU_prev = ANU_prev | {p: val[ANU_node[p]]}
    and pc = pc | {p: (if val[ANU_node[p]] == 101 then 57 else 58)}
}

// anu5 (pc=57): val null -> fail, unlock both
action anu5(p: 0..1) {
    require pc[p] == 57
    ret = ret | {p: ANU_prev[p]}
    and locked = locked | {ANU_node[p]: -1}
    and pc = pc | {p: 72}
}

// anu5b (pc=72): unlock parent after anu5
action anu5b(p: 0..1) {
    require pc[p] == 72
    locked = locked | {ANU_parent[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anu7 (pc=58): call attemptUnlink_nl(parent, node)
action anu7(p: 0..1) {
    require pc[p] == 58
    retStack = retStack | {p: retStack[p] ++ [59]}
    and AUL_parent = AUL_parent | {p: ANU_parent[p]}
    and AUL_node = AUL_node | {p: ANU_node[p]}
    and pc = pc | {p: 80}
}

// anuT0 (pc=59): after attemptUnlink_nl
action anuT0_success(p: 0..1) {
    require pc[p] == 59
    require ret[p] == 111
    // Unlink succeeded. unlock node, call fixHeight_nl(parent)
    locked = locked | {ANU_node[p]: -1}
    and retStack = retStack | {p: retStack[p] ++ [63]}
    and FH_node = FH_node | {p: ANU_parent[p]}
    and pc = pc | {p: 120}
}

action anuT0_fail(p: 0..1) {
    require pc[p] == 59
    require ret[p] != 111
    // Unlink failed -> retry, unlock both
    ret = ret | {p: 104}
    and locked = locked | {ANU_node[p]: -1}
    and pc = pc | {p: 73}
}

// anu8b (pc=73): unlock parent after failed unlink
action anu8b(p: 0..1) {
    require pc[p] == 73
    locked = locked | {ANU_parent[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anu12 (pc=63): after fixHeight_nl, get damaged
action anu12(p: 0..1) {
    require pc[p] == 63
    ANU_damaged = ANU_damaged | {p: ret[p]}
    // unlock parent
    and locked = locked | {ANU_parent[p]: -1}
    and pc = pc | {p: 64}
}

// anu13 (pc=64): call fixHeightAndRebalance(damaged)
action anu13(p: 0..1) {
    require pc[p] == 64
    retStack = retStack | {p: retStack[p] ++ [65]}
    and FHR_node = FHR_node | {p: ANU_damaged[p]}
    and pc = pc | {p: 100}
}

// anu14 (pc=65): return prev val
action anu14(p: 0..1) {
    require pc[p] == 65
    ret = ret | {p: ANU_prev[p]}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anuLock2 (pc=66): lock node (update-in-place path)
action anuLock2(p: 0..1) {
    require pc[p] == 66
    require locked[ANU_node[p]] == -1 or locked[ANU_node[p]] == p
    locked = locked | {ANU_node[p]: p}
    and pc = pc | {p: 67}
}

// anu15 (pc=67): check not unlinked
action anu15(p: 0..1) {
    require pc[p] == 67
    pc = pc | {p: (if ver[ANU_node[p]] == 103 then 68 else 69)}
}

// anu16 (pc=68): unlinked -> retry + unlock
action anu16(p: 0..1) {
    require pc[p] == 68
    ret = ret | {p: 104}
    and locked = locked | {ANU_node[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anu17 (pc=69): read prev, check conditions
action anu17(p: 0..1) {
    require pc[p] == 69
    ANU_prev = ANU_prev | {p: val[ANU_node[p]]}
    and pc = pc | {p: (
        if ANU_newValue[p] == 101 and (left[ANU_node[p]] == 101 or rite[ANU_node[p]] == 101)
        then 70
        else 71
    )}
}

// anu18 (pc=70): conditions changed, retry + unlock
action anu18(p: 0..1) {
    require pc[p] == 70
    ret = ret | {p: 104}
    and locked = locked | {ANU_node[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// anu19 (pc=71): update val in place, unlock, return
action anu19(p: 0..1) {
    require pc[p] == 71
    val = val | {ANU_node[p]: ANU_newValue[p]}
    and ret = ret | {p: ANU_prev[p]}
    and locked = locked | {ANU_node[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ATTEMPT UNLINK (pc 80-85) - combined into single action
// Parent and node are both locked. Splice node out of tree.
// ======================================================================

// attemptUnlink_nl: all labels combined (aul0-aul5)
action attemptUnlink(p: 0..1) {
    require pc[p] == 80
    // Check node is child of parent
    require left[AUL_parent[p]] == AUL_node[p] or rite[AUL_parent[p]] == AUL_node[p]
    // Check at most one child
    require left[AUL_node[p]] == 101 or rite[AUL_node[p]] == 101
    // splice = non-null child (or Null if leaf)
    // Splice out: replace parent's pointer to node with splice
    left = left | {AUL_parent[p]: (
        if left[AUL_parent[p]] == AUL_node[p]
        then (if left[AUL_node[p]] != 101 then left[AUL_node[p]] else rite[AUL_node[p]])
        else left[AUL_parent[p]]
    )}
    and rite = rite | {AUL_parent[p]: (
        if rite[AUL_parent[p]] == AUL_node[p]
        then (if left[AUL_node[p]] != 101 then left[AUL_node[p]] else rite[AUL_node[p]])
        else rite[AUL_parent[p]]
    )}
    // Update splice's parent pointer
    and parent = parent | {
        (if left[AUL_node[p]] != 101 then left[AUL_node[p]]
         else if rite[AUL_node[p]] != 101 then rite[AUL_node[p]]
         else AUL_node[p]): (
            if left[AUL_node[p]] != 101 or rite[AUL_node[p]] != 101
            then AUL_parent[p]
            else parent[AUL_node[p]]
        )
    }
    and ver = ver | {AUL_node[p]: 103}
    and val = val | {AUL_node[p]: 101}
    and ret = ret | {p: 111}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// attemptUnlink_nl: fail cases
action attemptUnlink_notChild(p: 0..1) {
    require pc[p] == 80
    require left[AUL_parent[p]] != AUL_node[p] and rite[AUL_parent[p]] != AUL_node[p]
    ret = ret | {p: 110}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

action attemptUnlink_twoChildren(p: 0..1) {
    require pc[p] == 80
    require left[AUL_parent[p]] == AUL_node[p] or rite[AUL_parent[p]] == AUL_node[p]
    require left[AUL_node[p]] != 101 and rite[AUL_node[p]] != 101
    ret = ret | {p: 110}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// NODE CONDITION (pc 90) - combined into single action
// Called on locked node. Returns condition code via ret.
// ======================================================================

action nodeCondition(p: 0..1) {
    require pc[p] == 90
    ret = ret | {p: (
        if (left[NC_node[p]] == 101 or rite[NC_node[p]] == 101) and val[NC_node[p]] == 101
        then 108
        else (
            if NullSafeHeight(left[NC_node[p]]) - NullSafeHeight(rite[NC_node[p]]) < -1
               or NullSafeHeight(left[NC_node[p]]) - NullSafeHeight(rite[NC_node[p]]) > 1
            then 109
            else (
                if height[NC_node[p]] != MaxPlusOne(NullSafeHeight(left[NC_node[p]]), NullSafeHeight(rite[NC_node[p]]))
                then MaxPlusOne(NullSafeHeight(left[NC_node[p]]), NullSafeHeight(rite[NC_node[p]]))
                else 107
            )
        )
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// FIX HEIGHT AND REBALANCE (pc 100-115)
// fhr0=100: loop check. fhr1=101: parent null -> return.
// fhr2=102: call nodeCondition. fhrT1=103: check condition.
// fhr3=104: no repair or unlinked -> return.
// fhr4=105: height fix path. fhrLock0=106: lock node.
// fhr5=107: call fixHeight_nl. fhrT0=108: unlock, set node=ret, loop.
// fhr6=109: rebalance path - read nParent.
// fhrLock1=110: lock nParent. fhr6b=111: check parent valid.
// fhrLock2=112: lock node. fhr7=113: call rebalance_nl.
// fhr8=114: unlock node, set node=ret. fhr9=115: unlock nParent, loop.
// ======================================================================

// fhr0 (pc=100): loop check - node == Null?
action fhr0_null(p: 0..1) {
    require pc[p] == 100
    require FHR_node[p] == 101
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

action fhr0_notNull(p: 0..1) {
    require pc[p] == 100
    require FHR_node[p] != 101
    pc = pc | {p: (if parent[FHR_node[p]] == 101 then 101 else 102)}
}

// fhr1 (pc=101): parent is null -> return
action fhr1(p: 0..1) {
    require pc[p] == 101
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// fhr2 (pc=102): call nodeCondition(FHR_node)
action fhr2(p: 0..1) {
    require pc[p] == 102
    retStack = retStack | {p: retStack[p] ++ [103]}
    and NC_node = NC_node | {p: FHR_node[p]}
    and pc = pc | {p: 90}
}

// fhrT1 (pc=103): got condition, check
// NothingRequired (107) -> advance to parent and loop
// Node unlinked (ver==103) -> advance to parent and loop
// Otherwise -> proceed to fix/rebalance
action fhrT1(p: 0..1) {
    require pc[p] == 103
    FHR_condition = FHR_condition | {p: ret[p]}
    and pc = pc | {p: (
        if ret[p] == 107 or ver[FHR_node[p]] == 103
        then 104
        else 105
    )}
}

// fhr3 (pc=104): nothing required or unlinked -> advance to parent, loop
action fhr3(p: 0..1) {
    require pc[p] == 104
    FHR_node = FHR_node | {p: parent[FHR_node[p]]}
    and pc = pc | {p: 100}
}

// fhr4 (pc=105): check if height fix or rebalance/unlink
action fhr4(p: 0..1) {
    require pc[p] == 105
    pc = pc | {p: (if FHR_condition[p] != 108 and FHR_condition[p] != 109 then 106 else 109)}
}

// fhrLock0 (pc=106): lock node for height fix
action fhrLock0(p: 0..1) {
    require pc[p] == 106
    require locked[FHR_node[p]] == -1 or locked[FHR_node[p]] == p
    locked = locked | {FHR_node[p]: p}
    and pc = pc | {p: 107}
}

// fhr5 (pc=107): call fixHeight_nl(node)
action fhr5(p: 0..1) {
    require pc[p] == 107
    retStack = retStack | {p: retStack[p] ++ [108]}
    and FH_node = FH_node | {p: FHR_node[p]}
    and pc = pc | {p: 120}
}

// fhrT0 (pc=108): unlock node, set node=ret, loop
action fhrT0(p: 0..1) {
    require pc[p] == 108
    locked = locked | {FHR_node[p]: -1}
    and FHR_node = FHR_node | {p: ret[p]}
    and pc = pc | {p: 100}
}

// fhr6 (pc=109): rebalance path - read nParent
action fhr6(p: 0..1) {
    require pc[p] == 109
    FHR_nParent = FHR_nParent | {p: parent[FHR_node[p]]}
    and pc = pc | {p: 110}
}

// fhrLock1 (pc=110): lock nParent
action fhrLock1(p: 0..1) {
    require pc[p] == 110
    require locked[FHR_nParent[p]] == -1 or locked[FHR_nParent[p]] == p
    locked = locked | {FHR_nParent[p]: p}
    and pc = pc | {p: 111}
}

// fhr6b (pc=111): check parent still valid
action fhr6b_valid(p: 0..1) {
    require pc[p] == 111
    require ver[FHR_nParent[p]] != 103
    require parent[FHR_node[p]] == FHR_nParent[p]
    pc = pc | {p: 112}
}

action fhr6b_invalid(p: 0..1) {
    require pc[p] == 111
    require ver[FHR_nParent[p]] == 103 or parent[FHR_node[p]] != FHR_nParent[p]
    // Skip rebalance, just unlock nParent
    locked = locked | {FHR_nParent[p]: -1}
    and pc = pc | {p: 100}
}

// fhrLock2 (pc=112): lock node for rebalance
action fhrLock2(p: 0..1) {
    require pc[p] == 112
    require locked[FHR_node[p]] == -1 or locked[FHR_node[p]] == p
    locked = locked | {FHR_node[p]: p}
    and pc = pc | {p: 113}
}

// fhr7 (pc=113): call rebalance_nl(nParent, node)
action fhr7(p: 0..1) {
    require pc[p] == 113
    retStack = retStack | {p: retStack[p] ++ [114]}
    and REB_nParent = REB_nParent | {p: FHR_nParent[p]}
    and REB_n = REB_n | {p: FHR_node[p]}
    and pc = pc | {p: 130}
}

// fhr8 (pc=114): unlock node, set node=ret
action fhr8(p: 0..1) {
    require pc[p] == 114
    locked = locked | {FHR_node[p]: -1}
    and FHR_node = FHR_node | {p: ret[p]}
    and pc = pc | {p: 115}
}

// fhr9 (pc=115): unlock nParent, loop
action fhr9(p: 0..1) {
    require pc[p] == 115
    locked = locked | {FHR_nParent[p]: -1}
    and pc = pc | {p: 100}
}

// ======================================================================
// FIX HEIGHT (pc 120) - combined into single action
// Called on locked node. Calls nodeCondition internally, updates height.
// ======================================================================

action fixHeight(p: 0..1) {
    require pc[p] == 120
    // nodeCondition inline
    ret = ret | {p: (
        if (left[FH_node[p]] == 101 or rite[FH_node[p]] == 101) and val[FH_node[p]] == 101
        then FH_node[p]
        else if NullSafeHeight(left[FH_node[p]]) - NullSafeHeight(rite[FH_node[p]]) < -1
                or NullSafeHeight(left[FH_node[p]]) - NullSafeHeight(rite[FH_node[p]]) > 1
        then FH_node[p]
        else if height[FH_node[p]] == MaxPlusOne(NullSafeHeight(left[FH_node[p]]), NullSafeHeight(rite[FH_node[p]]))
        then 101
        else parent[FH_node[p]]
    )}
    and height = height | {FH_node[p]: (
        if (left[FH_node[p]] == 101 or rite[FH_node[p]] == 101) and val[FH_node[p]] == 101
        then height[FH_node[p]]
        else if NullSafeHeight(left[FH_node[p]]) - NullSafeHeight(rite[FH_node[p]]) < -1
                or NullSafeHeight(left[FH_node[p]]) - NullSafeHeight(rite[FH_node[p]]) > 1
        then height[FH_node[p]]
        else if height[FH_node[p]] == MaxPlusOne(NullSafeHeight(left[FH_node[p]]), NullSafeHeight(rite[FH_node[p]]))
        then height[FH_node[p]]
        else MaxPlusOne(NullSafeHeight(left[FH_node[p]]), NullSafeHeight(rite[FH_node[p]]))
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// REBALANCE (pc 130-145)
// reb0=130: read nL, nR, check unlink.
// reb_unlink=131: call attemptUnlink. rebT0=132: after unlink.
// reb1=133: unlink succeeded -> call fixHeight_nl(nParent).
// reb2=134: unlink failed -> return n.
// reb3=135: read heights, compute balance, dispatch.
// reb4=136: call rebalanceToRite. reb5=137: return.
// reb6=138: call rebalanceToLeft. reb7=139: return.
// reb8=140: height mismatch -> fix height, call fixHeight_nl(nParent).
// reb9=141: after fixHeight_nl. reb10=142: return null (no repair).
// ======================================================================

// reb0 (pc=130): read children, check unlink
action reb0(p: 0..1) {
    require pc[p] == 130
    REB_nL = REB_nL | {p: left[REB_n[p]]}
    and REB_nR = REB_nR | {p: rite[REB_n[p]]}
    and pc = pc | {p: (
        if (left[REB_n[p]] == 101 or rite[REB_n[p]] == 101) and val[REB_n[p]] == 101
        then 131
        else 135
    )}
}

// reb_unlink (pc=131): call attemptUnlink_nl(nParent, n)
action reb_unlink(p: 0..1) {
    require pc[p] == 131
    retStack = retStack | {p: retStack[p] ++ [132]}
    and AUL_parent = AUL_parent | {p: REB_nParent[p]}
    and AUL_node = AUL_node | {p: REB_n[p]}
    and pc = pc | {p: 80}
}

// rebT0 (pc=132): after unlink
action rebT0_success(p: 0..1) {
    require pc[p] == 132
    require ret[p] == 111
    // call fixHeight_nl(nParent)
    retStack = retStack | {p: retStack[p] ++ [141]}
    and FH_node = FH_node | {p: REB_nParent[p]}
    and pc = pc | {p: 120}
}

action rebT0_fail(p: 0..1) {
    require pc[p] == 132
    require ret[p] != 111
    ret = ret | {p: REB_n[p]}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// reb3 (pc=135): read heights, dispatch
action reb3_rebalToRite(p: 0..1) {
    require pc[p] == 135
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) > 1
    retStack = retStack | {p: retStack[p] ++ [137]}
    and REBR_nParent = REBR_nParent | {p: REB_nParent[p]}
    and REBR_n = REBR_n | {p: REB_n[p]}
    and REBR_nL = REBR_nL | {p: REB_nL[p]}
    and REBR_hR0 = REBR_hR0 | {p: NullSafeHeight(REB_nR[p])}
    and pc = pc | {p: 150}
}

action reb3_rebalToLeft(p: 0..1) {
    require pc[p] == 135
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) < -1
    retStack = retStack | {p: retStack[p] ++ [139]}
    and REBL_nParent = REBL_nParent | {p: REB_nParent[p]}
    and REBL_n = REBL_n | {p: REB_n[p]}
    and REBL_nR = REBL_nR | {p: REB_nR[p]}
    and REBL_hL0 = REBL_hL0 | {p: NullSafeHeight(REB_nL[p])}
    and pc = pc | {p: 170}
}

action reb3_heightFix(p: 0..1) {
    require pc[p] == 135
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) >= -1
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) <= 1
    require MaxPlusOne(NullSafeHeight(REB_nL[p]), NullSafeHeight(REB_nR[p])) != height[REB_n[p]]
    height = height | {REB_n[p]: MaxPlusOne(NullSafeHeight(REB_nL[p]), NullSafeHeight(REB_nR[p]))}
    and retStack = retStack | {p: retStack[p] ++ [141]}
    and FH_node = FH_node | {p: REB_nParent[p]}
    and pc = pc | {p: 120}
}

action reb3_noRepair(p: 0..1) {
    require pc[p] == 135
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) >= -1
    require NullSafeHeight(REB_nL[p]) - NullSafeHeight(REB_nR[p]) <= 1
    require MaxPlusOne(NullSafeHeight(REB_nL[p]), NullSafeHeight(REB_nR[p])) == height[REB_n[p]]
    ret = ret | {p: 101}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// reb5/reb7/reb9 (pc=137,139,141): returns from rebalanceToRite/Left or fixHeight_nl
action reb_return(p: 0..1) {
    require pc[p] == 137 or pc[p] == 139 or pc[p] == 141
    pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// REBALANCE TO RITE (pc 150-169)
// 150: lock nL. 151: read hL, check. 152: no rebal -> unlock, return n.
// 153: read nLR,hLL0,hLR0, branch. 154: call rotateRite (hLL>=hLR).
// 155: after rotateRite, unlock nL. 156: lock nLR (double rot path).
// 157: read hLR, branch. 158: call rotateRite (hLL>=hLR updated).
// 159: after rotateRite, unlock nLR. 160: unlock nL.
// 161: check double rot condition. 162: call rotateRiteOverLeft.
// 163: after rot, unlock nLR. 164: unlock nL.
// 165: fallback - unlock nLR. 166: call rebalanceToLeft.
// 167: after rebalToLeft, return. 168: unlock nL (after main body).
// ======================================================================

// rebr0Lock0 (pc=150): lock nL
action rebr0Lock0(p: 0..1) {
    require pc[p] == 150
    require locked[REBR_nL[p]] == -1 or locked[REBR_nL[p]] == p
    locked = locked | {REBR_nL[p]: p}
    and pc = pc | {p: 151}
}

// rebr1 (pc=151): read hL, check if rebalance still needed
action rebr1(p: 0..1) {
    require pc[p] == 151
    pc = pc | {p: (if height[REBR_nL[p]] - REBR_hR0[p] <= 1 then 152 else 153)}
}

// rebr2 (pc=152): no rebalance needed, unlock nL, return n
action rebr2(p: 0..1) {
    require pc[p] == 152
    ret = ret | {p: REBR_n[p]}
    and locked = locked | {REBR_nL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// rebr_inner (pc=153): read nLR, hLL0, hLR0, decide rotation
action rebr_simpleRotate(p: 0..1) {
    require pc[p] == 153
    require NullSafeHeight(left[REBR_nL[p]]) >= NullSafeHeight(rite[REBR_nL[p]])
    // call rotateRite_nl(nParent, n, nL, hR0, hLL0, nLR, hLR0)
    REBR_nLR = REBR_nLR | {p: rite[REBR_nL[p]]}
    and REBR_hLL0 = REBR_hLL0 | {p: NullSafeHeight(left[REBR_nL[p]])}
    and REBR_hLR0 = REBR_hLR0 | {p: NullSafeHeight(rite[REBR_nL[p]])}
    and retStack = retStack | {p: retStack[p] ++ [155]}
    and ROTR_nParent = ROTR_nParent | {p: REBR_nParent[p]}
    and ROTR_n = ROTR_n | {p: REBR_n[p]}
    and ROTR_nL = ROTR_nL | {p: REBR_nL[p]}
    and ROTR_hR = ROTR_hR | {p: REBR_hR0[p]}
    and ROTR_hLL = ROTR_hLL | {p: NullSafeHeight(left[REBR_nL[p]])}
    and ROTR_nLR = ROTR_nLR | {p: rite[REBR_nL[p]]}
    and ROTR_hLR = ROTR_hLR | {p: NullSafeHeight(rite[REBR_nL[p]])}
    and pc = pc | {p: 190}
}

action rebr_needInnerCheck(p: 0..1) {
    require pc[p] == 153
    require NullSafeHeight(left[REBR_nL[p]]) < NullSafeHeight(rite[REBR_nL[p]])
    REBR_nLR = REBR_nLR | {p: rite[REBR_nL[p]]}
    and REBR_hLL0 = REBR_hLL0 | {p: NullSafeHeight(left[REBR_nL[p]])}
    and REBR_hLR0 = REBR_hLR0 | {p: NullSafeHeight(rite[REBR_nL[p]])}
    and pc = pc | {p: 156}
}

// rebr4 (pc=155): after rotateRite, unlock nL
action rebr4(p: 0..1) {
    require pc[p] == 155
    locked = locked | {REBR_nL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// rebrLock1 (pc=156): lock nLR
action rebrLock1(p: 0..1) {
    require pc[p] == 156
    require locked[REBR_nLR[p]] == -1 or locked[REBR_nLR[p]] == p
    locked = locked | {REBR_nLR[p]: p}
    and pc = pc | {p: 157}
}

// rebr5 (pc=157): read hLR, decide rotation
action rebr5_simpleRotate(p: 0..1) {
    require pc[p] == 157
    require REBR_hLL0[p] >= height[REBR_nLR[p]]
    // call rotateRite
    retStack = retStack | {p: retStack[p] ++ [159]}
    and ROTR_nParent = ROTR_nParent | {p: REBR_nParent[p]}
    and ROTR_n = ROTR_n | {p: REBR_n[p]}
    and ROTR_nL = ROTR_nL | {p: REBR_nL[p]}
    and ROTR_hR = ROTR_hR | {p: REBR_hR0[p]}
    and ROTR_hLL = ROTR_hLL | {p: REBR_hLL0[p]}
    and ROTR_nLR = ROTR_nLR | {p: REBR_nLR[p]}
    and ROTR_hLR = ROTR_hLR | {p: height[REBR_nLR[p]]}
    and pc = pc | {p: 190}
}

action rebr5_doubleCheck(p: 0..1) {
    require pc[p] == 157
    require REBR_hLL0[p] < height[REBR_nLR[p]]
    pc = pc | {p: 161}
}

// rebr_afterRotUnlockNLR (pc=159): unlock nLR after rotate
action rebr_afterRotUnlockNLR(p: 0..1) {
    require pc[p] == 159
    locked = locked | {REBR_nLR[p]: -1}
    and pc = pc | {p: 160}
}

// rebr_afterRotUnlockNL (pc=160): unlock nL
action rebr_afterRotUnlockNL(p: 0..1) {
    require pc[p] == 160
    locked = locked | {REBR_nL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// rebr_doubleCheck (pc=161): check double rotation condition
action rebr_doubleRot(p: 0..1) {
    require pc[p] == 161
    require REBR_hLL0[p] - NullSafeHeight(left[REBR_nLR[p]]) >= -1
    require REBR_hLL0[p] - NullSafeHeight(left[REBR_nLR[p]]) <= 1
    require not ((REBR_hLL0[p] == 0 or NullSafeHeight(left[REBR_nLR[p]]) == 0) and val[REBR_nL[p]] == 101)
    // call rotateRiteOverLeft
    retStack = retStack | {p: retStack[p] ++ [163]}
    and ROTROL_nParent = ROTROL_nParent | {p: REBR_nParent[p]}
    and ROTROL_n = ROTROL_n | {p: REBR_n[p]}
    and ROTROL_nL = ROTROL_nL | {p: REBR_nL[p]}
    and ROTROL_hR = ROTROL_hR | {p: REBR_hR0[p]}
    and ROTROL_hLL = ROTROL_hLL | {p: REBR_hLL0[p]}
    and ROTROL_nLR = ROTROL_nLR | {p: REBR_nLR[p]}
    and ROTROL_hLRL = ROTROL_hLRL | {p: NullSafeHeight(left[REBR_nLR[p]])}
    and pc = pc | {p: 230}
}

action rebr_fallback(p: 0..1) {
    require pc[p] == 161
    require not (
        REBR_hLL0[p] - NullSafeHeight(left[REBR_nLR[p]]) >= -1
        and REBR_hLL0[p] - NullSafeHeight(left[REBR_nLR[p]]) <= 1
        and not ((REBR_hLL0[p] == 0 or NullSafeHeight(left[REBR_nLR[p]]) == 0) and val[REBR_nL[p]] == 101)
    )
    // unlock nLR, call rebalanceToLeft(n, nL, nLR, hLL0)
    locked = locked | {REBR_nLR[p]: -1}
    and retStack = retStack | {p: retStack[p] ++ [167]}
    and REBL_nParent = REBL_nParent | {p: REBR_n[p]}
    and REBL_n = REBL_n | {p: REBR_nL[p]}
    and REBL_nR = REBL_nR | {p: REBR_nLR[p]}
    and REBL_hL0 = REBL_hL0 | {p: REBR_hLL0[p]}
    and pc = pc | {p: 170}
}

// rebr_afterDoubleRot (pc=163): unlock nLR
action rebr_afterDoubleRot163(p: 0..1) {
    require pc[p] == 163
    locked = locked | {REBR_nLR[p]: -1}
    and pc = pc | {p: 164}
}

// pc=164: unlock nL
action rebr_afterDoubleRot164(p: 0..1) {
    require pc[p] == 164
    locked = locked | {REBR_nL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// pc=167: after rebalanceToLeft fallback, return (nL still locked from rebr!)
// pc=167: after rebalanceToLeft fallback â€” unlock nL then return
action rebr_afterFallback(p: 0..1) {
    require pc[p] == 167
    locked = locked | {REBR_nL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// REBALANCE TO LEFT (pc 170-189) - mirror of rebalanceToRite
// ======================================================================

// rebl0Lock0 (pc=170): lock nR
action rebl0Lock0(p: 0..1) {
    require pc[p] == 170
    require locked[REBL_nR[p]] == -1 or locked[REBL_nR[p]] == p
    locked = locked | {REBL_nR[p]: p}
    and pc = pc | {p: 171}
}

// rebl1 (pc=171): read hR, check
action rebl1(p: 0..1) {
    require pc[p] == 171
    pc = pc | {p: (if REBL_hL0[p] - height[REBL_nR[p]] >= -1 then 172 else 173)}
}

// rebl2 (pc=172): no rebalance, unlock nR, return n
action rebl2(p: 0..1) {
    require pc[p] == 172
    ret = ret | {p: REBL_n[p]}
    and locked = locked | {REBL_nR[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// rebl_inner (pc=173): read nRL, hRR0, hRL0, decide
action rebl_simpleRotate(p: 0..1) {
    require pc[p] == 173
    require NullSafeHeight(rite[REBL_nR[p]]) >= NullSafeHeight(left[REBL_nR[p]])
    REBL_nRL = REBL_nRL | {p: left[REBL_nR[p]]}
    and REBL_hRR0 = REBL_hRR0 | {p: NullSafeHeight(rite[REBL_nR[p]])}
    and REBL_hRL0 = REBL_hRL0 | {p: NullSafeHeight(left[REBL_nR[p]])}
    and retStack = retStack | {p: retStack[p] ++ [175]}
    and ROTL_nParent = ROTL_nParent | {p: REBL_nParent[p]}
    and ROTL_n = ROTL_n | {p: REBL_n[p]}
    and ROTL_hL = ROTL_hL | {p: REBL_hL0[p]}
    and ROTL_nR = ROTL_nR | {p: REBL_nR[p]}
    and ROTL_nRL = ROTL_nRL | {p: left[REBL_nR[p]]}
    and ROTL_hRL = ROTL_hRL | {p: NullSafeHeight(left[REBL_nR[p]])}
    and ROTL_hRR = ROTL_hRR | {p: NullSafeHeight(rite[REBL_nR[p]])}
    and pc = pc | {p: 210}
}

action rebl_needInnerCheck(p: 0..1) {
    require pc[p] == 173
    require NullSafeHeight(rite[REBL_nR[p]]) < NullSafeHeight(left[REBL_nR[p]])
    REBL_nRL = REBL_nRL | {p: left[REBL_nR[p]]}
    and REBL_hRR0 = REBL_hRR0 | {p: NullSafeHeight(rite[REBL_nR[p]])}
    and REBL_hRL0 = REBL_hRL0 | {p: NullSafeHeight(left[REBL_nR[p]])}
    and pc = pc | {p: 176}
}

// rebl4 (pc=175): after rotateLeft, unlock nR
action rebl4(p: 0..1) {
    require pc[p] == 175
    locked = locked | {REBL_nR[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// reblLock1 (pc=176): lock nRL
action reblLock1(p: 0..1) {
    require pc[p] == 176
    require locked[REBL_nRL[p]] == -1 or locked[REBL_nRL[p]] == p
    locked = locked | {REBL_nRL[p]: p}
    and pc = pc | {p: 177}
}

// rebl5 (pc=177): read hRL, decide
action rebl5_simpleRotate(p: 0..1) {
    require pc[p] == 177
    require REBL_hRR0[p] >= height[REBL_nRL[p]]
    retStack = retStack | {p: retStack[p] ++ [179]}
    and ROTL_nParent = ROTL_nParent | {p: REBL_nParent[p]}
    and ROTL_n = ROTL_n | {p: REBL_n[p]}
    and ROTL_hL = ROTL_hL | {p: REBL_hL0[p]}
    and ROTL_nR = ROTL_nR | {p: REBL_nR[p]}
    and ROTL_nRL = ROTL_nRL | {p: REBL_nRL[p]}
    and ROTL_hRL = ROTL_hRL | {p: height[REBL_nRL[p]]}
    and ROTL_hRR = ROTL_hRR | {p: REBL_hRR0[p]}
    and pc = pc | {p: 210}
}

action rebl5_doubleCheck(p: 0..1) {
    require pc[p] == 177
    require REBL_hRR0[p] < height[REBL_nRL[p]]
    pc = pc | {p: 181}
}

// rebl_afterRotUnlockNR (pc=179): unlock nR after rotate
action rebl_afterRotUnlockNR(p: 0..1) {
    require pc[p] == 179
    locked = locked | {REBL_nR[p]: -1}
    and pc = pc | {p: 180}
}

// pc=180: unlock nRL
action rebl_afterRotUnlockNRL(p: 0..1) {
    require pc[p] == 180
    locked = locked | {REBL_nRL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// rebl_doubleCheck (pc=181)
action rebl_doubleRot(p: 0..1) {
    require pc[p] == 181
    require REBL_hRR0[p] - NullSafeHeight(rite[REBL_nRL[p]]) >= -1
    require REBL_hRR0[p] - NullSafeHeight(rite[REBL_nRL[p]]) <= 1
    require not ((REBL_hRR0[p] == 0 or NullSafeHeight(rite[REBL_nRL[p]]) == 0) and val[REBL_nR[p]] == 101)
    retStack = retStack | {p: retStack[p] ++ [183]}
    and ROTLOR_nParent = ROTLOR_nParent | {p: REBL_nParent[p]}
    and ROTLOR_n = ROTLOR_n | {p: REBL_n[p]}
    and ROTLOR_hL = ROTLOR_hL | {p: REBL_hL0[p]}
    and ROTLOR_nR = ROTLOR_nR | {p: REBL_nR[p]}
    and ROTLOR_nRL = ROTLOR_nRL | {p: REBL_nRL[p]}
    and ROTLOR_hRR = ROTLOR_hRR | {p: REBL_hRR0[p]}
    and ROTLOR_hRLR = ROTLOR_hRLR | {p: NullSafeHeight(rite[REBL_nRL[p]])}
    and pc = pc | {p: 250}
}

action rebl_fallback(p: 0..1) {
    require pc[p] == 181
    require not (
        REBL_hRR0[p] - NullSafeHeight(rite[REBL_nRL[p]]) >= -1
        and REBL_hRR0[p] - NullSafeHeight(rite[REBL_nRL[p]]) <= 1
        and not ((REBL_hRR0[p] == 0 or NullSafeHeight(rite[REBL_nRL[p]]) == 0) and val[REBL_nR[p]] == 101)
    )
    locked = locked | {REBL_nRL[p]: -1}
    and retStack = retStack | {p: retStack[p] ++ [187]}
    and REBR_nParent = REBR_nParent | {p: REBL_n[p]}
    and REBR_n = REBR_n | {p: REBL_nR[p]}
    and REBR_nL = REBR_nL | {p: REBL_nRL[p]}
    and REBR_hR0 = REBR_hR0 | {p: REBL_hRR0[p]}
    and pc = pc | {p: 150}
}

// pc=183: unlock nR after double rot
action rebl_afterDoubleRot183(p: 0..1) {
    require pc[p] == 183
    locked = locked | {REBL_nR[p]: -1}
    and pc = pc | {p: 184}
}

// pc=184: unlock nRL
action rebl_afterDoubleRot184(p: 0..1) {
    require pc[p] == 184
    locked = locked | {REBL_nRL[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// pc=187: after rebalanceToRite fallback â€” unlock nR then return
action rebl_afterFallback(p: 0..1) {
    require pc[p] == 187
    locked = locked | {REBL_nR[p]: -1}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ROTATE RITE (pc 190) - combined into single action
// All 3 nodes (nParent, n, nL) are locked.
// ======================================================================

action rotateRite(p: 0..1) {
    require pc[p] == 190
    // Set ver[n] to Shrinking then restore after rotation
    ver = ver | {ROTR_n[p]: ver[ROTR_n[p]] + 1}
    // Move nLR from nL's right to n's left
    and left = left | {
        ROTR_n[p]: ROTR_nLR[p],
        ROTR_nParent[p]: (if left[ROTR_nParent[p]] == ROTR_n[p] then ROTR_nL[p] else left[ROTR_nParent[p]])
    }
    and rite = rite | {
        ROTR_nL[p]: ROTR_n[p],
        ROTR_nParent[p]: (if left[ROTR_nParent[p]] == ROTR_n[p] then rite[ROTR_nParent[p]] else ROTR_nL[p])
    }
    and parent = parent | {
        ROTR_n[p]: ROTR_nL[p],
        ROTR_nL[p]: ROTR_nParent[p],
        (if ROTR_nLR[p] != 101 then ROTR_nLR[p] else ROTR_n[p]): (if ROTR_nLR[p] != 101 then ROTR_n[p] else parent[ROTR_n[p]])
    }
    and height = height | {
        ROTR_n[p]: MaxPlusOne(ROTR_hLR[p], ROTR_hR[p]),
        ROTR_nL[p]: MaxPlusOne(ROTR_hLL[p], MaxPlusOne(ROTR_hLR[p], ROTR_hR[p]))
    }
    // Return value: which node might need further rebalancing
    and ret = ret | {p: (
        if ROTR_hLR[p] - ROTR_hR[p] < -1 or ROTR_hLR[p] - ROTR_hR[p] > 1 then ROTR_n[p]
        else if (ROTR_nLR[p] == 101 or ROTR_hR[p] == 0) and val[ROTR_n[p]] == 101 then ROTR_n[p]
        else if ROTR_hLL[p] - MaxPlusOne(ROTR_hLR[p], ROTR_hR[p]) < -1 or ROTR_hLL[p] - MaxPlusOne(ROTR_hLR[p], ROTR_hR[p]) > 1 then ROTR_nL[p]
        else if ROTR_hLL[p] == 0 and val[ROTR_nL[p]] == 101 then ROTR_nL[p]
        else parent[ROTR_nParent[p]]
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ROTATE LEFT (pc 210) - mirror of rotateRite, combined
// ======================================================================

action rotateLeft(p: 0..1) {
    require pc[p] == 210
    ver = ver | {ROTL_n[p]: ver[ROTL_n[p]] + 1}
    and rite = rite | {
        ROTL_n[p]: ROTL_nRL[p],
        ROTL_nParent[p]: (if left[ROTL_nParent[p]] == ROTL_n[p] then rite[ROTL_nParent[p]] else ROTL_nR[p])
    }
    and left = left | {
        ROTL_nR[p]: ROTL_n[p],
        ROTL_nParent[p]: (if left[ROTL_nParent[p]] == ROTL_n[p] then ROTL_nR[p] else left[ROTL_nParent[p]])
    }
    and parent = parent | {
        ROTL_n[p]: ROTL_nR[p],
        ROTL_nR[p]: ROTL_nParent[p],
        (if ROTL_nRL[p] != 101 then ROTL_nRL[p] else ROTL_n[p]): (if ROTL_nRL[p] != 101 then ROTL_n[p] else parent[ROTL_n[p]])
    }
    and height = height | {
        ROTL_n[p]: MaxPlusOne(ROTL_hL[p], ROTL_hRL[p]),
        ROTL_nR[p]: MaxPlusOne(MaxPlusOne(ROTL_hL[p], ROTL_hRL[p]), ROTL_hRR[p])
    }
    and ret = ret | {p: (
        if ROTL_hRL[p] - ROTL_hL[p] < -1 or ROTL_hRL[p] - ROTL_hL[p] > 1 then ROTL_n[p]
        else if (ROTL_nRL[p] == 101 or ROTL_hL[p] == 0) and val[ROTL_n[p]] == 101 then ROTL_n[p]
        else if ROTL_hRR[p] - MaxPlusOne(ROTL_hL[p], ROTL_hRL[p]) < -1 or ROTL_hRR[p] - MaxPlusOne(ROTL_hL[p], ROTL_hRL[p]) > 1 then ROTL_nR[p]
        else if ROTL_hRR[p] == 0 and val[ROTL_nR[p]] == 101 then ROTL_nR[p]
        else parent[ROTL_nParent[p]]
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ROTATE RITE OVER LEFT (pc 230) - double rotation, combined
// ======================================================================

action rotateRiteOverLeft(p: 0..1) {
    require pc[p] == 230
    // nLRL = left[nLR], nLRR = rite[nLR], hLRR = NullSafeHeight(nLRR)
    ver = ver | {ROTROL_n[p]: ver[ROTROL_n[p]] + 1, ROTROL_nL[p]: ver[ROTROL_nL[p]] + 1}
    // n.left = nLRR, nL.rite = nLRL, nLR.left = nL, nLR.rite = n
    and left = left | {
        ROTROL_n[p]: rite[ROTROL_nLR[p]],
        ROTROL_nLR[p]: ROTROL_nL[p],
        ROTROL_nParent[p]: (if left[ROTROL_nParent[p]] == ROTROL_n[p] then ROTROL_nLR[p] else left[ROTROL_nParent[p]])
    }
    and rite = rite | {
        ROTROL_nL[p]: left[ROTROL_nLR[p]],
        ROTROL_nLR[p]: ROTROL_n[p],
        ROTROL_nParent[p]: (if left[ROTROL_nParent[p]] == ROTROL_n[p] then rite[ROTROL_nParent[p]] else ROTROL_nLR[p])
    }
    and parent = parent | {
        ROTROL_n[p]: ROTROL_nLR[p],
        ROTROL_nL[p]: ROTROL_nLR[p],
        ROTROL_nLR[p]: ROTROL_nParent[p],
        (if rite[ROTROL_nLR[p]] != 101 then rite[ROTROL_nLR[p]] else ROTROL_n[p]):
            (if rite[ROTROL_nLR[p]] != 101 then ROTROL_n[p] else parent[ROTROL_n[p]]),
        (if left[ROTROL_nLR[p]] != 101 then left[ROTROL_nLR[p]] else ROTROL_nL[p]):
            (if left[ROTROL_nLR[p]] != 101 then ROTROL_nL[p] else parent[ROTROL_nL[p]])
    }
    and height = height | {
        ROTROL_n[p]: MaxPlusOne(NullSafeHeight(rite[ROTROL_nLR[p]]), ROTROL_hR[p]),
        ROTROL_nL[p]: MaxPlusOne(ROTROL_hLL[p], ROTROL_hLRL[p]),
        ROTROL_nLR[p]: MaxPlusOne(MaxPlusOne(ROTROL_hLL[p], ROTROL_hLRL[p]), MaxPlusOne(NullSafeHeight(rite[ROTROL_nLR[p]]), ROTROL_hR[p]))
    }
    and ret = ret | {p: (
        if NullSafeHeight(rite[ROTROL_nLR[p]]) - ROTROL_hR[p] < -1 or NullSafeHeight(rite[ROTROL_nLR[p]]) - ROTROL_hR[p] > 1
        then ROTROL_n[p]
        else if (rite[ROTROL_nLR[p]] == 101 or ROTROL_hR[p] == 0) and val[ROTROL_n[p]] == 101
        then ROTROL_n[p]
        else if MaxPlusOne(ROTROL_hLL[p], ROTROL_hLRL[p]) - MaxPlusOne(NullSafeHeight(rite[ROTROL_nLR[p]]), ROTROL_hR[p]) < -1
                or MaxPlusOne(ROTROL_hLL[p], ROTROL_hLRL[p]) - MaxPlusOne(NullSafeHeight(rite[ROTROL_nLR[p]]), ROTROL_hR[p]) > 1
        then ROTROL_nLR[p]
        else parent[ROTROL_nParent[p]]
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// ROTATE LEFT OVER RITE (pc 250) - mirror of rotateRiteOverLeft
// ======================================================================

action rotateLeftOverRite(p: 0..1) {
    require pc[p] == 250
    ver = ver | {ROTLOR_n[p]: ver[ROTLOR_n[p]] + 1, ROTLOR_nR[p]: ver[ROTLOR_nR[p]] + 1}
    and rite = rite | {
        ROTLOR_n[p]: left[ROTLOR_nRL[p]],
        ROTLOR_nRL[p]: ROTLOR_nR[p],
        ROTLOR_nParent[p]: (if left[ROTLOR_nParent[p]] == ROTLOR_n[p] then rite[ROTLOR_nParent[p]] else ROTLOR_nRL[p])
    }
    and left = left | {
        ROTLOR_nR[p]: rite[ROTLOR_nRL[p]],
        ROTLOR_nRL[p]: ROTLOR_n[p],
        ROTLOR_nParent[p]: (if left[ROTLOR_nParent[p]] == ROTLOR_n[p] then ROTLOR_nRL[p] else left[ROTLOR_nParent[p]])
    }
    and parent = parent | {
        ROTLOR_n[p]: ROTLOR_nRL[p],
        ROTLOR_nR[p]: ROTLOR_nRL[p],
        ROTLOR_nRL[p]: ROTLOR_nParent[p],
        (if left[ROTLOR_nRL[p]] != 101 then left[ROTLOR_nRL[p]] else ROTLOR_n[p]):
            (if left[ROTLOR_nRL[p]] != 101 then ROTLOR_n[p] else parent[ROTLOR_n[p]]),
        (if rite[ROTLOR_nRL[p]] != 101 then rite[ROTLOR_nRL[p]] else ROTLOR_nR[p]):
            (if rite[ROTLOR_nRL[p]] != 101 then ROTLOR_nR[p] else parent[ROTLOR_nR[p]])
    }
    and height = height | {
        ROTLOR_n[p]: MaxPlusOne(ROTLOR_hL[p], NullSafeHeight(left[ROTLOR_nRL[p]])),
        ROTLOR_nR[p]: MaxPlusOne(ROTLOR_hRLR[p], ROTLOR_hRR[p]),
        ROTLOR_nRL[p]: MaxPlusOne(MaxPlusOne(ROTLOR_hL[p], NullSafeHeight(left[ROTLOR_nRL[p]])), MaxPlusOne(ROTLOR_hRLR[p], ROTLOR_hRR[p]))
    }
    and ret = ret | {p: (
        if NullSafeHeight(left[ROTLOR_nRL[p]]) - ROTLOR_hL[p] < -1 or NullSafeHeight(left[ROTLOR_nRL[p]]) - ROTLOR_hL[p] > 1
        then ROTLOR_n[p]
        else if (left[ROTLOR_nRL[p]] == 101 or ROTLOR_hL[p] == 0) and val[ROTLOR_n[p]] == 101
        then ROTLOR_n[p]
        else if MaxPlusOne(ROTLOR_hRLR[p], ROTLOR_hRR[p]) - MaxPlusOne(ROTLOR_hL[p], NullSafeHeight(left[ROTLOR_nRL[p]])) < -1
                or MaxPlusOne(ROTLOR_hRLR[p], ROTLOR_hRR[p]) - MaxPlusOne(ROTLOR_hL[p], NullSafeHeight(left[ROTLOR_nRL[p]])) > 1
        then ROTLOR_nRL[p]
        else parent[ROTLOR_nParent[p]]
    )}
    and pc = pc | {p: retStack[p][len(retStack[p]) - 1]}
    and retStack = retStack | {p: retStack[p][0..len(retStack[p]) - 1]}
}

// ======================================================================
// INVARIANT: Quiescence balance guarantee
// When both writers are done, the tree must be balanced (AVL property).
// ======================================================================

// Check balance when both writers are idle (at writeInv, pc=1)
invariant QuiescenceBalanced {
    not (pc[0] == 1 and pc[1] == 1)
    or (all a in 1..MaxAddr:
        (key[a] == 101 or ver[a] == 103)
        or (TrueHeight(left[a]) - TrueHeight(rite[a]) > -2
            and TrueHeight(left[a]) - TrueHeight(rite[a]) < 2)
    )
}
