module Raft

// ============================================================================
// Production-Grade Raft Consensus Specification
// ============================================================================
// Based on: Ongaro & Ousterhout, "In Search of an Understandable Consensus Algorithm"
// Extended Technical Report: https://raft.github.io/raft.pdf
//
// This specification models the complete Raft protocol with:
// - Explicit network modeling with separate message sets per RPC type
// - Full RPC request/response protocol (RequestVote, AppendEntries)
// - Leader state tracking (nextIndex, matchIndex)
// - Proper prevLogIndex/prevLogTerm consistency checking
// - All five safety properties from Figure 3 of the paper
// - 1-based indexing (consistent with paper and canonical TLA+ spec)
//
// Usage: specl check raft.specl -c N=2 -c MaxTerm=2 -c MaxLogLen=2
//
// Messages are encoded as 6-element sequences to work within Specl's type system:
// RequestVoteRequest: [1, src, dest, term, lastLogIdx, lastLogTerm]
// RequestVoteResponse: [2, src, dest, term, voteGranted (0/1), 0]
// AppendEntriesRequest: [3, src, dest, term, prevLogIdx, prevLogTerm]
// AppendEntriesResponse: [4, src, dest, term, success (0/1), matchIdx]
// ============================================================================

const N: Int
const MaxTerm: Int
const MaxLogLen: Int

// ============================================================================
// Server State
// ============================================================================

// Persistent state
var currentTerm: Dict[Int, Int]  // latest term server has seen
var votedFor: Dict[Int, Int]     // candidateId that received vote (-1 if none)
var log: Dict[Int, Seq[Int]]     // log entries (1-based indexing)

// Volatile state
var commitIndex: Dict[Int, Int]  // highest log entry known committed
var role: Dict[Int, Int]         // 0=Follower, 1=Candidate, 2=Leader

// Leader state
var nextIndex: Dict[Int, Dict[Int, Int]]   // next log index to send to each follower
var matchIndex: Dict[Int, Dict[Int, Int]]  // highest log entry replicated on each follower

// Candidate state
var votesGranted: Dict[Int, Dict[Int, Bool]]  // votes received

// Network - separate sets for each message type (6-element sequences)
var requestVoteReqs: Set[Seq[Int]]
var requestVoteResps: Set[Seq[Int]]
var appendEntriesReqs: Set[Seq[Int]]
var appendEntriesResps: Set[Seq[Int]]

// ============================================================================
// Helper Functions
// ============================================================================

func LastLogIndex(l) {
    len(l)
}

func LastLogTerm(l) {
    if len(l) == 0 then 0 else l[len(l)]
}

func LogTerm(l, i) {
    if i == 0 then 0
    else if i > len(l) then -1
    else l[i]
}

func Min(a, b) {
    if a <= b then a else b
}

// ============================================================================
// Initial State
// ============================================================================

init {
    currentTerm = {s: 0 for s in 0..N}
    and votedFor = {s: -1 for s in 0..N}
    and log = {s: [] for s in 0..N}
    and commitIndex = {s: 0 for s in 0..N}
    and role = {s: 0 for s in 0..N}
    and nextIndex = {s: {t: 1 for t in 0..N} for s in 0..N}
    and matchIndex = {s: {t: 0 for t in 0..N} for s in 0..N}
    and votesGranted = {s: {t: false for t in 0..N} for s in 0..N}
    and requestVoteReqs = {}
    and requestVoteResps = {}
    and appendEntriesReqs = {}
    and appendEntriesResps = {}
}

// ============================================================================
// Leader Election Actions
// ============================================================================

// Server i times out and starts election
action Timeout(i: 0..N) {
    require role[i] != 2
    require currentTerm[i] < MaxTerm

    currentTerm = currentTerm | {i: currentTerm[i] + 1}
    and role = role | {i: 1}
    and votedFor = votedFor | {i: i}
    and votesGranted = votesGranted | {i: {t: (t == i) for t in 0..N}}
    and requestVoteReqs = requestVoteReqs union {
        [1, i, j, currentTerm[i] + 1, LastLogIndex(log[i]), LastLogTerm(log[i])]
        for j in 0..N if j != i
    }
}

// Server j receives RequestVote request
// msg = [1, src=i, dest=j, term, lastLogIdx, lastLogTerm]
action HandleRequestVoteRequest(i: 0..N, j: 0..N, msg: Seq[Int]) {
    require i != j
    require msg in requestVoteReqs
    require msg[0] == 1 and msg[1] == i and msg[2] == j

    // Update term if higher
    currentTerm = currentTerm | {j:
        if msg[3] > currentTerm[j] then msg[3] else currentTerm[j]
    }

    // Become follower if term advanced
    and role = role | {j:
        if msg[3] > currentTerm[j] and role[j] != 0 then 0 else role[j]
    }

    // Clear votedFor if term advanced, otherwise keep it
    and votedFor = votedFor | {j:
        if msg[3] > currentTerm[j] then
            (if msg[3] >= currentTerm[j]
             and (msg[4] > LastLogTerm(log[j])
                  or (msg[4] == LastLogTerm(log[j]) and msg[5] >= LastLogIndex(log[j])))
             then i else -1)
        else
            (if msg[3] >= currentTerm[j]
             and (votedFor[j] == -1 or votedFor[j] == i)
             and (msg[4] > LastLogTerm(log[j])
                  or (msg[4] == LastLogTerm(log[j]) and msg[5] >= LastLogIndex(log[j])))
             then i else votedFor[j])
    }

    // Remove request and send response
    and requestVoteReqs = requestVoteReqs diff {msg}
    and requestVoteResps = requestVoteResps union {[
        2, j, i,
        if msg[3] > currentTerm[j] then msg[3] else currentTerm[j],
        if (msg[3] > currentTerm[j] and msg[3] >= currentTerm[j]
            and (msg[4] > LastLogTerm(log[j])
                 or (msg[4] == LastLogTerm(log[j]) and msg[5] >= LastLogIndex(log[j]))))
           or (msg[3] <= currentTerm[j] and msg[3] >= currentTerm[j]
               and (votedFor[j] == -1 or votedFor[j] == i)
               and (msg[4] > LastLogTerm(log[j])
                    or (msg[4] == LastLogTerm(log[j]) and msg[5] >= LastLogIndex(log[j]))))
        then 1 else 0,
        0
    ]}
}

// Candidate i receives RequestVote response
// msg = [2, src=j, dest=i, term, voteGranted, 0]
action HandleRequestVoteResponse(i: 0..N, j: 0..N, msg: Seq[Int]) {
    require i != j
    require role[i] == 1
    require msg in requestVoteResps
    require msg[0] == 2 and msg[1] == j and msg[2] == i

    currentTerm = currentTerm | {i:
        if msg[3] > currentTerm[i] then msg[3] else currentTerm[i]
    }

    and role = role | {i:
        if msg[3] > currentTerm[i] then 0 else role[i]
    }

    and votedFor = votedFor | {i:
        if msg[3] > currentTerm[i] then -1 else votedFor[i]
    }

    and votesGranted = votesGranted | {i:
        if msg[3] > currentTerm[i] then votesGranted[i]
        else (votesGranted[i] | {j: msg[4] == 1})
    }

    and requestVoteResps = requestVoteResps diff {msg}
}

// Candidate becomes leader with majority
action BecomeLeader(i: 0..N) {
    require role[i] == 1
    require len({k in 0..N if votesGranted[i][k]}) * 2 > N + 1

    role = role | {i: 2}
    and nextIndex = nextIndex | {i: {j: LastLogIndex(log[i]) + 1 for j in 0..N}}
    and matchIndex = matchIndex | {i: {j: 0 for j in 0..N}}
}

// ============================================================================
// Log Replication Actions
// ============================================================================

// Leader appends client entry
action ClientRequest(i: 0..N) {
    require role[i] == 2
    require len(log[i]) < MaxLogLen

    log = log | {i: log[i] ++ [currentTerm[i]]}
}

// Leader sends AppendEntries to follower
// msg = [3, src=i, dest=j, term, prevLogIdx, prevLogTerm]
action SendAppendEntries(i: 0..N, j: 0..N) {
    require i != j
    require role[i] == 2

    appendEntriesReqs = appendEntriesReqs union {[
        3, i, j, currentTerm[i],
        nextIndex[i][j] - 1,
        LogTerm(log[i], nextIndex[i][j] - 1)
    ]}
}

// Follower receives AppendEntries
// msg = [3, src=i, dest=j, term, prevLogIdx, prevLogTerm]
action HandleAppendEntriesRequest(i: 0..N, j: 0..N, msg: Seq[Int]) {
    require i != j
    require msg in appendEntriesReqs
    require msg[0] == 3 and msg[1] == i and msg[2] == j

    // Update state
    currentTerm = currentTerm | {j:
        if msg[3] > currentTerm[j] then msg[3] else currentTerm[j]
    }

    and role = role | {j:
        if msg[3] >= currentTerm[j] then 0 else role[j]
    }

    and votedFor = votedFor | {j:
        if msg[3] > currentTerm[j] then -1 else votedFor[j]
    }

    // Update log if success: truncate to prevLogIndex, then append entries from leader
    and log = log | {j:
        if not (msg[3] >= currentTerm[j]
                and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
        then log[j]
        else if msg[4] + 1 > len(log[i]) then
            (if msg[4] == 0 then log[j] else log[j][0 .. msg[4]])
        else
            (if msg[4] == 0 then log[i][msg[4] .. len(log[i])]
             else log[j][0 .. msg[4]] ++ log[i][msg[4] .. len(log[i])])
    }

    // Update commitIndex if success
    and commitIndex = commitIndex | {j:
        if (msg[3] >= currentTerm[j]
            and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
        then Min(commitIndex[i], len(
            if not (msg[3] >= currentTerm[j]
                    and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
            then log[j]
            else if msg[4] + 1 > len(log[i]) then
                (if msg[4] == 0 then log[j] else log[j][0 .. msg[4]])
            else
                (if msg[4] == 0 then log[i][msg[4] .. len(log[i])]
                 else log[j][0 .. msg[4]] ++ log[i][msg[4] .. len(log[i])])
        )) else commitIndex[j]
    }

    // Send response: [4, src=j, dest=i, term, success, matchIdx]
    and appendEntriesReqs = appendEntriesReqs diff {msg}
    and appendEntriesResps = appendEntriesResps union {[
        4, j, i,
        if msg[3] > currentTerm[j] then msg[3] else currentTerm[j],
        if (msg[3] >= currentTerm[j]
            and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
        then 1 else 0,
        if (msg[3] >= currentTerm[j]
            and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
        then len(
            if not (msg[3] >= currentTerm[j]
                    and (msg[4] == 0 or (msg[4] <= len(log[j]) and LogTerm(log[j], msg[4]) == msg[5])))
            then log[j]
            else if msg[4] + 1 > len(log[i]) then
                (if msg[4] == 0 then log[j] else log[j][0 .. msg[4]])
            else
                (if msg[4] == 0 then log[i][msg[4] .. len(log[i])]
                 else log[j][0 .. msg[4]] ++ log[i][msg[4] .. len(log[i])])
        ) else 0
    ]}
}

// Leader receives AppendEntries response
// msg = [4, src=j, dest=i, term, success, matchIdx]
action HandleAppendEntriesResponse(i: 0..N, j: 0..N, msg: Seq[Int]) {
    require i != j
    require role[i] == 2
    require msg in appendEntriesResps
    require msg[0] == 4 and msg[1] == j and msg[2] == i

    currentTerm = currentTerm | {i:
        if msg[3] > currentTerm[i] then msg[3] else currentTerm[i]
    }

    and role = role | {i:
        if msg[3] > currentTerm[i] then 0 else role[i]
    }

    and votedFor = votedFor | {i:
        if msg[3] > currentTerm[i] then -1 else votedFor[i]
    }

    and nextIndex = nextIndex | {i:
        if msg[3] > currentTerm[i] then nextIndex[i]
        else if msg[4] == 1 then nextIndex[i] | {j: msg[5] + 1}
        else nextIndex[i] | {j: if nextIndex[i][j] > 1 then nextIndex[i][j] - 1 else 1}
    }

    and matchIndex = matchIndex | {i:
        if msg[3] > currentTerm[i] then matchIndex[i]
        else if msg[4] == 1 then matchIndex[i] | {j: msg[5]}
        else matchIndex[i]
    }

    and appendEntriesResps = appendEntriesResps diff {msg}
}

// Leader advances commit index using matchIndex
action AdvanceCommitIndex(i: 0..N, k: 1..MaxLogLen) {
    require role[i] == 2
    require k > commitIndex[i]
    require k <= len(log[i])
    require LogTerm(log[i], k) == currentTerm[i]
    require len({j in 0..N if matchIndex[i][j] >= k}) * 2 > N + 1

    commitIndex = commitIndex | {i: k}
}

// ============================================================================
// Term Discovery
// ============================================================================

action UpdateTerm(i: 0..N, j: 0..N) {
    require i != j
    require currentTerm[j] > currentTerm[i]

    currentTerm = currentTerm | {i: currentTerm[j]}
    and role = role | {i: 0}
    and votedFor = votedFor | {i: -1}
}

// ============================================================================
// Network Actions (Message Loss)
// ============================================================================

action DropRequestVoteReq(msg: Seq[Int]) {
    require msg in requestVoteReqs
    requestVoteReqs = requestVoteReqs diff {msg}
}

action DropRequestVoteResp(msg: Seq[Int]) {
    require msg in requestVoteResps
    requestVoteResps = requestVoteResps diff {msg}
}

action DropAppendEntriesReq(msg: Seq[Int]) {
    require msg in appendEntriesReqs
    appendEntriesReqs = appendEntriesReqs diff {msg}
}

action DropAppendEntriesResp(msg: Seq[Int]) {
    require msg in appendEntriesResps
    appendEntriesResps = appendEntriesResps diff {msg}
}

// ============================================================================
// Safety Invariants
// ============================================================================

invariant ElectionSafety {
    all i in 0..N: all j in 0..N:
        (role[i] == 2 and role[j] == 2 and currentTerm[i] == currentTerm[j])
        implies i == j
}

invariant LeaderAppendOnly {
    all i in 0..N:
        role[i] == 2 implies (all j in 0..N: i != j implies len(log[i]) >= matchIndex[i][j])
}

invariant LogMatching {
    all i in 0..N: all j in 0..N: all k in 1..MaxLogLen:
        (k <= len(log[i]) and k <= len(log[j]) and LogTerm(log[i], k) == LogTerm(log[j], k)
         and LogTerm(log[i], k) != -1)
        implies (all m in 1..k: m <= len(log[i]) and m <= len(log[j])
                                implies LogTerm(log[i], m) == LogTerm(log[j], m))
}

invariant LeaderCompleteness {
    all i in 0..N: all j in 0..N: all k in 1..MaxLogLen:
        (role[j] == 2 and k <= len(log[i]) and LogTerm(log[i], k) > 0
         and currentTerm[j] > LogTerm(log[i], k) and commitIndex[i] >= k)
        implies (k <= len(log[j]) and LogTerm(log[j], k) == LogTerm(log[i], k))
}

invariant StateMachineSafety {
    all i in 0..N: all j in 0..N: all k in 1..MaxLogLen:
        (commitIndex[i] >= k and commitIndex[j] >= k
         and k <= len(log[i]) and k <= len(log[j]))
        implies LogTerm(log[i], k) == LogTerm(log[j], k)
}

invariant TypeInvariant {
    (all s in 0..N: currentTerm[s] >= 0 and currentTerm[s] <= MaxTerm)
    and (all s in 0..N: role[s] >= 0 and role[s] <= 2)
    and (all s in 0..N: votedFor[s] >= -1 and votedFor[s] <= N)
    and (all s in 0..N: commitIndex[s] >= 0 and commitIndex[s] <= len(log[s]))
    and (all s in 0..N: len(log[s]) <= MaxLogLen)
}

invariant NextIndexValid {
    all i in 0..N: all j in 0..N:
        role[i] == 2 implies nextIndex[i][j] >= 1
}

invariant MatchIndexValid {
    all i in 0..N: all j in 0..N:
        role[i] == 2 implies matchIndex[i][j] <= len(log[i])
}

invariant CommittedInLeaderLog {
    all i in 0..N: all j in 0..N: all k in 1..MaxLogLen:
        (role[i] == 2 and commitIndex[j] >= k and k <= len(log[j]))
        implies (k <= len(log[i]))
}

invariant VotedForValid {
    all s in 0..N:
        votedFor[s] == -1 or (votedFor[s] >= 0 and votedFor[s] <= N)
}

invariant LeaderVotedForSelf {
    all i in 0..N:
        role[i] == 2 implies votedFor[i] == i
}
