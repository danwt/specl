module EPaxosFull

// EPaxos with explicit message passing for recovery.
//
// Same protocol as epaxos.specl but recovery is split into three steps
// with explicit Prepare/PrepareReply messages, matching the structure of
// the original TLA+ spec (github.com/efficient/epaxos).
//
// Pre-accept, accept, and commit remain atomic for tractability.
// Recovery is multi-step: SendPrepare → ReplyPrepare → PrepareFinalize.
//
// Command leader: replica 0. Fast quorum: {0, 1}. Classic quorum: any 2 of 3.
//
// UseFix=0: ReplyPrepare reports bal (inflated by prior prepares) — BUG.
// UseFix=1: ReplyPrepare reports vbal (actual acceptance ballot) — FIX.
//
// Use: specl check epaxos_full.specl -c MaxBal=4 -c NB=5 -c UseFix=0 --no-deadlock --no-auto --max-states 50000000
// Use: specl check epaxos_full.specl -c MaxBal=4 -c NB=5 -c UseFix=1 --no-deadlock --no-auto --max-states 50000000

const MaxBal: Int
const NB: Int // must equal MaxBal + 1
const UseFix: 0..1

// Status: 0=none, 1=preaccepted, 2=accepted, 3=committed

var status: Dict[0..2, 0..3]
var bal: Dict[0..2, 0..MaxBal]
var vbal: Dict[0..2, 0..MaxBal]
var val: Dict[0..2, 0..1]
var next_bal: 1..NB
var initial_val: 0..1
var msgs: Set[Seq[Int]]
// Messages encoded as Seq[Int]:
// [0, src, dst, ballot]                        = Prepare
// [1, src, dst, ballot, prev_bal, status, val]  = PrepareReply

init {
    status = {r: 0 for r in 0..2}
    and bal = {r: 0 for r in 0..2}
    and vbal = {r: 0 for r in 0..2}
    and val = {r: 0 for r in 0..2}
    and next_bal = 1
    and initial_val = 0
    and msgs = {}
}

// Command leader (r0) proposes value v.
action LeaderPreAccept(v: 0..1) {
    require status[0] == 0
    require bal[0] == 0
    status = status | {0: 1}
    and val = val | {0: v}
    and initial_val = v
}

// Fast quorum member (r1) pre-accepts with possibly different deps.
action FastQuorumPreAccept(v: 0..1) {
    require status[0] >= 1
    require status[1] == 0
    require bal[1] == 0
    status = status | {1: 1}
    and val = val | {1: v}
}

// Fast-path commit: fast quorum {0, 1} agrees at ballot 0.
action FastCommit(r: 0..2) {
    require r <= 1
    require status[r] >= 1
    require status[r] != 3
    require bal[r] == 0
    require status[0] >= 1 and status[1] >= 1
    require val[0] == val[1]
    require bal[0] == 0 and bal[1] == 0
    status = status | {r: 3}
}

// Recovery step 1: send Prepare to a quorum member.
action SendPrepare(src: 0..2, dst: 0..2) {
    require src != dst
    require next_bal <= MaxBal
    require status[src] != 3
    msgs = msgs union {[0, src, dst, next_bal]}
    and next_bal = next_bal + 1
}

// Recovery step 2: process Prepare, reply with local state.
// Inflates bal[r] to the prepare's ballot.
// BUG/FIX: prev_bal in reply is bal[r] (UseFix=0) or vbal[r] (UseFix=1).
action ReplyPrepare(r: 0..2, src: 0..2, b: 1..MaxBal) {
    require src != r
    require [0, src, r, b] in msgs
    require b > bal[r]
    require status[r] != 3
    msgs = (msgs diff {[0, src, r, b]})
        union {[1, r, src, b,
            if UseFix == 1 then vbal[r] else bal[r],
            status[r], val[r]]}
    and bal = bal | {r: b}
}

// Recovery step 3: process reply and decide value.
// Uses leader's own state + the reply from other.
action PrepareFinalize(leader: 0..2, other: 0..2,
                       b: 1..MaxBal, prev: 0..MaxBal,
                       st: 0..3, v: 0..1, pick: 0..1) {
    require leader != other
    require [1, other, leader, b, prev, st, v] in msgs
    require status[leader] != 3
    require b >= bal[leader] // leader hasn't joined a higher ballot since sending this prepare
    require status[leader] >= 1 or st >= 1

    val = val | {leader:
        if st == 3 then v
        else if status[leader] == 2 and st == 2 then
            if (if UseFix == 1 then vbal[leader] else bal[leader]) > prev then val[leader]
            else if prev > (if UseFix == 1 then vbal[leader] else bal[leader]) then v
            else val[leader]
        else if st == 2 then v
        else if status[leader] == 2 then val[leader]
        else if (status[leader] == 1 and val[leader] == initial_val)
                or (st == 1 and v == initial_val)
            then initial_val
        else if status[leader] == 1 and st == 1 then
            if val[leader] == v then val[leader] else pick
        else if status[leader] == 1 then val[leader]
        else if st == 1 then v
        else pick
    }
    and status = status | {leader: 2}
    and bal = bal | {leader: b}
    and vbal = vbal | {leader: b}
    and msgs = msgs diff {[1, other, leader, b, prev, st, v]}
}

// Accept propagation: src sends value to dst.
action Accept(src: 0..2, dst: 0..2) {
    require src != dst
    require status[src] == 2
    require status[dst] != 3
    require vbal[src] == bal[src]
    require bal[src] >= bal[dst]
    status = status | {dst: 2}
    and bal = bal | {dst: bal[src]}
    and vbal = vbal | {dst: vbal[src]}
    and val = val | {dst: val[src]}
}

// Slow-path commit: quorum of 2 accepted replicas agree.
action SlowCommit(r: 0..2) {
    require status[r] == 2
    require vbal[r] == bal[r]
    require any r2 in 0..2:
        r2 != r and status[r2] >= 2 and vbal[r2] == vbal[r] and val[r2] == val[r]
    status = status | {r: 3}
}

invariant Agreement {
    all r1 in 0..2: all r2 in 0..2:
        (status[r1] == 3 and status[r2] == 3) implies val[r1] == val[r2]
}
