module STM

// Software Transactional Memory (Shavit & Touitou, 1995).
// N+1 transactions read and write shared variables optimistically.
// Each variable has a version number. At commit time, transactions
// validate that all read versions are still current (no other
// transaction committed a conflicting write).
//
// If validation fails, the transaction aborts and retries.
// Guarantees serializability without locks.
//
// Use: specl check stm.specl -c N=1 -c MaxVer=3 --no-deadlock --no-auto --bfs
// Verified: N=1 MaxVer=3 -> OK (89 states, 0.0s)

const N: 0..2
const MaxVer: 2..4

// Shared variable version (monotonically increasing)
var version: 0..MaxVer

// Shared variable value
var value: 0..1

// Per-transaction: 0=idle, 1=running, 2=validating, 3=committed, 4=aborted
var tx_pc: Dict[0..N, 0..4]

// Version read by each transaction
var tx_read_ver: Dict[0..N, 0..MaxVer]

// Local write value
var tx_write: Dict[0..N, 0..1]
var tx_has_write: Dict[0..N, Bool]

init {
    version = 0;
    value = 0;
    tx_pc = {t: 0 for t in 0..N};
    tx_read_ver = {t: 0 for t in 0..N};
    tx_write = {t: 0 for t in 0..N};
    tx_has_write = {t: false for t in 0..N};
}

// Transaction begins and reads current version
action Begin(t: 0..N) {
    require tx_pc[t] == 0;
    tx_pc = tx_pc | {t: 1};
    tx_read_ver = tx_read_ver | {t: version};
}

// Transaction buffers a write
action Write(t: 0..N, v: 0..1) {
    require tx_pc[t] == 1;
    tx_write = tx_write | {t: v};
    tx_has_write = tx_has_write | {t: true};
}

// Transaction tries to commit: validate read version unchanged
action TryCommit(t: 0..N) {
    require tx_pc[t] == 1;
    require tx_has_write[t] == true;
    require tx_read_ver[t] == version;
    require version < MaxVer;
    // Validation passes: apply write atomically
    version = version + 1;
    value = tx_write[t];
    tx_pc = tx_pc | {t: 3};
}

// Validation fails: version changed since read
action Abort(t: 0..N) {
    require tx_pc[t] == 1;
    require tx_has_write[t] == true;
    require tx_read_ver[t] != version;
    tx_pc = tx_pc | {t: 4};
}

// Read-only transaction commits (always valid)
action CommitReadOnly(t: 0..N) {
    require tx_pc[t] == 1;
    require tx_has_write[t] == false;
    tx_pc = tx_pc | {t: 3};
}

// Aborted transaction retries
action Retry(t: 0..N) {
    require tx_pc[t] == 4;
    tx_pc = tx_pc | {t: 0};
    tx_has_write = tx_has_write | {t: false};
}

// Serializable: committed writing transactions got distinct versions
invariant Serializable {
    all i in 0..N: all j in 0..N:
        (i != j and tx_pc[i] == 3 and tx_pc[j] == 3
         and tx_has_write[i] == true and tx_has_write[j] == true)
        implies tx_read_ver[i] != tx_read_ver[j]
}

// Version monotonicity
invariant VersionMonotonic {
    version >= 0
}
