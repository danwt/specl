module BerkeleyClockSync

// Berkeley Algorithm for clock synchronization (Gusella & Zatti, 1989).
// A coordinator polls N+1 clocks (including its own), computes
// the average, and sends adjustments to each node.
// Unlike Cristian's, no external time source is needed.
//
// Safety: after synchronization, all clocks are within bounded
// distance of the average.
//
// Use: specl check berkeley-clock-sync.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (18 states, 0.0s)

const N: 0..3

// Per-node clock value
var clock: Dict[0..N, 0..6]

// Coordinator (node 0) state: 0=idle, 1=collecting, 2=adjusting, 3=done
var coord_pc: 0..3

// Collected clock values (what coordinator received)
var collected: Dict[0..N, 0..6]
var has_collected: Dict[0..N, Bool]

// Computed target (average)
var target: 0..6

// Per-node: adjusted?
var adjusted: Dict[0..N, Bool]

init {
    clock = {n: n for n in 0..N};
    coord_pc = 0;
    collected = {n: 0 for n in 0..N};
    has_collected = {n: false for n in 0..N};
    target = 0;
    adjusted = {n: false for n in 0..N};
}

// Coordinator starts collection
action StartCollect() {
    require coord_pc == 0;
    coord_pc = 1;
}

// Coordinator collects clock from node n
action Collect(n: 0..N) {
    require coord_pc == 1;
    require has_collected[n] == false;
    collected = collected | {n: clock[n]};
    has_collected = has_collected | {n: true};
}

// Coordinator computes average and moves to adjusting
action ComputeAverage() {
    require coord_pc == 1;
    require all n in 0..N: has_collected[n] == true;
    // Average approximated: for N=2, (c0 + c1 + c2) / 3
    // Simplified: use coordinator's collected value as target
    // (real algorithm computes average; here we approximate)
    target = collected[0];
    coord_pc = 2;
}

// Node adjusts its clock to target
action Adjust(n: 0..N) {
    require coord_pc == 2;
    require adjusted[n] == false;
    clock = clock | {n: target};
    adjusted = adjusted | {n: true};
}

// Coordinator finishes
action Finish() {
    require coord_pc == 2;
    require all n in 0..N: adjusted[n] == true;
    coord_pc = 3;
}

// After synchronization, all clocks agree
invariant Synchronized {
    coord_pc == 3 implies (
        all i in 0..N: all j in 0..N: clock[i] == clock[j]
    )
}

// Clocks are always non-negative
invariant NonNegative {
    all n in 0..N: clock[n] >= 0
}
