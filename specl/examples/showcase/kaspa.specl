module KaspaBridge

// Kaspa-Hub lock-and-mint bridge with anchor-UTXO-chain mechanism.
// Based on the protocol described in kaspa.txt.
//
// Actors:
//   Relayer (untrusted): observes chains, requests signatures, relays messages
//   Validator (trusted, stateless): verifies chain state, signs withdrawals
//
// Safety mechanisms:
//   Withdrawals: UTXO-uniqueness on Kaspa + compare-and-set on Hub
//   Deposits: outpoint seen-set anti-replay on Hub
//
// Messages are unordered (modeled as sets) and lossy (drop actions).
// Signed withdrawals persist: the relayer always has the signed data and
// can attempt replay. Kaspa UTXO rules are the sole replay prevention.
// Executed withdrawals persist: they are on-chain on Kaspa. Hub
// compare-and-set is the sole mechanism preventing re-confirmation.
//
// Quick:     specl check kaspa.specl -c N=3 --no-deadlock --bfs
// Strenuous: specl check kaspa.specl -c N=5 --no-deadlock --bfs --fast

const N: Int

// Withdrawal message encoding: [spend, create, from_L, target_L]
//   [0] spend    : anchor UTXO to spend
//   [1] create   : new anchor UTXO to create
//   [2] from_L   : hub_L at signing time (start of withdrawal range, exclusive)
//   [3] target_L : end of withdrawal range (inclusive), releases indices (from_L, target_L]

// === HUB CHAIN STATE ===
var hub_O: 0..N         // O: current anchor outpoint (UTXO ID on Kaspa)
var hub_L: 0..N         // L: last withdrawal index confirmed as bridged to Kaspa
var hub_queue: 0..N     // total withdrawal requests (indices 1..hub_queue)
var hub_seen: Set[Int]  // deposit outpoints already credited (anti-replay)

// === KASPA CHAIN STATE ===
var unspent: Set[Int]   // unspent transaction outputs (UTXO 0 is the seed)
var next_id: 0..N       // monotonic UTXO ID allocator
var escrow: Int         // escrow balance: seed(1) + deposits - releases

// === MESSAGES ===
// Signed withdrawals persist: relayer always has the signed data.
// Kaspa UTXO rules are the sole mechanism preventing replay.
var signed_withdrawals: Set[Seq[Int]]
// Executed withdrawals are on-chain on Kaspa: always verifiable.
// Hub compare-and-set is the sole mechanism preventing re-confirmation.
var executed_withdrawals: Set[Seq[Int]]
// Deposit messages can be lost in transit.
var deposit_msgs: Set[Int]

// === USER STATE ===
var deposits: Set[Int]  // deposit outpoints that exist on Kaspa

// === GHOST STATE ===
var released: Set[Int]  // withdrawal indices with funds released on Kaspa

init {
    hub_O = 0;
    hub_L = 0;
    hub_queue = 0;
    hub_seen = {};
    unspent = {0};
    next_id = 1;
    escrow = 1;
    signed_withdrawals = {};
    executed_withdrawals = {};
    deposit_msgs = {};
    deposits = {};
    released = {};
}

// ================================================================
// DEPOSIT DIRECTION: Kaspa -> Hub
// Each deposit has a unique Kaspa outpoint.
// Hub seen-set prevents replay.
// ================================================================

// User deposits KAS to escrow on Kaspa
action UserDeposit(id: 1..N) {
    require not (id in deposits);
    deposits = deposits union {id};
    escrow = escrow + 1;
}

// Relayer observes deposit. Validator verifies outpoint exists on Kaspa.
action RelayDeposit(id: 1..N) {
    require id in deposits;
    deposit_msgs = deposit_msgs union {id};
}

// Hub credits wrapped KAS. Seen-set prevents double-crediting.
action HubCredit(id: 1..N) {
    require id in deposit_msgs;
    require not (id in hub_seen);
    hub_seen = hub_seen union {id};
    deposit_msgs = deposit_msgs diff {id};
}

// ================================================================
// WITHDRAWAL DIRECTION: Hub -> Kaspa
// Safety from:
//   1. Kaspa UTXO uniqueness (each UTXO spent at most once)
//   2. Hub compare-and-set (hub_O must match to update)
//   3. Validator ensures L monotonically advances
// ================================================================

// User burns wrapped KAS on Hub, creating a withdrawal request
action UserWithdraw() {
    require hub_queue < N;
    hub_queue = hub_queue + 1;
}

// Validator signs a Kaspa TX processing withdrawals.
// Checks: anchor live, L advances, within queue, escrow sufficient.
action ValidatorSignWithdrawal(target_L: 1..N) {
    require next_id < N;
    require hub_O in unspent;
    require hub_L < target_L;
    require target_L <= hub_queue;
    require escrow >= target_L - hub_L;
    signed_withdrawals = signed_withdrawals union {[hub_O, next_id, hub_L, target_L]};
    next_id = next_id + 1;
}

// Kaspa executes a signed withdrawal.
// KASPA CONSENSUS RULE: each UTXO can only be spent once.
// Signed withdrawals are NOT consumed: the relayer always has them.
// The UTXO check is the sole mechanism preventing double-execution.
action KaspaExecute(msg: Seq[Int]) {
    require msg in signed_withdrawals;
    require msg[0] in unspent;
    unspent = (unspent diff {msg[0]}) union {msg[1]};
    released = released union {w in 1..N if w > msg[2] and w <= msg[3]};
    escrow = escrow - (msg[3] - msg[2]);
    executed_withdrawals = executed_withdrawals union {msg};
}

// Hub confirms a Kaspa execution. Validator verifies the on-chain trace.
// Compare-and-set on O prevents stale or reordered updates.
action HubConfirm(msg: Seq[Int]) {
    require msg in executed_withdrawals;
    require msg[0] == hub_O;
    require hub_L < msg[3];
    hub_O = msg[1];
    hub_L = msg[3];
}

// ================================================================
// ADVERSARIAL RELAYER: message loss
// Signed/executed withdrawals cannot be lost (persistent data/on-chain).
// Message reordering is implicit (sets are unordered).
// ================================================================

// Deposit message lost in transit to Hub
action DropDepositMsg(id: 1..N) {
    require id in deposit_msgs;
    deposit_msgs = deposit_msgs diff {id};
}

// ================================================================
// INVARIANTS
// ================================================================

// Every released withdrawal index is a valid request
invariant NoUnauthorizedRelease {
    all w in released: w >= 1 and w <= hub_queue
}

// Hub never credits a deposit that doesn't exist on Kaspa
invariant DepositIntegrity {
    hub_seen subset_of deposits
}

// Confirmed withdrawal index never exceeds queue
invariant HubLBounded {
    hub_L <= hub_queue
}

// Can't release more withdrawals than requested
invariant PegWithdrawalSafety {
    len(released) <= hub_queue
}

// Can't credit more deposits than made
invariant PegDepositSafety {
    len(hub_seen) <= len(deposits)
}

// UTXO uniqueness ensures escrow is never overdrafted.
// Removing `require msg[0] in unspent` from KaspaExecute violates this:
// two withdrawals from the same epoch (same spend UTXO) would both execute,
// each deducting from escrow, draining it below zero.
invariant EscrowNonNegative {
    escrow >= 0
}
