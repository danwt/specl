module Bulkhead

// Bulkhead Pattern (Nygard, 2007; Microsoft Azure patterns).
// Isolates critical resources into separate pools (bulkheads)
// so that failure in one pool doesn't cascade to others.
// Each pool has a maximum capacity. Requests are rejected
// when a pool is full.
//
// 2 pools (0 and 1), each with capacity C. N+1 workers.
//
// Use: specl check bulkhead.specl -c N=3 -c C=2 --no-deadlock --no-auto --bfs
// Verified: N=3 C=2 -> OK (230 states)

const N: 0..4
const C: 1..3

// Per-pool: current usage count
var usage: Dict[0..1, 0..C]
// Per-worker: state (0=idle, 1=using_pool0, 2=using_pool1, 3=done)
var pc: Dict[0..N, 0..3]

init {
    usage = {p: 0 for p in 0..1}
    and pc = {w: 0 for w in 0..N}
}

// Worker acquires resource from pool 0
action AcquirePool0(w: 0..N) {
    require pc[w] == 0
    require usage[0] < C
    usage = usage | {0: usage[0] + 1}
    and pc = pc | {w: 1}
}

// Worker acquires resource from pool 1
action AcquirePool1(w: 0..N) {
    require pc[w] == 0
    require usage[1] < C
    usage = usage | {1: usage[1] + 1}
    and pc = pc | {w: 2}
}

// Worker releases pool 0
action ReleasePool0(w: 0..N) {
    require pc[w] == 1
    usage = usage | {0: usage[0] - 1}
    and pc = pc | {w: 3}
}

// Worker releases pool 1
action ReleasePool1(w: 0..N) {
    require pc[w] == 2
    usage = usage | {1: usage[1] - 1}
    and pc = pc | {w: 3}
}

// Worker restarts
action Restart(w: 0..N) {
    require pc[w] == 3
    pc = pc | {w: 0}
}

// Pool isolation: each pool never exceeds capacity
invariant PoolCapacity {
    all p in 0..1: usage[p] <= C
}

// Bulkhead isolation: pool 0 being full doesn't block pool 1
invariant IndependentPools {
    (usage[0] == C) implies (usage[1] <= C)
}
