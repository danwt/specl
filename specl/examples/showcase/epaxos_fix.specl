module EPaxosFix

// EPaxos recovery with CORRECT two-ballot design (Sutra 2019 fix)
//
// Same model as epaxos_bug.specl but recovery compares VBAL (line 74)
// instead of BAL. VBAL tracks the actual acceptance ballot and is NOT
// inflated by prepare messages, so recovery correctly identifies the
// most recent accepted value.
//
// This version PASSES â€” the fix prevents the ballot inflation bug.
//
// Use: specl check epaxos_fix.specl -c MaxBal=5 -c NB=6 --no-deadlock --no-auto --max-states 50000000

const MaxBal: Int
const NB: Int // must equal MaxBal + 1

// 3 replicas: 0, 1, 2
// Status: 0=none, 1=preaccepted, 2=accepted, 3=committed

var status: Dict[0..2, 0..3]
var bal: Dict[0..2, 0..MaxBal]   // last ballot joined (inflated by prepares)
var vbal: Dict[0..2, 0..MaxBal]  // ballot of last acceptance (only set by accept)
var val: Dict[0..2, 0..1]
var next_bal: 1..NB

init {
    status = {r: 0 for r in 0..2}
    and bal = {r: 0 for r in 0..2}
    and vbal = {r: 0 for r in 0..2}
    and val = {r: 0 for r in 0..2}
    and next_bal = 1
}

action PreAccept(r: 0..2, v: 0..1) {
    require status[r] == 0
    status = status | {r: 1}
    and val = val | {r: v}
}

action JoinBallot(r: 0..2) {
    require next_bal <= MaxBal
    require next_bal > bal[r]
    require status[r] != 3
    bal = bal | {r: next_bal}
    and next_bal = next_bal + 1
}

// Atomic recovery with quorum {leader, other}.
// FIX ON LINE 74: compares vbal (not bal).
action DoRecovery(leader: 0..2, other: 0..2, pick: 0..1) {
    require leader != other
    require next_bal <= MaxBal
    require next_bal > bal[leader]
    require next_bal > bal[other]
    require status[leader] != 3
    require status[leader] >= 1 or status[other] >= 1

    val = val | {leader:
        if status[other] == 3 then val[other]
        else if status[leader] == 2 and status[other] == 2 then
            if vbal[leader] > vbal[other] then val[leader]      // FIX: vbal not bal
            else if vbal[other] > vbal[leader] then val[other]   // FIX: vbal not bal
            else val[leader]
        else if status[other] == 2 then val[other]
        else if status[leader] == 2 then val[leader]
        else if status[leader] == 1 and status[other] == 1 then
            if val[leader] == val[other] then val[leader] else pick
        else if status[leader] == 1 then val[leader]
        else if status[other] == 1 then val[other]
        else pick
    }
    and status = status | {leader: 2}
    and bal = bal | {leader: next_bal, other: next_bal}
    and vbal = vbal | {leader: next_bal}
    and next_bal = next_bal + 1
}

action AcceptProp(src: 0..2, dst: 0..2) {
    require src != dst
    require status[src] == 2
    require status[dst] != 3
    require bal[src] >= bal[dst]
    status = status | {dst: 2}
    and bal = bal | {dst: bal[src]}
    and vbal = vbal | {dst: vbal[src]}
    and val = val | {dst: val[src]}
}

action Commit(r: 0..2) {
    require status[r] == 2
    require vbal[r] == bal[r]
    require any r2 in 0..2:
        r2 != r and status[r2] >= 2 and vbal[r2] == vbal[r] and val[r2] == val[r]
    status = status | {r: 3}
}

invariant Agreement {
    all r1 in 0..2: all r2 in 0..2:
        (status[r1] == 3 and status[r2] == 3) implies val[r1] == val[r2]
}
