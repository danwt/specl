module SWIM

// SWIM failure detection protocol
// From: Das, Gupta, Sturgis, "SWIM: Scalable Weakly-consistent
//       Infection-style Membership Protocol" (2002)
// N is the last node index (N+1 nodes, 0..N)
// K is the number of indirect ping helpers per probe
// MaxRound bounds protocol rounds for bounded completeness checking
// Use: specl check swim.specl -c N=3 -c K=1 -c MaxRound=4 --no-deadlock
// Verified: N=3 K=1 MaxRound=4 -> AccuracySafety VIOLATED in 7 steps
// (intentional: alive node falsely marked Failed due to non-deterministic timeout —
// demonstrates SWIM's fundamental accuracy-completeness tradeoff)

const N: Int
const K: Int
const MaxRound: Int

// Per node: alive or crashed
var alive: Dict[Int, Bool]

// Per node's view of each other node: 0=Alive, 1=Suspected, 2=Failed
var view: Dict[Int, Dict[Int, Int]]

// Current round
var round: Int

// Per round: prober and target (-1 = not yet assigned)
var prober: Dict[Int, Int]
var target: Dict[Int, Int]

// Per round: direct ping result (0=Pending, 1=Ack, 2=Timeout)
var directResult: Dict[Int, Int]

// Per round: indirect ping result (0=Pending, 1=Ack, 2=Timeout)
var indirectResult: Dict[Int, Int]

// Per round: how many helpers have been asked
var helpersAsked: Dict[Int, Int]

// Per round × node: has this node already been asked as a helper?
var askedHelper: Dict[Int, Dict[Int, Bool]]

init {
    alive = {i: true for i in 0..N};
    view = {i: {j: 0 for j in 0..N} for i in 0..N};
    round = 0;
    prober = {r: -1 for r in 0..MaxRound};
    target = {r: -1 for r in 0..MaxRound};
    directResult = {r: 0 for r in 0..MaxRound};
    indirectResult = {r: 0 for r in 0..MaxRound};
    helpersAsked = {r: 0 for r in 0..MaxRound};
    askedHelper = {r: {i: false for i in 0..N} for r in 0..MaxRound};
}

// --- Crashes ---

// Node i crashes (node 0 never crashes, ensures at least one correct node)
action Crash(i: 0..N) {
    require alive[i];
    require i != 0;
    alive = alive | {i: false};
}

// --- Probing ---

// Alive node i starts probing node j in the current round
action StartProbe(i: 0..N, j: 0..N) {
    require round <= MaxRound;
    require prober[round] == -1;
    require i != j;
    require alive[i];
    require view[i][j] != 2;
    prober = prober | {round: i};
    target = target | {round: j};
}

// Direct ping succeeds (target is alive and reachable)
action DirectAck() {
    require prober[round] != -1;
    require directResult[round] == 0;
    require alive[target[round]];
    directResult = directResult | {round: 1};
}

// Direct ping times out (target crashed OR non-deterministic network delay)
action DirectTimeout() {
    require prober[round] != -1;
    require directResult[round] == 0;
    directResult = directResult | {round: 2};
}

// --- Indirect probing ---

// Ask helper h to probe the target (each helper asked at most once)
action IndirectPing(h: 0..N) {
    require directResult[round] == 2;
    require indirectResult[round] == 0;
    require helpersAsked[round] < K;
    require h != prober[round];
    require h != target[round];
    require alive[h];
    require not askedHelper[round][h];
    helpersAsked = helpersAsked | {round: helpersAsked[round] + 1};
    askedHelper = askedHelper | {round: (askedHelper[round] | {h: true})};
}

// Indirect ping succeeds (a helper got an ack from the target)
action IndirectAck() {
    require directResult[round] == 2;
    require indirectResult[round] == 0;
    require helpersAsked[round] > 0;
    require alive[target[round]];
    indirectResult = indirectResult | {round: 1};
}

// Indirect ping times out (all helpers asked, none got an ack)
action IndirectTimeout() {
    require directResult[round] == 2;
    require indirectResult[round] == 0;
    require helpersAsked[round] >= K;
    indirectResult = indirectResult | {round: 2};
}

// --- View updates ---

// Prober marks target as suspected (both probes failed)
action Suspect() {
    require directResult[round] == 2;
    require indirectResult[round] == 2;
    require view[prober[round]][target[round]] == 0;
    view = view | {prober[round]:
        (view[prober[round]] | {target[round]: 1})}
}

// Prober confirms target is alive (got an ack)
action ConfirmAlive() {
    require directResult[round] == 1
        or indirectResult[round] == 1
    require view[prober[round]][target[round]] != 2;
    view = view | {prober[round]:
        (view[prober[round]] | {target[round]: 0})}
}

// Suspected node promoted to Failed
action DeclareFailed(i: 0..N, j: 0..N) {
    require i != j;
    require alive[i];
    require view[i][j] == 1;
    view = view | {i: (view[i] | {j: 2})};
}

// --- Round management ---

// Advance to next round (current round must be complete)
action AdvanceRound() {
    require round < MaxRound;
    require prober[round] != -1;
    require directResult[round] != 0;
    require directResult[round] == 1 or indirectResult[round] != 0;
    round = round + 1;
}

// --- Gossip dissemination ---

// Node i learns from node j about node k's higher suspicion status
action Gossip(i: 0..N, j: 0..N, k: 0..N) {
    require alive[i] and alive[j];
    require i != j;
    require i != k;
    require view[j][k] > view[i][k];
    view = view | {i: (view[i] | {k: view[j][k]})};
}

// --- Invariants ---

// No self-suspicion: a live node never marks itself as suspected or failed
invariant NoSelfSuspicion {
    all i in 0..N: alive[i] implies view[i][i] == 0
}

// Strong accuracy (safety encoding): alive nodes are never marked Failed
// by any alive node. This MAY be violated due to non-deterministic
// DirectTimeout for alive targets, demonstrating SWIM's accuracy limitation.
invariant AccuracySafety {
    all i in 0..N: all j in 0..N:
        (alive[i] and alive[j]) implies view[i][j] != 2
}

// Bounded completeness: once a probe has been started in the final round,
// all alive nodes should have at least suspected every crashed node
// (safety encoding of liveness property — activates only after MaxRound probe starts)
invariant BoundedCompleteness {
    (round == MaxRound and prober[MaxRound] != -1)
    implies (all i in 0..N: all j in 0..N:
        (alive[i] and not alive[j])
        implies view[i][j] >= 1)
}
