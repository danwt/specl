module SloppyQuorum

// Sloppy Quorums with Hinted Handoff (DeCandia et al., 2007).
// In Dynamo-style systems, when a preferred replica is down,
// writes go to the "next" available node (sloppy quorum).
// That node stores a "hint" and hands the data back when the
// preferred replica recovers.
//
// 3 preferred replicas. If one is down, writes go to a hint node.
// When the downed node recovers, hints are handed off.
//
// Use: specl check sloppy-quorum.specl -c MaxWrites=2 --no-deadlock --no-auto --bfs
// Verified: MaxWrites=2 -> OK (740 states, 0.0s)

const MaxWrites: 1..3

// 3 preferred replicas (0, 1, 2) and 1 hint node (3)
// Replica value (latest written value)
var replica: Dict[0..2, 0..1]
var replica_ver: Dict[0..2, 0..MaxWrites]

// Hint node stores data for a downed replica
var hint_val: 0..1
var hint_ver: 0..MaxWrites
var hint_for: 0..2    // which replica the hint is for
var has_hint: Bool

// Which replicas are alive
var alive: Dict[0..2, Bool]

// Write counter
var writes: 0..MaxWrites

init {
    replica = {r: 0 for r in 0..2}
    and replica_ver = {r: 0 for r in 0..2}
    and hint_val = 0
    and hint_ver = 0
    and hint_for = 0
    and has_hint = false
    and alive = {r: true for r in 0..2}
    and writes = 0
}

// Normal write: all 3 alive, write to 2 of 3 (quorum)
action NormalWrite(v: 0..1, skip: 0..2) {
    require writes < MaxWrites
    require all r in 0..2: alive[r] == true
    writes = writes + 1
    and replica = {r: if r == skip then replica[r] else v for r in 0..2}
    and replica_ver = {r: if r == skip then replica_ver[r] else writes + 1 for r in 0..2}
}

// Sloppy write: one replica down, write to 2 alive + hint node
action SloppyWrite(v: 0..1, down: 0..2) {
    require writes < MaxWrites
    require alive[down] == false
    // Other 2 replicas must be alive
    require all r in 0..2: r == down or alive[r] == true
    writes = writes + 1
    and replica = {r: if r == down then replica[r] else v for r in 0..2}
    and replica_ver = {r: if r == down then replica_ver[r] else writes + 1 for r in 0..2}
    and hint_val = v
    and hint_ver = writes + 1
    and hint_for = down
    and has_hint = true
}

// Replica goes down
action Crash(r: 0..2) {
    require alive[r] == true
    // Keep at least 2 alive for quorum
    require len({i in 0..2 if alive[i] == true}) > 2
    alive = alive | {r: false}
}

// Replica recovers
action Recover(r: 0..2) {
    require alive[r] == false
    alive = alive | {r: true}
}

// Hinted handoff: hint node sends data to recovered replica
action Handoff() {
    require has_hint == true
    require alive[hint_for] == true
    require hint_ver > replica_ver[hint_for]
    replica = replica | {hint_for: hint_val}
    and replica_ver = replica_ver | {hint_for: hint_ver}
    and has_hint = false
}

// Read repair: slow replica catches up from a faster one
action ReadRepair(slow: 0..2, fast: 0..2) {
    require slow != fast
    require alive[slow] == true and alive[fast] == true
    require replica_ver[fast] > replica_ver[slow]
    replica = replica | {slow: replica[fast]}
    and replica_ver = replica_ver | {slow: replica_ver[fast]}
}

// Quorum read consistency: any 2 of 3 alive replicas include the latest
invariant QuorumRead {
    writes == 0 or
    all i in 0..2: all j in 0..2:
        (i != j and alive[i] == true and alive[j] == true) implies
        (replica_ver[i] == writes or replica_ver[j] == writes)
}
