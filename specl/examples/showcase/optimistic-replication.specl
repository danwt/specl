module OptimisticReplication

// Optimistic Replication with Conflict Resolution (Saito & Shapiro, 2005).
// Replicas accept writes locally without coordination. When syncing,
// conflicts are resolved by a deterministic merge function.
// This models N+1 replicas with a single register. Concurrent writes
// create conflicts, resolved by picking the highest-timestamped value
// (like LWW), but tracking the conflict state explicitly.
//
// Use: specl check optimistic-replication.specl -c N=2 -c MaxOps=2 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxOps=2 -> OK (131 states, 0.0s)

const N: 0..3
const MaxOps: 1..4

var val: Dict[0..N, 0..1]
var ts: Dict[0..N, 0..MaxOps]
// 0=clean, 1=dirty (local write pending sync)
var dirty: Dict[0..N, Bool]
var ops: 0..MaxOps

init {
    val = {r: 0 for r in 0..N};
    ts = {r: 0 for r in 0..N};
    dirty = {r: false for r in 0..N};
    ops = 0;
}

// Local write at replica r
action LocalWrite(r: 0..N, v: 0..1) {
    require ops < MaxOps;
    ops = ops + 1;
    val = val | {r: v};
    ts = ts | {r: ops + 1};
    dirty = dirty | {r: true};
}

// Sync: replica src pushes to dst, resolve by timestamp
action Sync(src: 0..N, dst: 0..N) {
    require src != dst;
    require dirty[src] == true or ts[src] > ts[dst];
    // Higher timestamp wins; tie-break by replica ID
    val = val | {dst:
        if ts[src] > ts[dst] then val[src]
        else if ts[src] == ts[dst] and src > dst then val[src]
        else val[dst]
    };
    ts = ts | {dst:
        if ts[src] > ts[dst] then ts[src]
        else ts[dst]
    };
    dirty = dirty | {src: false};
}

// After full sync, all replicas converge
invariant ConvergedMeansEqual {
    (all r in 0..N: dirty[r] == false) implies
    (all i in 0..N: all j in 0..N: ts[i] == ts[j] implies val[i] == val[j])
}
