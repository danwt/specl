module PhiAccrual

// Phi Accrual Failure Detector (Hayashibara et al., 2004).
// Instead of a binary alive/dead output, the phi accrual failure
// detector outputs a suspicion level (phi). Higher phi = more likely
// the process has failed. The application decides the threshold.
//
// This models N+1 processes sending heartbeats. Each process tracks
// the last heartbeat time from every other process. Phi is approximated
// by the time since last heartbeat.
//
// Safety: a process that keeps heartbeating is never suspected at
// high phi. A crashed process eventually reaches high phi.
//
// Use: specl check phi-accrual.specl -c N=1 -c MaxTime=4 --no-deadlock --no-auto --bfs
// Verified: N=1 MaxTime=4 -> OK (220 states, 0.0s)

const N: 0..2
const MaxTime: 3..6

// Global time
var time: 0..MaxTime

// Per-process: alive?
var alive: Dict[0..N, Bool]

// Per-process per-monitored: last heartbeat time
var last_hb: Dict[0..N, Dict[0..N, 0..MaxTime]]

// Per-process per-monitored: suspicion level (0=low, 1=medium, 2=high)
var phi: Dict[0..N, Dict[0..N, 0..2]]

init {
    time = 0;
    alive = {p: true for p in 0..N};
    last_hb = {p: {q: 0 for q in 0..N} for p in 0..N};
    phi = {p: {q: 0 for q in 0..N} for p in 0..N};
}

// Time advances
action Tick() {
    require time < MaxTime;
    time = time + 1;
    // Update phi based on time since last heartbeat
    phi = {p: {q:
        if p == q then 0
        else if time + 1 - last_hb[p][q] <= 1 then 0
        else if time + 1 - last_hb[p][q] <= 2 then 1
        else 2
    for q in 0..N} for p in 0..N}
}

// Process q sends heartbeat to process p
action Heartbeat(q: 0..N, p: 0..N) {
    require p != q;
    require alive[q] == true;
    last_hb = last_hb | {p: last_hb[p] | {q: time}};
    phi = phi | {p: phi[p] | {q: 0}};
}

// Process p crashes
action Crash(p: 0..N) {
    require alive[p] == true;
    alive = alive | {p: false};
}

// Alive processes that recently sent heartbeats have low phi
invariant AliveHeartbeatLowPhi {
    all p in 0..N: all q in 0..N:
        (p != q and alive[q] == true and last_hb[p][q] == time)
        implies phi[p][q] <= 1
}

// Self-phi is always 0
invariant SelfPhiZero {
    all p in 0..N: phi[p][p] == 0
}
