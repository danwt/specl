module PriorityInversion

// Priority Inversion demonstration.
// Three tasks: High (prio 2), Medium (prio 1), Low (prio 0).
// The classic scenario:
//   1. Low acquires mutex
//   2. High arrives, blocks on mutex
//   3. Medium arrives, preempts Low (higher priority)
//   4. High waits for Medium to finish before Low can resume
//
// With priority inheritance (UseFix=1), step 3 is blocked:
// Low inherits High's priority, so Medium can't preempt.
//
// UseFix=0: priority inversion bug (expected violation)
// UseFix=1: priority inheritance prevents it
//
// Use: specl check priority-inversion.specl -c UseFix=0 --no-deadlock --no-auto --bfs
// Verified: UseFix=0 -> VIOLATION (NoInversion), UseFix=1 -> OK (4 states)

const UseFix: 0..1

// Phase: 0=low_acquires, 1=high_blocks, 2=med_may_preempt, 3=resolved
var phase: 0..3
// Did priority inversion occur?
var inverted: Bool

init {
    phase = 0
    and inverted = false
}

// Low acquires the mutex
action LowAcquire() {
    require phase == 0
    phase = 1
}

// High arrives and blocks on the mutex
action HighBlock() {
    require phase == 1
    phase = 2
}

// Medium preempts Low (priority inversion!)
// With fix: Low has inherited High's priority, Medium can't preempt
action MedPreempt() {
    require phase == 2
    require UseFix == 0
    phase = 3
    and inverted = true
}

// Low finishes with mutex (no preemption happened)
action LowFinish() {
    require phase == 2
    phase = 3
}

// Priority inversion should never happen
invariant NoInversion {
    inverted == false
}
