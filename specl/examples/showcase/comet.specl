module CometBFT

// CometBFT/Tendermint BFT consensus â€” single height with Byzantine faults
// From: Buchman, Kwon, Milosevic, "The latest gossip on BFT consensus" (2018)
// N+1 validators (0..N), tolerating F Byzantine faults where N+1 >= 3F+1
// Quorum = 2F+1 (strict majority of honest + Byzantine)
// Use: specl check comet.specl -c N=3 -c MaxRound=1 -c V=1 -c F=1 --no-deadlock --fast
// Baseline: N=3 MaxRound=0 V=1 F=1 -> 56K states, 2s (no view changes)
// Full: N=3 MaxRound=1 V=1 F=1 -> >5 min check (exercises view changes, large state space)
// WARNING: F=0 is degenerate (Quorum=1, Agreement trivially violated). Always use F>=1.

const N: Int
const MaxRound: Int
const V: Int
const F: Int

// Step encoding: 0=Propose, 1=Prevote, 2=Precommit
var step: Dict[Int, Int]
var round: Dict[Int, Int]
var lockedValue: Dict[Int, Int]
var lockedRound: Dict[Int, Int]
var validValue: Dict[Int, Int]
var validRound: Dict[Int, Int]

// Vote tracking: per round per validator
// -2 = not yet voted, -1 = nil, 0..V = value
var prevotes: Dict[Int, Dict[Int, Int]]
var precommits: Dict[Int, Dict[Int, Int]]

// Per round: proposed value (-1 = no proposal)
var proposal: Dict[Int, Int]

// Per validator: decided value (-1 = not decided)
var decision: Dict[Int, Int]

// Per validator: whether they have gone Byzantine
var faulty: Dict[Int, Bool]

func Proposer(r) { r % (N + 1) }

func PrevoteCount(r, v) {
    len({i in 0..N if prevotes[r][i] == v})
}

func PrecommitCount(r, v) {
    len({i in 0..N if precommits[r][i] == v})
}

func AnyPrevoteCount(r) {
    len({i in 0..N if prevotes[r][i] != -2})
}

func AnyPrecommitCount(r) {
    len({i in 0..N if precommits[r][i] != -2})
}

func Quorum() { 2 * F + 1 }

init {
    step = {i: 0 for i in 0..N}
    and round = {i: 0 for i in 0..N}
    and lockedValue = {i: -1 for i in 0..N}
    and lockedRound = {i: -1 for i in 0..N}
    and validValue = {i: -1 for i in 0..N}
    and validRound = {i: -1 for i in 0..N}
    and prevotes = {r: {i: -2 for i in 0..N} for r in 0..MaxRound}
    and precommits = {r: {i: -2 for i in 0..N} for r in 0..MaxRound}
    and proposal = {r: -1 for r in 0..MaxRound}
    and decision = {i: -1 for i in 0..N}
    and faulty = {i: false for i in 0..N}
}

// A validator goes Byzantine (at most F can)
action GoFaulty(i: 0..N) {
    require not faulty[i]
    require len({j in 0..N if faulty[j]}) < F
    faulty = faulty | {i: true}
}

// Byzantine validator prevotes for a value (skips all protocol rules)
action ByzantinePrevote(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require faulty[i]
    require prevotes[r][i] == -2
    prevotes = prevotes | {r: (prevotes[r] | {i: v})}
}

// Byzantine validator prevotes nil
action ByzantinePrevoteNil(i: 0..N, r: 0..MaxRound) {
    require faulty[i]
    require prevotes[r][i] == -2
    prevotes = prevotes | {r: (prevotes[r] | {i: -1})}
}

// Byzantine validator precommits for a value (skips all protocol rules)
action ByzantinePrecommit(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require faulty[i]
    require precommits[r][i] == -2
    precommits = precommits | {r: (precommits[r] | {i: v})}
}

// Byzantine validator precommits nil
action ByzantinePrecommitNil(i: 0..N, r: 0..MaxRound) {
    require faulty[i]
    require precommits[r][i] == -2
    precommits = precommits | {r: (precommits[r] | {i: -1})}
}

// Proposer for round r proposes value v (honest only)
// If proposer has validValue, must re-propose it; otherwise any value
action Propose(r: 0..MaxRound, v: 0..V) {
    require not faulty[Proposer(r)]
    require proposal[r] == -1
    require round[Proposer(r)] == r
    require step[Proposer(r)] == 0
    require validValue[Proposer(r)] == -1 or validValue[Proposer(r)] == v
    proposal = proposal | {r: v}
}

// Byzantine proposer can propose any value without following protocol rules
action ByzantinePropose(r: 0..MaxRound, v: 0..V) {
    require faulty[Proposer(r)]
    require proposal[r] == -1
    proposal = proposal | {r: v}
}

// Validator i prevotes for value v in round r (honest only)
action PrevoteBlock(i: 0..N, r: 0..MaxRound) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 0
    require prevotes[r][i] == -2
    require proposal[r] != -1
    require lockedRound[i] == -1
        or lockedValue[i] == proposal[r]
        or (any vr in 0..MaxRound:
            vr < r
            and PrevoteCount(vr, proposal[r]) >= Quorum()
            and lockedRound[i] <= vr)
    prevotes = prevotes | {r: (prevotes[r] | {i: proposal[r]})}
    and step = step | {i: 1}
}

// Validator i prevotes nil in round r (honest only)
action PrevoteNil(i: 0..N, r: 0..MaxRound) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 0
    require prevotes[r][i] == -2
    prevotes = prevotes | {r: (prevotes[r] | {i: -1})}
    and step = step | {i: 1}
}

// Validator i precommits for value v after seeing 2F+1 prevotes (honest only)
action PrecommitBlock(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 1
    require precommits[r][i] == -2
    require PrevoteCount(r, v) >= Quorum()
    require proposal[r] == v
    precommits = precommits | {r: (precommits[r] | {i: v})}
    and step = step | {i: 2}
    and lockedValue = lockedValue | {i: v}
    and lockedRound = lockedRound | {i: r}
    and validValue = validValue | {i: v}
    and validRound = validRound | {i: r}
}

// Validator i precommits nil after 2F+1 nil prevotes (honest only)
action PrecommitNil(i: 0..N, r: 0..MaxRound) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 1
    require precommits[r][i] == -2
    require PrevoteCount(r, -1) >= Quorum()
    precommits = precommits | {r: (precommits[r] | {i: -1})}
    and step = step | {i: 2}
}

// Validator i precommits nil on prevote timeout (honest only)
action PrecommitTimeout(i: 0..N, r: 0..MaxRound) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 1
    require precommits[r][i] == -2
    require AnyPrevoteCount(r) >= Quorum()
    precommits = precommits | {r: (precommits[r] | {i: -1})}
    and step = step | {i: 2}
}

// Validator i decides value v (any validator, including faulty, can observe precommits)
action Decide(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require decision[i] == -1
    require PrecommitCount(r, v) >= Quorum()
    require proposal[r] == v
    decision = decision | {i: v}
}

// Validator i moves to next round (honest only)
action NextRound(i: 0..N, r: 0..MaxRound) {
    require not faulty[i]
    require round[i] == r
    require step[i] == 2
    require r < MaxRound
    require AnyPrecommitCount(r) >= Quorum()
    round = round | {i: r + 1}
    and step = step | {i: 0}
}

// Agreement: no two honest validators decide different values
invariant Agreement {
    all i in 0..N: all j in 0..N:
        (not faulty[i] and not faulty[j]
         and decision[i] != -1 and decision[j] != -1)
        implies decision[i] == decision[j]
}
