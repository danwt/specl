module Reactor

// Event-driven reactor pattern (select/epoll/kqueue).
// N+1 file descriptors with pending events. A single reactor
// thread dispatches events to handlers. Handlers run to completion
// before the next event is dispatched (no concurrent handlers).
//
// Use: specl check reactor.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (48 states, 0.0s)

const N: 0..3

// Per-fd: has pending event?
var pending: Dict[0..N, Bool]

// Reactor state: 0=polling, 1=dispatching
var reactor: 0..1

// Which fd is being handled (-1 = none, encoded as N+1)
var handling: 0..N

// Is a handler currently running?
var handler_active: Bool

init {
    pending = {fd: false for fd in 0..N}
    and reactor = 0
    and handling = 0
    and handler_active = false
}

// External event arrives on an fd
action EventArrive(fd: 0..N) {
    require pending[fd] == false
    pending = pending | {fd: true}
}

// Reactor picks up a pending event
action Dispatch(fd: 0..N) {
    require reactor == 0
    require handler_active == false
    require pending[fd] == true
    reactor = 1
    and handling = fd
    and handler_active = true
    and pending = pending | {fd: false}
}

// Handler completes
action HandlerDone() {
    require handler_active == true
    handler_active = false
    and reactor = 0
}

// At most one handler at a time (single-threaded reactor)
invariant SingleThreaded {
    reactor == 0 or handler_active == true
}

// Handler only runs when dispatched
invariant HandlerImpliesDispatch {
    handler_active == true implies reactor == 1
}
