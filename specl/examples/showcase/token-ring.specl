module TokenRing

// Token Ring mutual exclusion for N+1 processes arranged in a ring.
// A single token circulates: only the token holder may enter the critical section.
// Processes pass the token to their successor (p+1) % (N+1) when done.
//
// Use: specl check token-ring.specl -c N=3 --no-deadlock
// Verified: N=3 -> OK (100 states, 0.0s)

const N: 0..5

// 0=idle, 1=critical, 2=done (holding token, ready to pass)
var pc: Dict[0..N, 0..2]
var token: 0..N  // which process holds the token

init {
    pc = {p: 0 for p in 0..N}
    and token = 0
}

// Token holder enters critical section
action Enter(p: 0..N) {
    require pc[p] == 0
    require token == p
    pc = pc | {p: 1}
}

// Token holder exits critical section
action Exit(p: 0..N) {
    require pc[p] == 1
    require token == p
    pc = pc | {p: 2}
}

// Pass token to next process in the ring
action PassToken(p: 0..N) {
    require pc[p] == 2
    require token == p
    token = (p + 1) % (N + 1)
    and pc = pc | {p: 0}
}

// Token holder may skip critical section and pass directly
action Skip(p: 0..N) {
    require pc[p] == 0
    require token == p
    token = (p + 1) % (N + 1)
}

// Mutual exclusion: at most one process in critical section
invariant MutualExclusion {
    all p in 0..N: all q in 0..N:
        (p != q) implies not (pc[p] == 1 and pc[q] == 1)
}

// Token uniqueness: exactly one process can act on the token
invariant TokenValid {
    token >= 0 and token <= N
}
