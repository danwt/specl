module Percolator

// Google Percolator - Distributed Transactions with Snapshot Isolation
// Based on: PingCAP TLA+ specification (github.com/pingcap/tla-plus)
// C+1 clients (0..C), K+1 keys (0..K). Client c's primary key = c (requires C <= K).
// MaxTs = 2*(C+1) bounds timestamps. Each client uses 2 ts: start + commit.
// Use: specl check percolator.specl -c C=2 -c K=2 -c MaxTs=8 --no-deadlock --fast
// Baseline: C=1 K=1 MaxTs=4 -> 3K states, <1s
// Full: C=2 K=2 MaxTs=8 (3 clients, 3 keys) -> >5 min check (large state space)

const C: Int
const K: Int
const MaxTs: Int

// Client state: 0=init, 1=working, 2=prewriting, 3=committing, 4=committed, 5=aborted
var clientState: Dict[Int, Int]
var clientStartTs: Dict[Int, Int]
var clientCommitTs: Dict[Int, Int]
// clientPending[c][k] = true means key k still needs prewrite for client c
var clientPending: Dict[Int, Dict[Int, Bool]]

// Global monotonic timestamp oracle
var nextTs: Int

// Per-key data versions: keyData[k][ts] = true means data written at start_ts=ts
var keyData: Dict[Int, Dict[Int, Bool]]

// Per-key lock (at most one per key, enforced by canLockKey)
// -1 = no lock
var keyLockTs: Dict[Int, Int]
var keyLockPrimary: Dict[Int, Int]

// Per-key write log: parallel sequences of commit and start timestamps
var keyWriteCts: Dict[Int, Seq[Int]]
var keyWriteSts: Dict[Int, Seq[Int]]

// Auxiliary variables for snapshot isolation verification
var keyLastReadTs: Dict[Int, Int]
var keySi: Dict[Int, Bool]

// Client c's primary key is c
func PrimaryKey(c) { c }

func HasLockEQ(k, ts) { keyLockTs[k] == ts }
func HasLockLE(k, ts) { keyLockTs[k] != -1 and keyLockTs[k] <= ts }

func HasWriteWithStartTs(k, sTs) {
    any n in 0..C: n < len(keyWriteSts[k]) and keyWriteSts[k][n] == sTs
}

func CanLockKey(k, ts) {
    keyLockTs[k] == -1
    and not (any n in 0..C: n < len(keyWriteCts[k]) and keyWriteCts[k][n] >= ts)
}

init {
    nextTs = 0
    and clientState = {c: 0 for c in 0..C}
    and clientStartTs = {c: 0 for c in 0..C}
    and clientCommitTs = {c: 0 for c in 0..C}
    and clientPending = {c: {k: true for k in 0..K} for c in 0..C}
    and keyData = {k: {ts: false for ts in 1..MaxTs} for k in 0..K}
    and keyLockTs = {k: -1 for k in 0..K}
    and keyLockPrimary = {k: -1 for k in 0..K}
    and keyWriteCts = {k: [] for k in 0..K}
    and keyWriteSts = {k: [] for k in 0..K}
    and keyLastReadTs = {k: 0 for k in 0..K}
    and keySi = {k: true for k in 0..K}
}

// Assign start_ts to a new transaction
action Start(c: 0..C) {
    require clientState[c] == 0
    nextTs = nextTs + 1
    and clientState = clientState | {c: 1}
    and clientStartTs = clientStartTs | {c: nextTs + 1}
}

// Client advances from working to prewriting phase
action GetAdvance(c: 0..C) {
    require clientState[c] == 1
    clientState = clientState | {c: 2}
}

// Read a key (updates last-read timestamp for SI tracking)
action GetRead(c: 0..C, k: 0..K) {
    require clientState[c] == 1
    require keyLockTs[k] == -1 or keyLockTs[k] > clientStartTs[c]
    require keyLastReadTs[k] < clientStartTs[c]
    keyLastReadTs = keyLastReadTs | {k: clientStartTs[c]}
}

// Cleanup stale primary lock: always rollback
action CleanupPrimaryLock(c: 0..C, k: 0..K) {
    require clientState[c] == 1
    require HasLockLE(k, clientStartTs[c])
    require keyLockPrimary[k] == k
    keyData = keyData | {k: (keyData[k] | {keyLockTs[k]: false})}
    and keyLockTs = keyLockTs | {k: -1}
    and keyLockPrimary = keyLockPrimary | {k: -1}
}

// Cleanup stale secondary lock: primary not committed, primary still locked -> rollback primary
action CleanupSecRollbackPri(c: 0..C, k: 0..K) {
    require clientState[c] == 1
    require HasLockLE(k, clientStartTs[c])
    require keyLockPrimary[k] != k
    require not HasWriteWithStartTs(keyLockPrimary[k], keyLockTs[k])
    require HasLockEQ(keyLockPrimary[k], keyLockTs[k])
    keyData = keyData | {keyLockPrimary[k]: (keyData[keyLockPrimary[k]] | {keyLockTs[k]: false})}
    and keyLockTs = keyLockTs | {keyLockPrimary[k]: -1}
    and keyLockPrimary = keyLockPrimary | {keyLockPrimary[k]: -1}
}

// Cleanup stale secondary lock: primary not committed, primary unlocked -> rollback secondary
action CleanupSecRollbackSec(c: 0..C, k: 0..K) {
    require clientState[c] == 1
    require HasLockLE(k, clientStartTs[c])
    require keyLockPrimary[k] != k
    require not HasWriteWithStartTs(keyLockPrimary[k], keyLockTs[k])
    require not HasLockEQ(keyLockPrimary[k], keyLockTs[k])
    keyData = keyData | {k: (keyData[k] | {keyLockTs[k]: false})}
    and keyLockTs = keyLockTs | {k: -1}
    and keyLockPrimary = keyLockPrimary | {k: -1}
}

// Cleanup stale secondary lock: primary committed -> commit secondary
// wi indexes into primary's write log to find matching write
action CleanupSecCommit(c: 0..C, k: 0..K, wi: 0..C) {
    require clientState[c] == 1
    require HasLockLE(k, clientStartTs[c])
    require keyLockPrimary[k] != k
    require wi < len(keyWriteSts[keyLockPrimary[k]])
    require keyWriteSts[keyLockPrimary[k]][wi] == keyLockTs[k]
    keyLockTs = keyLockTs | {k: -1}
    and keyLockPrimary = keyLockPrimary | {k: -1}
    and keyWriteCts = keyWriteCts | {k: keyWriteCts[k] ++ [keyWriteCts[keyLockPrimary[k]][wi]]}
    and keyWriteSts = keyWriteSts | {k: keyWriteSts[k] ++ [keyLockTs[k]]}
    and keySi = keySi | {k: (if keyLastReadTs[k] >= keyWriteCts[keyLockPrimary[k]][wi] then false else keySi[k])}
}

// All keys locked, advance to committing phase
action PrewriteAdvance(c: 0..C) {
    require clientState[c] == 2
    require all k in 0..K: not clientPending[c][k]
    nextTs = nextTs + 1
    and clientState = clientState | {c: 3}
    and clientCommitTs = clientCommitTs | {c: nextTs + 1}
}

// Lock primary key (must be locked before secondaries)
action PrewritePrimary(c: 0..C) {
    require clientState[c] == 2
    require clientPending[c][c]
    require CanLockKey(c, clientStartTs[c])
    keyLockTs = keyLockTs | {c: clientStartTs[c]}
    and keyLockPrimary = keyLockPrimary | {c: c}
    and keyData = keyData | {c: (keyData[c] | {clientStartTs[c]: true})}
    and clientPending = clientPending | {c: (clientPending[c] | {c: false})}
}

// Lock a secondary key (primary must already be locked)
action PrewriteSecondary(c: 0..C, k: 0..K) {
    require clientState[c] == 2
    require k != c
    require clientPending[c][k]
    require not clientPending[c][c]
    require CanLockKey(k, clientStartTs[c])
    keyLockTs = keyLockTs | {k: clientStartTs[c]}
    and keyLockPrimary = keyLockPrimary | {k: c}
    and keyData = keyData | {k: (keyData[k] | {clientStartTs[c]: true})}
    and clientPending = clientPending | {c: (clientPending[c] | {k: false})}
}

// Commit primary key
action Commit(c: 0..C) {
    require clientState[c] == 3
    require HasLockEQ(c, clientStartTs[c])
    keyWriteCts = keyWriteCts | {c: keyWriteCts[c] ++ [clientCommitTs[c]]}
    and keyWriteSts = keyWriteSts | {c: keyWriteSts[c] ++ [clientStartTs[c]]}
    and keyLockTs = keyLockTs | {c: -1}
    and keyLockPrimary = keyLockPrimary | {c: -1}
    and clientState = clientState | {c: 4}
    and keySi = keySi | {c: (if keyLastReadTs[c] >= clientCommitTs[c] then false else keySi[c])}
}

// Abort (from any state except committed)
action Abort(c: 0..C) {
    require clientState[c] != 4
    require clientState[c] != 5
    clientState = clientState | {c: 5}
}

// Write ordering: each write's commit_ts > start_ts, no overlap between consecutive writes
invariant WriteConsistency {
    all k in 0..K: all n in 0..C:
        (n < len(keyWriteCts[k])) implies (
            keyWriteSts[k][n] < keyWriteCts[k][n]
            and (n > 0 implies keyWriteCts[k][n - 1] < keyWriteSts[k][n])
        )
}

// When committing with primary lock held, all secondary locks must exist
invariant LockConsistency {
    all c in 0..C: all k in 0..K:
        (clientState[c] == 3 and keyLockTs[c] == clientStartTs[c] and k != c)
        implies keyLockTs[k] == clientStartTs[c]
}

// Aborted transactions must not have committed primary writes
invariant AbortedConsistency {
    all c in 0..C:
        (clientState[c] == 5 and clientCommitTs[c] != 0)
        implies not (any n in 0..C:
            n < len(keyWriteCts[c]) and keyWriteCts[c][n] == clientCommitTs[c])
}

// Snapshot isolation: preserved for all keys
invariant SnapshotIsolation {
    all k in 0..K: keySi[k]
}
