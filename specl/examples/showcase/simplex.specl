module Simplex

// Simplex consensus — crash-fault variant (single-shot consensus)
// From: Chan & Pass, "Simplex Consensus: A Simple and Fast Consensus Protocol" (TCC 2023)
// N is the last player index (N+1 players total, 0..N)
// f < (N+1)/2 may crash, no Byzantine behavior
// Leader of iteration h: h % (N + 1)
// Notarization: leader's proposal alone suffices (crash = no equivocation)
// Dummy blocks need >n/2 votes; Finalization needs >n/2 finalize messages
// Use: specl check simplex.specl -c N=2 -c MaxIter=2 -c V=1 --no-deadlock --fast
// Verified: N=2 MaxIter=2 V=1 -> 277K states, 3s, FinalizationSafety + Agreement OK
// Scale up: N=2 MaxIter=3 V=1 (>5 min check)

const N: Int
const MaxIter: Int
const V: Int

// Per player: current iteration (monotonically increasing)
var iter: Dict[Int, Int]

// Per iteration: value proposed by leader (-1 = no proposal yet)
var proposed: Dict[Int, Int]

// Per iteration × player: voted for dummy block (timeout fired)?
var dummyVote: Dict[Int, Dict[Int, Bool]]

// Per iteration × player: sent finalize message?
var finMsg: Dict[Int, Dict[Int, Bool]]

// Per player: decided value (-1 = undecided)
var decided: Dict[Int, Int]

init {
    iter = {i: 0 for i in 0..N};
    proposed = {h: -1 for h in 0..MaxIter};
    dummyVote = {h: {i: false for i in 0..N} for h in 0..MaxIter};
    finMsg = {h: {i: false for i in 0..N} for h in 0..MaxIter};
    decided = {i: -1 for i in 0..N};
}

// Leader of iteration h proposes value v
// In crash-fault model, the leader's proposal alone constitutes notarization
// Chain-linking: must re-propose the value from any earlier real block
action LeaderPropose(h: 0..MaxIter, v: 0..V) {
    require proposed[h] == -1;
    require iter[h % (N + 1)] == h;
    require all h2 in 0..MaxIter: (h2 < h and proposed[h2] != -1) implies v == proposed[h2];
    proposed = proposed | {h: v};
}

// Player i votes for the dummy block at iteration h (timeout fired)
action VoteDummy(h: 0..MaxIter, i: 0..N) {
    require iter[i] == h;
    require dummyVote[h][i] == false;
    dummyVote = dummyVote | {h: (dummyVote[h] | {i: true})};
}

// Player i advances to the next iteration
// Requires current iteration has a notarized block (real proposal or dummy majority)
action AdvanceIter(i: 0..N) {
    require iter[i] < MaxIter;
    // Notarized: either leader proposed (real block) or majority voted dummy
    require proposed[iter[i]] != -1
        or len({j in 0..N if dummyVote[iter[i]][j]}) * 2 > N + 1
    iter = iter | {i: iter[i] + 1};
}

// Player i sends finalize for iteration h
// Sent when: player advanced past h, saw a real block, and didn't vote dummy
action SendFinalize(h: 0..MaxIter, i: 0..N) {
    require iter[i] > h;
    require proposed[h] != -1;
    require dummyVote[h][i] == false;
    require finMsg[h][i] == false;
    finMsg = finMsg | {h: (finMsg[h] | {i: true})};
}

// Player i decides upon seeing >n/2 finalize messages for iteration h
action Decide(i: 0..N, h: 0..MaxIter) {
    require decided[i] == -1;
    require proposed[h] != -1;
    require len({j in 0..N if finMsg[h][j]}) * 2 > N + 1;
    decided = decided | {i: proposed[h]};
}

// Finalization safety (Claim B from the paper):
// Trivially true by pigeonhole (finalize requires not voting dummy),
// but kept as documentation of the paper's claim.
invariant FinalizationSafety {
    all h in 0..MaxIter:
        (len({i in 0..N if finMsg[h][i]}) * 2 > N + 1)
        implies (len({j in 0..N if dummyVote[h][j]}) * 2 <= N + 1)
}

// Agreement: no two players decide different values
invariant Agreement {
    all i in 0..N: all j in 0..N:
        (decided[i] != -1 and decided[j] != -1)
        implies decided[i] == decided[j]
}
