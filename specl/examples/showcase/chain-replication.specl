module ChainReplication

// Chain Replication (van Renesse & Schneider, 2004).
// Linearizable storage using a chain of N+1 replicas.
// Writes enter at the head, propagate down the chain,
// and are committed when they reach the tail.
// Reads served only by the tail (always sees latest committed value).
//
// Safety: reads always return the latest committed write.
// No two committed values can diverge.
//
// Use: specl check chain-replication.specl -c N=2 -c MaxVal=2 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxVal=2 -> OK (23 states, 0.0s)

const N: 0..3
const MaxVal: 1..3

// Per-replica stored value
var store: Dict[0..N, 0..MaxVal]

// Per-replica: number of writes applied (for ordering)
var applied: Dict[0..N, 0..MaxVal]

// How far the latest write has propagated (index of last replica that has it)
var prop: 0..N

// Is there a write in flight?
var writing: Bool

// Latest committed value (at tail)
var committed: 0..MaxVal

init {
    store = {r: 0 for r in 0..N};
    applied = {r: 0 for r in 0..N};
    prop = 0;
    writing = false;
    committed = 0;
}

// Client sends write to head (replica 0)
action ClientWrite(v: 1..MaxVal) {
    require writing == false;
    require applied[0] < MaxVal;
    store = store | {0: v};
    applied = applied | {0: applied[0] + 1};
    prop = 0;
    writing = true;
}

// Write propagates from replica r to replica r+1
action Propagate(r: 0..N) {
    require writing == true;
    require prop == r;
    require r < N;
    store = store | {r + 1: store[r]};
    applied = applied | {r + 1: applied[r + 1] + 1};
    prop = r + 1;
}

// Write reaches tail â€” commit
action CommitAtTail() {
    require writing == true;
    require prop == N;
    committed = store[N];
    writing = false;
}

// Tail value always matches committed value
invariant TailConsistency {
    writing == false implies store[N] == committed
}

// All replicas ahead of propagation point have the same value
invariant ChainOrder {
    all i in 0..N: all j in 0..N:
        (writing == true and i <= prop and j <= prop)
        implies store[i] == store[j]
}
