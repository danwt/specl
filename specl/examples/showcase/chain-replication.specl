module ChainReplication

// Chain Replication (van Renesse & Schneider, 2004).
// Linearizable storage using a chain of N+1 replicas.
// Writes enter at the head, propagate down the chain,
// and are committed when they reach the tail.
// Reads served only by the tail (always sees latest committed value).
//
// Safety: reads always return the latest committed write.
// No two committed values can diverge.
//
// Use: specl check chain-replication.specl -c N=2 -c MaxVal=2 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxVal=2 -> OK (23 states, 0.0s)

const N: 0..3
const MaxVal: 1..3

// Per-replica stored value
var store: Dict[0..N, 0..MaxVal]

// Per-replica: number of writes applied (for ordering)
var applied: Dict[0..N, 0..MaxVal]

// How far the latest write has propagated (index of last replica that has it)
var prop: 0..N

// Is there a write in flight?
var writing: Bool

// Latest committed value (at tail)
var committed: 0..MaxVal

init {
    store = {r: 0 for r in 0..N}
    and applied = {r: 0 for r in 0..N}
    and prop = 0
    and writing = false
    and committed = 0
}

// Client sends write to head (replica 0)
action ClientWrite(v: 1..MaxVal) {
    require writing == false
    require applied[0] < MaxVal
    store = store | {0: v}
    and applied = applied | {0: applied[0] + 1}
    and prop = 0
    and writing = true
}

// Write propagates from replica r to replica r+1
action Propagate(r: 0..N) {
    require writing == true
    require prop == r
    require r < N
    store = store | {r + 1: store[r]}
    and applied = applied | {r + 1: applied[r + 1] + 1}
    and prop = r + 1
}

// Write reaches tail â€” commit
action CommitAtTail() {
    require writing == true
    require prop == N
    committed = store[N]
    and writing = false
}

// Tail value always matches committed value
invariant TailConsistency {
    writing == false implies store[N] == committed
}

// All replicas ahead of propagation point have the same value
invariant ChainOrder {
    all i in 0..N: all j in 0..N:
        (writing == true and i <= prop and j <= prop)
        implies store[i] == store[j]
}
