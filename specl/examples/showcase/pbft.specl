module PBFT

// Simplified PBFT (Practical Byzantine Fault Tolerance) for one consensus slot.
// N+1 replicas (3f+1, with at most f Byzantine faults).
//
// Protocol phases:
// 1. Pre-prepare: primary (replica 0) proposes a value
// 2. Prepare: replicas broadcast prepare messages; 2f+1 prepares = "prepared"
// 3. Commit: replicas broadcast commit messages; 2f+1 commits = "committed"
//
// Byzantine replicas can send arbitrary messages (modeled by nondeterministic
// prepare/commit for any value). Honest replicas follow the protocol.
//
// N=3 gives 4 replicas, f=1 fault. Quorum = 2f+1 = 3.
//
// Use: specl check pbft.specl -c N=3 -c F=1 -c MaxVal=1 --no-deadlock --no-auto --bfs
// Verified: N=3 F=1 MaxVal=1 -> OK (2.6K states, 0.0s)

const N: 1..6
const F: 0..2
const MaxVal: 0..2

// Which replicas are Byzantine (fixed set, up to F of them)
var byzantine: Dict[0..N, Bool]
var byz_count: 0..F

// Messages: prepare[r] = value r prepared for, commit[r] = value r committed for
// -1 (represented as MaxVal+1 would be ideal but we use a flag instead)
var prepared_val: Dict[0..N, 0..MaxVal]
var has_prepared: Dict[0..N, Bool]
var committed_val: Dict[0..N, 0..MaxVal]
var has_committed: Dict[0..N, Bool]

// Primary's proposal
var proposed: Bool
var proposal: 0..MaxVal

// Final decisions
var decided: Dict[0..N, Bool]
var decision: Dict[0..N, 0..MaxVal]

init {
    byzantine = {r: false for r in 0..N};
    byz_count = 0;
    prepared_val = {r: 0 for r in 0..N};
    has_prepared = {r: false for r in 0..N};
    committed_val = {r: 0 for r in 0..N};
    has_committed = {r: false for r in 0..N};
    proposed = false;
    proposal = 0;
    decided = {r: false for r in 0..N};
    decision = {r: 0 for r in 0..N};
}

// Designate replica r as Byzantine (up to F total)
action MakeByzantine(r: 0..N) {
    require byzantine[r] == false;
    require byz_count < F;
    byzantine = byzantine | {r: true};
    byz_count = byz_count + 1;
}

// Primary (replica 0) proposes a value
action Propose(v: 0..MaxVal) {
    require proposed == false;
    require byzantine[0] == false;
    proposed = true;
    proposal = v;
}

// Honest replica r prepares the proposed value
action HonestPrepare(r: 0..N) {
    require proposed == true;
    require byzantine[r] == false;
    require has_prepared[r] == false;
    prepared_val = prepared_val | {r: proposal};
    has_prepared = has_prepared | {r: true};
}

// Byzantine replica r prepares any value
action ByzantinePrepare(r: 0..N, v: 0..MaxVal) {
    require byzantine[r] == true;
    require has_prepared[r] == false;
    prepared_val = prepared_val | {r: v};
    has_prepared = has_prepared | {r: true};
}

// Honest replica r commits after seeing 2f+1 matching prepares
action HonestCommit(r: 0..N) {
    require byzantine[r] == false;
    require has_prepared[r] == true;
    require has_committed[r] == false;
    // Need 2f+1 prepares for the same value as r's prepare
    require len({q in 0..N if has_prepared[q] and prepared_val[q] == prepared_val[r]}) * 1 >= 2 * F + 1;
    committed_val = committed_val | {r: prepared_val[r]};
    has_committed = has_committed | {r: true};
}

// Byzantine replica r commits any value
action ByzantineCommit(r: 0..N, v: 0..MaxVal) {
    require byzantine[r] == true;
    require has_committed[r] == false;
    committed_val = committed_val | {r: v};
    has_committed = has_committed | {r: true};
}

// Honest replica r decides after seeing 2f+1 matching commits
action Decide(r: 0..N) {
    require byzantine[r] == false;
    require has_committed[r] == true;
    require decided[r] == false;
    require len({q in 0..N if has_committed[q] and committed_val[q] == committed_val[r]}) * 1 >= 2 * F + 1;
    decided = decided | {r: true};
    decision = decision | {r: committed_val[r]};
}

// Agreement: all honest decided replicas agree
invariant Agreement {
    all i in 0..N: all j in 0..N:
        (decided[i] and decided[j] and byzantine[i] == false and byzantine[j] == false)
        implies decision[i] == decision[j]
}
