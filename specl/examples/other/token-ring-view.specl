module TokenRingView

// Token ring with a view abstraction.
//
// N nodes pass a token around a ring. An auxiliary `steps` counter
// tracks total transitions. The safety property (at most one token)
// depends only on `has_token`, not `steps`.
//
// Without `view`: state space = ring_states * step_values (explodes with MaxSteps).
// With `view { has_token }`: state space = ring_states only.
//
// Quick: specl check token-ring-view.specl -c N=4 -c MaxSteps=20 --no-deadlock --bfs
// Without view the state space is ~80 states (4 positions * 20 steps).
// With view it is only 4 states (4 positions).

const N: 0..99
const MaxSteps: 0..99

var has_token: Dict[0..N, Bool]
var steps: 0..MaxSteps

init {
    has_token = {i: (i == 0) for i in 0..N};
    steps = 0;
}

action PassToken(src: 0..N) {
    require has_token[src];
    require steps < MaxSteps;
    let dst = (src + 1) % N;
    has_token = has_token | {src: false, dst: true};
    steps = steps + 1;
}

// Only `has_token` matters for state deduplication.
// The `steps` counter is auxiliary bookkeeping.
view { has_token }

invariant AtMostOneToken {
    len({i in 0..N if has_token[i]}) <= 1
}
