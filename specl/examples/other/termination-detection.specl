module TerminationDetection

// Dijkstra-Safra Termination Detection (1980/1987).
// N+1 processes in a ring. Each process is either active or passive.
// Active processes may send messages that activate passive processes.
// A token circulates the ring to detect global quiescence
// (all passive, no messages in transit).
//
// The token carries a color: white if all visited processes were
// passive, black if any were active or sent a message.
// Detection succeeds when the token returns to initiator as white
// after a full round with all processes passive.
//
// Use: specl check termination-detection.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (989 states, 0.0s)

const N: 0..3

// Per-process: active or passive
var active: Dict[0..N, Bool]

// Per-process color: 0=white, 1=black (sent a message since token visit)
var color: Dict[0..N, 0..1]

// Token position (which process holds it; starts at 0)
var token_pos: 0..N

// Token color: 0=white, 1=black
var token_color: 0..1

// Has the token been sent out (started a round)?
var token_sent: Bool

// Number of in-transit messages (abstract counter)
var in_transit: 0..3

// Ghost: termination detected
var detected: Bool

init {
    active = {p: true for p in 0..N};
    color = {p: 0 for p in 0..N};
    token_pos = 0;
    token_color = 0;
    token_sent = false;
    in_transit = 0;
    detected = false;
}

// Process p goes passive (finishes its work)
action GoPassive(p: 0..N) {
    require active[p] == true;
    active = active | {p: false};
}

// Active process p sends a message to another process
action SendMessage(p: 0..N) {
    require active[p] == true;
    require in_transit < 3;
    color = color | {p: 1};
    in_transit = in_transit + 1;
}

// Passive process p receives a message and becomes active
// Receiver turns black (may have been activated after token passed)
action ReceiveMessage(p: 0..N) {
    require in_transit > 0;
    require active[p] == false;
    active = active | {p: true};
    color = color | {p: 1};
    in_transit = in_transit - 1;
}

// Initiator starts the token (sends from process 0 to process 1)
action StartToken() {
    require token_sent == false;
    require active[0] == false;
    require detected == false;
    token_sent = true;
    token_pos = 1;
    token_color = color[0];
}

// Token passes from clean white process p to p+1
action PassTokenClean(p: 0..N) {
    require token_sent == true;
    require token_pos == p;
    require p != 0;
    require p < N;
    require active[p] == false;
    require color[p] == 0;
    require detected == false;
    token_pos = p + 1;
}

// Token passes from dirty/black process p — taints token
action PassTokenDirty(p: 0..N) {
    require token_sent == true;
    require token_pos == p;
    require p != 0;
    require p < N;
    require active[p] == false;
    require color[p] == 1;
    require detected == false;
    token_color = 1;
    color = color | {p: 0};
    token_pos = p + 1;
}

// Token wraps from last process N back to process 0 (clean)
action WrapTokenClean() {
    require token_sent == true;
    require token_pos == N;
    require active[N] == false;
    require color[N] == 0;
    require detected == false;
    token_pos = 0;
}

// Token wraps from last process N back to process 0 (dirty)
action WrapTokenDirty() {
    require token_sent == true;
    require token_pos == N;
    require active[N] == false;
    require color[N] == 1;
    require detected == false;
    token_color = 1;
    color = color | {N: 0};
    token_pos = 0;
}

// Initiator checks returning token — detection succeeds
// All processes must be white (no reactivations since token visited them)
action Detect() {
    require token_sent == true;
    require token_pos == 0;
    require active[0] == false;
    require token_color == 0;
    require all p in 0..N: color[p] == 0;
    require in_transit == 0;
    detected = true;
}

// Token came back dirty — restart for another round
action RestartToken() {
    require token_sent == true;
    require token_pos == 0;
    require detected == false;
    require active[0] == false;
    require token_color == 1 or color[0] == 1;
    token_color = 0;
    color = color | {0: 0};
    token_pos = 1;
}

// Safety: if termination detected, all processes are truly passive
invariant DetectionCorrectness {
    detected == true implies (
        all p in 0..N: active[p] == false
    )
}

// Safety: if termination detected, no messages in transit
invariant DetectionNoMessages {
    detected == true implies in_transit == 0
}
