module ReadRepair

// Read Repair (DeCandia et al., 2007 / Dynamo).
// On a quorum read, the coordinator detects stale replicas and
// sends them the latest value. This ensures eventual consistency
// converges faster by repairing on every read.
//
// 3 replicas with quorum size 2. Writes go to a quorum.
// Reads go to a quorum; if replicas disagree, the coordinator
// sends the latest version to the stale replica.
//
// Use: specl check read-repair.specl -c MaxVer=3 --no-deadlock --no-auto --bfs
// Verified: MaxVer=3 -> OK (61 states, 0.0s)

const MaxVer: 2..5

// 3 replicas
var val: Dict[0..2, 0..1]
var ver: Dict[0..2, 0..MaxVer]

init {
    val = {r: 0 for r in 0..2};
    ver = {r: 0 for r in 0..2};
}

// Quorum write: update 2 of 3 replicas (skip the slow one)
action QuorumWrite(v: 0..1, slow: 0..2) {
    require ver[0] < MaxVer and ver[1] < MaxVer and ver[2] < MaxVer;
    // Find current max version
    val = {r: if r == slow then val[r] else v for r in 0..2};
    ver = {r:
        if r == slow then ver[r]
        else (if ver[0] >= ver[1] and ver[0] >= ver[2] then ver[0]
              else if ver[1] >= ver[2] then ver[1]
              else ver[2]) + 1
    for r in 0..2}
}

// Read repair: quorum read detects stale replica and repairs it.
// Coordinator reads from r1 and r2, repairs whoever is behind.
action Repair(r1: 0..2, r2: 0..2) {
    require r1 != r2;
    require ver[r1] != ver[r2];
    // Both replicas end up with the max version and its value
    val = val | {r1: if ver[r2] > ver[r1] then val[r2] else val[r1],
                 r2: if ver[r1] > ver[r2] then val[r1] else val[r2]};
    ver = ver | {r1: if ver[r2] > ver[r1] then ver[r2] else ver[r1],
                     r2: if ver[r1] > ver[r2] then ver[r1] else ver[r2]}
}

// Quorum overlap: any 2 replicas include one with the latest version
invariant QuorumOverlap {
    all i in 0..2: all j in 0..2:
        (i != j) implies (
            ver[i] >= ver[0] and ver[i] >= ver[1] and ver[i] >= ver[2]
            or ver[j] >= ver[0] and ver[j] >= ver[1] and ver[j] >= ver[2]
        )
}

// Same version means same value
invariant VersionConsistency {
    all i in 0..2: all j in 0..2:
        ver[i] == ver[j] implies val[i] == val[j]
}
