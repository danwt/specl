module MapReduce

// Map-Reduce coordination.
// M+1 map tasks produce results, then R+1 reduce tasks aggregate them.
// Coordinator tracks phase transitions.
//
// Safety: reduce only starts after all maps complete.
// No result is lost.
//
// Use: specl check map-reduce.specl -c M=2 -c R=1 --no-deadlock --no-auto --bfs
// Verified: M=2 R=1 -> OK (37 states, 0.0s)

const M: 0..3   // map tasks: 0..M
const R: 0..2   // reduce tasks: 0..R

// Phase: 0=mapping, 1=reducing, 2=done
var phase: 0..2

// Per-map task: 0=pending, 1=running, 2=complete
var map_state: Dict[0..M, 0..2]

// Per-reduce task: 0=pending, 1=running, 2=complete
var reduce_state: Dict[0..R, 0..2]

init {
    phase = 0;
    map_state = {m: 0 for m in 0..M};
    reduce_state = {r: 0 for r in 0..R};
}

// Start a map task
action StartMap(m: 0..M) {
    require phase == 0;
    require map_state[m] == 0;
    map_state = map_state | {m: 1};
}

// Complete a map task
action CompleteMap(m: 0..M) {
    require map_state[m] == 1;
    map_state = map_state | {m: 2};
}

// Transition to reduce phase (all maps complete)
action BeginReduce() {
    require phase == 0;
    require all m in 0..M: map_state[m] == 2;
    phase = 1;
}

// Start a reduce task
action StartReduce(r: 0..R) {
    require phase == 1;
    require reduce_state[r] == 0;
    reduce_state = reduce_state | {r: 1};
}

// Complete a reduce task
action CompleteReduce(r: 0..R) {
    require reduce_state[r] == 1;
    reduce_state = reduce_state | {r: 2};
}

// Mark job as done (all reduces complete)
action Done() {
    require phase == 1;
    require all r in 0..R: reduce_state[r] == 2;
    phase = 2;
}

// Reduce never starts before all maps finish
invariant ReduceAfterMap {
    (any r in 0..R: reduce_state[r] >= 1) implies
        (all m in 0..M: map_state[m] == 2)
}

// Done implies everything completed
invariant DoneImpliesComplete {
    phase == 2 implies
        (all m in 0..M: map_state[m] == 2) and
        (all r in 0..R: reduce_state[r] == 2)
}
