module ExponentialBackoff

// Exponential Backoff for contention resolution (Metcalfe & Boggs, 1976).
// When N+1 processes compete for a shared resource, failed attempts
// cause the process to back off for an exponentially increasing
// number of slots. This reduces contention and eventually allows
// one process to succeed.
//
// Models: each process has a backoff counter. On collision, the
// counter doubles. On success, it resets. Backoff must reach 0
// before another attempt.
//
// Use: specl check exponential-backoff.specl -c N=2 -c MaxBackoff=4 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxBackoff=4 -> OK (104 states)

const N: 0..3
const MaxBackoff: 2..6

// 0=idle, 1=attempting, 2=succeeded, 3=backing_off
var pc: Dict[0..N, 0..3]
var backoff: Dict[0..N, 0..MaxBackoff]
var resource_taken: Bool

init {
    pc = {p: 0 for p in 0..N};
    backoff = {p: 0 for p in 0..N};
    resource_taken = false;
}

// Process starts attempting
action Attempt(p: 0..N) {
    require pc[p] == 0;
    require backoff[p] == 0;
    pc = pc | {p: 1};
}

// Attempt succeeds: resource free
action Succeed(p: 0..N) {
    require pc[p] == 1;
    require resource_taken == false;
    resource_taken = true;
    pc = pc | {p: 2};
    backoff = backoff | {p: 0};
}

// Attempt fails: resource taken, back off
action Fail(p: 0..N) {
    require pc[p] == 1;
    require resource_taken == true;
    pc = pc | {p: 3};
    backoff = backoff | {p:
        if backoff[p] == 0 then 1
        else if backoff[p] * 2 <= MaxBackoff then backoff[p] * 2
        else MaxBackoff
    }
}

// Backoff tick: decrement counter
action BackoffTick(p: 0..N) {
    require pc[p] == 3;
    require backoff[p] > 0;
    backoff = backoff | {p: backoff[p] - 1};
}

// Backoff done: can try again
action BackoffDone(p: 0..N) {
    require pc[p] == 3;
    require backoff[p] == 0;
    pc = pc | {p: 0};
}

// Release resource
action Release(p: 0..N) {
    require pc[p] == 2;
    resource_taken = false;
    pc = pc | {p: 0};
}

// At most one process succeeds at a time
invariant MutualExclusion {
    all i in 0..N: all j in 0..N:
        (i != j) implies not (pc[i] == 2 and pc[j] == 2)
}
