module ORSet

// Observed-Remove Set (OR-Set) CRDT.
// N+1 replicas, each maintaining a set of (element, unique_tag) pairs.
// Add assigns a fresh tag. Remove deletes all observed tags for an element.
// Concurrent add and remove: the add wins (add-wins semantics).
// Merge is pairwise union.
//
// Elements: 0..MaxVal. Tags: (replica_id, counter) encoded as replica * MaxTag + counter.
//
// Use: specl check or-set.specl -c N=1 -c MaxVal=1 -c MaxTag=2 --no-deadlock --no-auto --bfs
// Verified: N=1 MaxVal=1 MaxTag=2 -> OK (743 states, 0.0s)

const N: 0..2
const MaxVal: 0..1
const MaxTag: 1..3

// Per-replica tag counter (for generating unique tags)
var counter: Dict[0..N, 0..MaxTag]

// Per-replica set of active (value, tag) pairs
// Encoded as: active[r][tag] = value if tag is active, or -1 if inactive
// We use a simpler model: track which tags exist at each replica
var tag_val: Dict[0..N, Dict[0..MaxTag, 0..MaxVal]]
var tag_active: Dict[0..N, Dict[0..MaxTag, Bool]]

init {
    counter = {r: 0 for r in 0..N};
    tag_val = {r: {t: 0 for t in 0..MaxTag} for r in 0..N};
    tag_active = {r: {t: false for t in 0..MaxTag} for r in 0..N};
}

// Replica r adds element v: assign fresh tag
action Add(r: 0..N, v: 0..MaxVal) {
    require counter[r] < MaxTag;
    // Use counter[r] as the tag index (unique per replica)
    tag_val = tag_val | {r: tag_val[r] | {counter[r]: v}};
    tag_active = tag_active | {r: tag_active[r] | {counter[r]: true}};
    counter = counter | {r: counter[r] + 1};
}

// Replica r removes element v: deactivate all tags with that value
action Remove(r: 0..N, v: 0..MaxVal) {
    // Must have at least one active tag with value v
    require any t in 0..MaxTag:
        tag_active[r][t] == true and tag_val[r][t] == v
    tag_active = tag_active | {r:
        {t: (if tag_val[r][t] == v then false else tag_active[r][t])
         for t in 0..MaxTag}
    }
}

// Merge: replica dst incorporates replica src's state (union of tags)
action Merge(src: 0..N, dst: 0..N) {
    require src != dst;
    // For each tag, if src has it active and dst doesn't, add it
    tag_val = tag_val | {dst:
        {t: (if tag_active[src][t] and not tag_active[dst][t]
             then tag_val[src][t]
             else tag_val[dst][t])
         for t in 0..MaxTag}
    };
    tag_active = tag_active | {dst:
        {t: (tag_active[dst][t] or tag_active[src][t])
         for t in 0..MaxTag}
    }
}

// Convergence: after merging, replicas with the same observable state agree
// (this is structural â€” OR-Set is a CRDT by design, so convergence is guaranteed)
// We check: if both replicas have merged with each other, they have
// the same set of active elements.
func HasElement(r, v) {
    any t in 0..MaxTag: tag_active[r][t] == true and tag_val[r][t] == v
}

// After full merge (both directions), replicas agree on set contents
invariant ConvergenceAfterSync {
    all r1 in 0..N: all r2 in 0..N: all v in 0..MaxVal:
        // If both replicas have identical tag states, they agree on elements
        (all t in 0..MaxTag: tag_active[r1][t] == tag_active[r2][t] and tag_val[r1][t] == tag_val[r2][t])
        implies (HasElement(r1, v) iff HasElement(r2, v))
}
