module BullyElection

// Bully Algorithm for leader election (Garcia-Molina, 1982).
// N+1 processes with unique IDs (0..N). Higher ID = higher priority.
// When a process detects the leader is down, it starts an election.
// It sends election messages to higher-ID processes.
// If no higher-ID process responds, it becomes leader.
// If a higher-ID process responds, it takes over the election.
// The highest active process always wins.
//
// Use: specl check bully-election.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (181 states, 0.0s)

const N: 0..3

// Per-process: 0=idle, 1=electing, 2=leader, 3=follower
var pc: Dict[0..N, 0..3]

// Who each process thinks the leader is
var leader: Dict[0..N, 0..N]

// Is a process alive?
var alive: Dict[0..N, Bool]

init {
    pc = {p: 0 for p in 0..N};
    leader = {p: N for p in 0..N};
    alive = {p: true for p in 0..N};
}

// Process p starts an election (detects leader may be down)
action StartElection(p: 0..N) {
    require alive[p] == true;
    require pc[p] == 0 or pc[p] == 3;
    pc = pc | {p: 1};
}

// Higher-priority process q takes over from lower process p
action BullyTakeover(p: 0..N, q: 0..N) {
    require pc[p] == 1;
    require q > p;
    require alive[q] == true;
    // p yields to q
    pc = pc | {p: 3, q: 1};
}

// Process p wins election (no higher alive process is electing)
action WinElection(p: 0..N) {
    require pc[p] == 1;
    require alive[p] == true;
    // No higher-priority process is alive and electing
    require all q in 0..N: q > p implies (alive[q] == false or pc[q] != 1);
    // p is the highest alive process
    require all q in 0..N: q > p implies alive[q] == false;
    pc = pc | {p: 2};
    leader = {r: p for r in 0..N};
}

// Process p crashes
action Crash(p: 0..N) {
    require alive[p] == true;
    require pc[p] != 2;
    alive = alive | {p: false};
}

// Highest alive process is always elected leader
invariant HighestWins {
    all p in 0..N:
        pc[p] == 2 implies (
            all q in 0..N: (q > p) implies alive[q] == false
        )
}

// At most one leader
invariant AtMostOneLeader {
    all i in 0..N: all j in 0..N:
        (i != j) implies not (pc[i] == 2 and pc[j] == 2)
}
