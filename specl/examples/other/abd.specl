module ABD

// ABD (Attiya-Bar-Noy-Dolev) quorum-based atomic register.
// N+1 replicas store a (value, timestamp) pair. A writer picks a new
// timestamp and writes to a quorum. A reader reads from a quorum,
// takes the highest timestamp, and writes it back to a quorum.
// Quorum intersection guarantees linearizability.
//
// Use: specl check abd.specl -c N=2 -c MaxTs=2 -c MaxVal=1 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxTs=2 MaxVal=1 -> OK (7K states, 0.0s)

const N: 1..4
const MaxTs: 1..4
const MaxVal: 0..2

var val: Dict[0..N, 0..MaxVal]
var ts: Dict[0..N, 0..MaxTs]

// Writer state: 0=idle, 1=writing
var wstate: 0..1
var wval: 0..MaxVal
var wts: 0..MaxTs
var wacks: Set[0..N]

// Reader state: 0=idle, 1=reading, 2=writeback
var rstate: 0..2
var rval: 0..MaxVal
var rts: 0..MaxTs
var rresps: Set[0..N]
var racks: Set[0..N]

// History for linearizability check
var last_written_val: 0..MaxVal
var last_written_ts: 0..MaxTs
var last_read_val: 0..MaxVal
var read_complete: Bool

init {
    val = {i: 0 for i in 0..N};
    ts = {i: 0 for i in 0..N};
    wstate = 0;
    wval = 0;
    wts = 0;
    wacks = {};
    rstate = 0;
    rval = 0;
    rts = 0;
    rresps = {};
    racks = {};
    last_written_val = 0;
    last_written_ts = 0;
    last_read_val = 0;
    read_complete = false;
}

// Writer picks value v and timestamp t, starts write phase
action WriteStart(v: 0..MaxVal, t: 1..MaxTs) {
    require wstate == 0;
    require rstate == 0;
    require t > wts;
    wstate = 1;
    wval = v;
    wts = t;
    wacks = {};
    read_complete = false;
}

// Replica i accepts the write (if timestamp is higher)
action WriteAccept(i: 0..N) {
    require wstate == 1;
    require not (i in wacks);
    require wts >= ts[i];
    val = val | {i: wval};
    ts = ts | {i: wts};
    wacks = wacks union {i};
}

// Writer completes after quorum of acks
action WriteDone() {
    require wstate == 1;
    require len(wacks) * 2 > N + 1;
    wstate = 0;
    last_written_val = wval;
    last_written_ts = wts;
}

// Reader starts by collecting values from replicas
action ReadStart() {
    require rstate == 0;
    require wstate == 0;
    rstate = 1;
    rresps = {};
    rval = 0;
    rts = 0;
    read_complete = false;
}

// Replica i responds to reader with its (val, ts)
action ReadResp(i: 0..N) {
    require rstate == 1;
    require not (i in rresps);
    // Reader takes the value with highest timestamp
    rval = (if ts[i] > rts then val[i] else rval);
    rts = (if ts[i] > rts then ts[i] else rts);
    rresps = rresps union {i};
}

// Reader got a quorum of responses, starts write-back phase
action ReadWriteBack() {
    require rstate == 1;
    require len(rresps) * 2 > N + 1;
    rstate = 2;
    racks = {};
}

// Replica i accepts the write-back
action WriteBackAccept(i: 0..N) {
    require rstate == 2;
    require not (i in racks);
    require rts >= ts[i];
    val = val | {i: rval};
    ts = ts | {i: rts};
    racks = racks union {i};
}

// Reader completes after quorum of write-back acks
action ReadDone() {
    require rstate == 2;
    require len(racks) * 2 > N + 1;
    rstate = 0;
    last_read_val = rval;
    read_complete = true;
}

// A completed read must return the last written value
// (assumes sequential access: no concurrent read and write)
invariant ReadReturnsLatest {
    read_complete implies last_read_val == last_written_val
}
