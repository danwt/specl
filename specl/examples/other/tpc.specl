module TwoPhaseCommit

// Two-Phase Commit protocol with coordinator crash
// From: Gray & Lamport, "Consensus on Transaction Commit" (2006)
//       TLA+ TwoPhase.tla from tlaplus/Examples
// N is the last resource manager index (N+1 RMs total, 0..N)
// Use: specl check tpc.specl -c N=2
// Expected: deadlock found (coordinator crashes after PREPARE, prepared RMs stuck)
// Use: specl check tpc.specl -c N=2 --no-deadlock  to verify safety invariants only

const N: Int

// RM states: 0=Working, 1=Prepared, 2=Committed, 3=Aborted
// TM states: 0=Init, 1=Committed, 2=Aborted
var rmState: Dict[Int, Int]
var tmState: Int
var tmPrepared: Set[Int]
var tmCrashed: Bool

init {
    rmState = {r: 0 for r in 0..N};
    tmState = 0;
    tmPrepared = {};
    tmCrashed = false;
}

// RM r votes YES by moving to Prepared
action RMPrepare(r: 0..N) {
    require rmState[r] == 0;
    rmState = rmState | {r: 1};
}

// RM r unilaterally aborts (only from Working state)
action RMChooseToAbort(r: 0..N) {
    require rmState[r] == 0;
    rmState = rmState | {r: 3};
}

// TM receives prepared message from RM r
action TMRcvPrepared(r: 0..N) {
    require not tmCrashed;
    require tmState == 0;
    require rmState[r] == 1;
    tmPrepared = tmPrepared union {r};
}

// TM commits: all RMs have prepared
action TMCommit() {
    require not tmCrashed;
    require tmState == 0;
    require all r in 0..N: (r in tmPrepared);
    tmState = 1;
}

// TM aborts
action TMAbort() {
    require not tmCrashed;
    require tmState == 0;
    tmState = 2;
}

// RM r learns the commit decision
action RMRcvCommit(r: 0..N) {
    require tmState == 1;
    rmState = rmState | {r: 2};
}

// RM r learns the abort decision
action RMRcvAbort(r: 0..N) {
    require tmState == 2;
    rmState = rmState | {r: 3};
}

// Coordinator crashes (can happen while TM is in Init)
action CoordinatorCrash() {
    require not tmCrashed;
    require tmState == 0;
    tmCrashed = true;
}

// Agreement: no RM committed while another aborted
invariant Agreement {
    all i in 0..N: all j in 0..N:
        not (rmState[i] == 2 and rmState[j] == 3)
}

// Validity: if TM committed, all RMs were prepared (not still working)
invariant CommitValidity {
    tmState == 1 implies all r in 0..N: rmState[r] != 0
}

// Consistency: if TM aborted, no RM committed
invariant AbortConsistency {
    tmState == 2 implies all r in 0..N: rmState[r] != 2
}
