module CometBFT

// CometBFT/Tendermint BFT consensus â€” single height with Byzantine faults
// From: Buchman, Kwon, Milosevic, "The latest gossip on BFT consensus" (2018)
// Based on: Konnov, Milosevic, Widder TLA+ spec (TendermintAcc_004_draft.tla)
// N+1 validators (0..N), tolerating F Byzantine faults where N+1 >= 3F+1
// Quorum = 2F+1 (strict majority of honest + Byzantine)
//
// Byzantine model: faulty validators can equivocate (change votes), propose
// conflicting values, and skip protocol rules. Equivocation is modeled by
// allowing Byzantine validators to overwrite their votes at any time.
//
// Use: specl check comet.specl -c N=3 -c MaxRound=1 -c V=1 -c F=1 --no-deadlock --fast
// Small: N=3 MaxRound=0 V=1 F=1 (no view changes)
// Full: N=3 MaxRound=1 V=1 F=1 (exercises round changes + locking, large state space)
// WARNING: F=0 is degenerate (Quorum=1, Agreement trivially violated). Always use F>=1.

const N: Int
const MaxRound: Int
const V: Int
const F: Int

// Step encoding: 0=Propose, 1=Prevote, 2=Precommit
var step: Dict[Int, Int]
var round: Dict[Int, Int]
var lockedValue: Dict[Int, Int]
var lockedRound: Dict[Int, Int]
var validValue: Dict[Int, Int]
var validRound: Dict[Int, Int]

// Vote tracking: per round per validator
// -2 = not yet voted, -1 = nil, 0..V = value
var prevotes: Dict[Int, Dict[Int, Int]]
var precommits: Dict[Int, Dict[Int, Int]]

// Per round: proposed value (-1 = no proposal)
var proposal: Dict[Int, Int]

// Per validator: decided value (-1 = not decided)
var decision: Dict[Int, Int]

// Per validator: whether they have gone Byzantine
var faulty: Dict[Int, Bool]

func Proposer(r) { r % (N + 1) }

func PrevoteCount(r, v) {
    len({i in 0..N if prevotes[r][i] == v})
}

func PrecommitCount(r, v) {
    len({i in 0..N if precommits[r][i] == v})
}

func AnyPrevoteCount(r) {
    len({i in 0..N if prevotes[r][i] != -2})
}

func AnyPrecommitCount(r) {
    len({i in 0..N if precommits[r][i] != -2})
}

func Quorum() { 2 * F + 1 }

init {
    step = {i: 0 for i in 0..N};
    round = {i: 0 for i in 0..N};
    lockedValue = {i: -1 for i in 0..N};
    lockedRound = {i: -1 for i in 0..N};
    validValue = {i: -1 for i in 0..N};
    validRound = {i: -1 for i in 0..N};
    prevotes = {r: {i: -2 for i in 0..N} for r in 0..MaxRound};
    precommits = {r: {i: -2 for i in 0..N} for r in 0..MaxRound};
    proposal = {r: -1 for r in 0..MaxRound};
    decision = {i: -1 for i in 0..N};
    faulty = {i: false for i in 0..N};
}

// A validator goes Byzantine (at most F can)
action GoFaulty(i: 0..N) {
    require not faulty[i];
    require len({j in 0..N if faulty[j]}) < F;
    faulty = faulty | {i: true};
}

// Byzantine validator prevotes for a value (equivocation: can overwrite previous vote)
action ByzantinePrevote(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require faulty[i];
    require prevotes[r][i] != v;
    prevotes = prevotes | {r: (prevotes[r] | {i: v})};
}

// Byzantine validator prevotes nil (equivocation: can overwrite previous vote)
action ByzantinePrevoteNil(i: 0..N, r: 0..MaxRound) {
    require faulty[i];
    require prevotes[r][i] != -1;
    prevotes = prevotes | {r: (prevotes[r] | {i: -1})};
}

// Byzantine validator precommits for a value (equivocation: can overwrite previous vote)
action ByzantinePrecommit(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require faulty[i];
    require precommits[r][i] != v;
    precommits = precommits | {r: (precommits[r] | {i: v})};
}

// Byzantine validator precommits nil (equivocation: can overwrite previous vote)
action ByzantinePrecommitNil(i: 0..N, r: 0..MaxRound) {
    require faulty[i];
    require precommits[r][i] != -1;
    precommits = precommits | {r: (precommits[r] | {i: -1})};
}

// Proposer for round r proposes value v (honest only)
// If proposer has validValue, must re-propose it; otherwise any value
action Propose(r: 0..MaxRound, v: 0..V) {
    require not faulty[Proposer(r)];
    require proposal[r] == -1;
    require round[Proposer(r)] == r;
    require step[Proposer(r)] == 0;
    require validValue[Proposer(r)] == -1 or validValue[Proposer(r)] == v;
    proposal = proposal | {r: v};
}

// Byzantine proposer can propose any value (equivocation: can change proposal)
action ByzantinePropose(r: 0..MaxRound, v: 0..V) {
    require faulty[Proposer(r)];
    require proposal[r] != v;
    proposal = proposal | {r: v};
}

// Validator i prevotes for value v in round r (honest only)
action PrevoteBlock(i: 0..N, r: 0..MaxRound) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 0;
    require prevotes[r][i] == -2;
    require proposal[r] != -1;
    require lockedRound[i] == -1
        or lockedValue[i] == proposal[r]
        or (any vr in 0..MaxRound:
            vr < r
            and PrevoteCount(vr, proposal[r]) >= Quorum()
            and lockedRound[i] <= vr)
    prevotes = prevotes | {r: (prevotes[r] | {i: proposal[r]})};
    step = step | {i: 1};
}

// Validator i prevotes nil in round r (honest only)
// Nil when: no proposal received (timeout), or locked on a different value
// with no valid-round proof that would allow unlocking
action PrevoteNil(i: 0..N, r: 0..MaxRound) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 0;
    require prevotes[r][i] == -2;
    require proposal[r] == -1
        or (lockedRound[i] != -1
            and lockedValue[i] != proposal[r]
            and not (any vr in 0..MaxRound:
                vr < r
                and PrevoteCount(vr, proposal[r]) >= Quorum()
                and lockedRound[i] <= vr))
    prevotes = prevotes | {r: (prevotes[r] | {i: -1})};
    step = step | {i: 1};
}

// Validator i precommits for value v after seeing 2F+1 prevotes (honest only)
action PrecommitBlock(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 1;
    require precommits[r][i] == -2;
    require PrevoteCount(r, v) >= Quorum();
    require proposal[r] == v;
    precommits = precommits | {r: (precommits[r] | {i: v})};
    step = step | {i: 2};
    lockedValue = lockedValue | {i: v};
    lockedRound = lockedRound | {i: r};
    validValue = validValue | {i: v};
    validRound = validRound | {i: r};
}

// Validator i precommits nil after 2F+1 nil prevotes (honest only)
action PrecommitNil(i: 0..N, r: 0..MaxRound) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 1;
    require precommits[r][i] == -2;
    require PrevoteCount(r, -1) >= Quorum();
    precommits = precommits | {r: (precommits[r] | {i: -1})};
    step = step | {i: 2};
}

// Validator i precommits nil on prevote timeout (honest only)
action PrecommitTimeout(i: 0..N, r: 0..MaxRound) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 1;
    require precommits[r][i] == -2;
    require AnyPrevoteCount(r) >= Quorum();
    precommits = precommits | {r: (precommits[r] | {i: -1})};
    step = step | {i: 2};
}

// Validator i decides value v (any validator, including faulty, can observe precommits)
action Decide(i: 0..N, r: 0..MaxRound, v: 0..V) {
    require decision[i] == -1;
    require PrecommitCount(r, v) >= Quorum();
    require proposal[r] == v;
    decision = decision | {i: v};
}

// Validator i moves to next round (honest only)
action NextRound(i: 0..N, r: 0..MaxRound) {
    require not faulty[i];
    require round[i] == r;
    require step[i] == 2;
    require r < MaxRound;
    require AnyPrecommitCount(r) >= Quorum();
    round = round | {i: r + 1};
    step = step | {i: 0};
}

// Agreement: no two honest validators decide different values
invariant Agreement {
    all i in 0..N: all j in 0..N:
        (not faulty[i] and not faulty[j]
         and decision[i] != -1 and decision[j] != -1)
        implies decision[i] == decision[j]
}

// Validity: decided value must be a valid proposed value (0..V)
invariant Validity {
    all i in 0..N:
        decision[i] == -1 or (decision[i] >= 0 and decision[i] <= V)
}

// At most F validators are faulty
invariant FaultyBounded {
    len({i in 0..N if faulty[i]}) <= F
}
