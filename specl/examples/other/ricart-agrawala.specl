module RicartAgrawala

// Ricart-Agrawala distributed mutual exclusion algorithm.
// Optimization of Lamport's mutex: no explicit release messages.
// Instead, deferred replies serve as implicit release notification.
//
// To enter CS, a process:
//   1. Sends timestamped REQUEST to all others
//   2. Waits for REPLY from all others
//   3. Enters CS
// On receiving a REQUEST, a process:
//   - If not requesting or has lower priority: REPLY immediately
//   - If requesting with higher priority: defer the reply until CS exit
// On CS exit: send all deferred replies
//
// Uses 2*(N) messages per CS entry (vs 3*(N) for Lamport).
//
// Use: specl check ricart-agrawala.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (22.7K states, 0.0s)

const N: 0..3

// Process state: 0=idle, 1=requesting, 2=in_cs
var pc: Dict[0..N, 0..2]

// Logical clock per process
var clock: Dict[0..N, 0..10]

// Request timestamp
var req_ts: Dict[0..N, 0..10]

// Whether process has an active request
var has_req: Dict[0..N, Bool]

// reply[i][j] = true means i has received reply from j
var reply: Dict[0..N, Dict[0..N, Bool]]

// deferred[i][j] = true means i has deferred reply to j
var deferred: Dict[0..N, Dict[0..N, Bool]]

init {
    pc = {i: 0 for i in 0..N};
    clock = {i: 0 for i in 0..N};
    req_ts = {i: 0 for i in 0..N};
    has_req = {i: false for i in 0..N};
    reply = {i: {j: false for j in 0..N} for i in 0..N};
    deferred = {i: {j: false for j in 0..N} for i in 0..N};
}

// Process p requests the critical section
action Request(p: 0..N) {
    require pc[p] == 0;
    require clock[p] < 10;
    pc = pc | {p: 1};
    clock = clock | {p: clock[p] + 1};
    req_ts = req_ts | {p: clock[p] + 1};
    has_req = has_req | {p: true};
    reply = reply | {p: {j: (if j == p then true else false) for j in 0..N}};
}

// Process q handles p's request: reply immediately (p has higher priority or q is idle)
action ReplyImmediate(p: 0..N, q: 0..N) {
    require p != q;
    require has_req[p] == true;
    require reply[p][q] == false;
    require deferred[q][p] == false;
    // q replies immediately if idle, or if p has higher priority
    require pc[q] == 0
        or (has_req[q] == true and req_ts[p] < req_ts[q])
        or (has_req[q] == true and req_ts[p] == req_ts[q] and p < q)
    clock = clock | {q: (if req_ts[p] > clock[q] then req_ts[p] else clock[q])};
    reply = reply | {p: reply[p] | {q: true}};
}

// Process q defers reply to p (q has higher priority and is requesting/in CS)
action DeferReply(p: 0..N, q: 0..N) {
    require p != q;
    require has_req[p] == true;
    require reply[p][q] == false;
    require deferred[q][p] == false;
    // q defers: q is requesting or in CS with higher priority
    require pc[q] == 1 or pc[q] == 2;
    require has_req[q] == true;
    require req_ts[q] < req_ts[p] or (req_ts[q] == req_ts[p] and q < p);
    // Update clock on receiving request message
    clock = clock | {q: (if req_ts[p] > clock[q] then req_ts[p] else clock[q])};
    deferred = deferred | {q: deferred[q] | {p: true}};
}

// Process p enters CS
action EnterCS(p: 0..N) {
    require pc[p] == 1;
    require all q in 0..N: reply[p][q] == true;
    pc = pc | {p: 2};
}

// Process p exits CS: send all deferred replies
action ExitCS(p: 0..N) {
    require pc[p] == 2;
    pc = pc | {p: 0};
    has_req = has_req | {p: false};
    // Send all deferred replies
    reply = {i:
        {j: (if deferred[p][i] and j == p then true else reply[i][j])
         for j in 0..N}
        for i in 0..N};
    deferred = deferred | {p: {j: false for j in 0..N}};
}

// Mutual exclusion
invariant MutualExclusion {
    all p in 0..N: all q in 0..N:
        (p != q) implies not (pc[p] == 2 and pc[q] == 2)
}
