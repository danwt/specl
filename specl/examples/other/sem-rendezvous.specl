// =============================================================================
// Rendezvous - Correct Solution
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 3.3: Rendezvous (pages 12-15)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// Generalize the signal pattern so that it works both ways. Thread A has
// to wait for Thread B and vice versa. In other words, given this code:
//
//   Thread A              Thread B
//   --------              --------
//   statement a1          statement b1
//   statement a2          statement b2
//
// we want to guarantee that a1 happens before b2 and b1 happens before a2.
// In writing your solution, be sure to specify the names and initial values
// of your semaphores (little hint there).
//
// Your solution should not enforce too many constraints. For example, we
// don't care about the order of a1 and b1. In your solution, either order
// should be possible.
//
// This synchronization problem has a name; it's a rendezvous. The idea is
// that two threads rendezvous at a point of execution, and neither is allowed
// to proceed until both have arrived.
//
// =============================================================================
// SOLUTION
// =============================================================================
//
// Uses two semaphores (aArrived and bArrived), both initialized to 0:
//
//   Thread A                    Thread B
//   --------                    --------
//   statement a1                statement b1
//   aArrived.signal()           bArrived.signal()
//   bArrived.wait()             aArrived.wait()
//   statement a2                statement b2
//
// How it works:
// - If Thread A arrives first, it signals aArrived and then blocks on bArrived
// - When Thread B arrives, it signals bArrived (waking A) and waits on aArrived
// - Both threads can now proceed to their second statements
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module Rendezvous
// Use: No constants needed

// Thread progress: 0=init, 1=did_statement_1, 2=signaled, 3=waited, 4=did_statement_2
var threadA: 0..4
var threadB: 0..4

// Semaphores (represent counts, 0 means blocked)
var aArrived: 0..1
var bArrived: 0..1

init {
    threadA = 0 and
    threadB = 0 and
    aArrived = 0 and
    bArrived = 0;
}

// === Thread A actions ===

action ThreadA_a1() {
    require threadA == 0;
    threadA = 1;
}

action ThreadA_signal() {
    require threadA == 1;
    threadA = 2 and
    aArrived = 1;
}

action ThreadA_wait() {
    require threadA == 2 and bArrived == 1;
    threadA = 3 and
    bArrived = 0;
}

action ThreadA_a2() {
    require threadA == 3;
    threadA = 4;
}

// === Thread B actions ===

action ThreadB_b1() {
    require threadB == 0;
    threadB = 1;
}

action ThreadB_signal() {
    require threadB == 1;
    threadB = 2 and
    bArrived = 1;
}

action ThreadB_wait() {
    require threadB == 2 and aArrived == 1;
    threadB = 3 and
    aArrived = 0;
}

action ThreadB_b2() {
    require threadB == 3;
    threadB = 4;
}

// === Safety properties ===

invariant A1_before_B2 {
    // If B has done b2 (state 4), then A must have done a1 (state >= 1)
    threadB == 4 implies threadA >= 1
}

invariant B1_before_A2 {
    // If A has done a2 (state 4), then B must have done b1 (state >= 1)
    threadA == 4 implies threadB >= 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check rendezvous.specl --no-deadlock
//
// Expected: OK (17 states explored, max depth 8)
//
// The model verifies that:
// 1. The rendezvous constraints are satisfied (A1_before_B2, B1_before_A2)
// 2. Both threads can complete successfully
// 3. No invariant violations occur
//
// Note: Use --no-deadlock because the terminal state (both threads done) is
// a valid quiescent state, not a deadlock.
// =============================================================================
