module TwoPhaseLocking

// Strict two-phase locking (S2PL) for database concurrency control.
// N+1 transactions access R+1 shared resources. Each transaction:
//   1. Growing phase: acquire locks (shared or exclusive)
//   2. Working phase: access resources while holding locks
//   3. Shrinking phase: release all locks at commit
//
// Shared locks allow concurrent readers. Exclusive locks are exclusive.
// Strict 2PL holds all locks until commit (no cascading aborts).
//
// Use: specl check two-phase-locking.specl -c N=2 -c R=1 --no-deadlock --no-auto --bfs
// Verified: N=2 R=1 -> OK (1.5K states, 0.0s)

const N: 0..3
const R: 0..2

// Transaction state: 0=idle, 1=growing, 2=working, 3=committed
var tx_pc: Dict[0..N, 0..3]

// Lock state per resource: 0=free, 1=shared, 2=exclusive
var lock_mode: Dict[0..R, 0..2]

// Who holds each lock: set of transaction IDs
// For exclusive: exactly one holder. For shared: possibly many.
var lock_holders: Dict[0..R, Set[0..N]]

// Which resources each transaction has locked
var tx_locks: Dict[0..N, Set[0..R]]

init {
    tx_pc = {t: 0 for t in 0..N};
    lock_mode = {r: 0 for r in 0..R};
    lock_holders = {r: {} for r in 0..R};
    tx_locks = {t: {} for t in 0..N};
}

// Transaction t starts (enters growing phase)
action TxStart(t: 0..N) {
    require tx_pc[t] == 0;
    tx_pc = tx_pc | {t: 1};
}

// Transaction t acquires shared lock on resource r
action AcquireShared(t: 0..N, r: 0..R) {
    require tx_pc[t] == 1;
    require not (r in tx_locks[t]);
    // Can acquire shared if free or already shared (no exclusive)
    require lock_mode[r] == 0 or lock_mode[r] == 1;
    lock_mode = lock_mode | {r: 1};
    lock_holders = lock_holders | {r: lock_holders[r] union {t}};
    tx_locks = tx_locks | {t: tx_locks[t] union {r}};
}

// Transaction t acquires exclusive lock on resource r
action AcquireExclusive(t: 0..N, r: 0..R) {
    require tx_pc[t] == 1;
    require not (r in tx_locks[t]);
    // Can acquire exclusive only if free
    require lock_mode[r] == 0;
    lock_mode = lock_mode | {r: 2};
    lock_holders = lock_holders | {r: lock_holders[r] union {t}};
    tx_locks = tx_locks | {t: tx_locks[t] union {r}};
}

// Transaction t enters working phase (has acquired all needed locks)
action TxWork(t: 0..N) {
    require tx_pc[t] == 1;
    require len(tx_locks[t]) > 0;
    tx_pc = tx_pc | {t: 2};
}

// Transaction t commits: release all locks
action TxCommit(t: 0..N) {
    require tx_pc[t] == 2;
    tx_pc = tx_pc | {t: 3};
    lock_holders = {r:
        (if r in tx_locks[t] then lock_holders[r] diff {t} else lock_holders[r])
        for r in 0..R};
    lock_mode = {r:
        (if r in tx_locks[t] then
            (if len(lock_holders[r] diff {t}) == 0 then 0
             else lock_mode[r])
         else lock_mode[r])
        for r in 0..R};
    tx_locks = tx_locks | {t: {}};
}

// No conflicting concurrent access:
// No two working transactions hold conflicting locks on the same resource
// (both exclusive, or one exclusive + one shared)
invariant NoConflict {
    all r in 0..R:
        lock_mode[r] == 2 implies len(lock_holders[r]) <= 1
}

// Exclusive lock consistency: if mode is exclusive, exactly one holder
invariant ExclusiveConsistency {
    all r in 0..R:
        lock_mode[r] == 2 implies len(lock_holders[r]) == 1
}
