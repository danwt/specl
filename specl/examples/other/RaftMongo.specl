// RaftMongo - MongoDB's Raft consensus (simplified for 3 servers)
// From: will62794-mongo-repl-tla-models/RaftMongo.tla
// Demonstrates parameterized actions with dictionaries
// Use: -c MaxLogLen=2 -c MaxTerm=2

module RaftMongo

// 0=Follower, 1=Leader
// Bounds for finite state exploration
const MaxLogLen: Int
const MaxTerm: Int

var globalCurrentTerm: Int
var state: Dict[0..2, 0..1]
var log: Dict[0..2, Seq[Int]]
var commitTerm: Dict[0..2, Int]
var commitIndex: Dict[0..2, Int]

// Helper: get last term from a log (0 if empty)
func LastTerm(l) {
    if len(l) == 0 then 0 else l[len(l) - 1]
}

// Helper: get entry at index from log (0 if out of bounds)
func LogEntry(l, idx) {
    if idx < 0 or idx >= len(l) then 0 else l[idx]
}

init {
    globalCurrentTerm = 0;
    state = {s: 0 for s in 0..2};
    log = {s: [] for s in 0..2};
    commitTerm = {s: 0 for s in 0..2};
    commitIndex = {s: 0 for s in 0..2};
}

// AppendOplog: dst appends one entry from src's log
action AppendOplog(src: 0..2, dst: 0..2) {
    require src != dst;
    require len(log[dst]) < len(log[src]);
    require len(log[dst]) < MaxLogLen;
    require LastTerm(log[dst]) == LogEntry(log[src], len(log[dst]) - 1) or len(log[dst]) == 0;
    log = log | { dst: log[dst] ++ [log[src][len(log[dst])]] };
}

// BecomePrimary: server becomes leader if it has quorum support (2 of 3 not behind)
action BecomePrimary(s: 0..2) {
    // s needs at least one other server not behind (plus self = quorum of 2)
    require len({ other in 0..2 if other != s and LastTerm(log[s]) >= LastTerm(log[other]) }) >= 1;
    require globalCurrentTerm < MaxTerm;
    state = state | { 0: 0, 1: 0, 2: 0 } | { s: 1 };
    globalCurrentTerm = globalCurrentTerm + 1;
}

// ClientWrite: leader appends entry with current term
action ClientWrite(s: 0..2) {
    require state[s] == 1;
    require len(log[s]) < MaxLogLen;
    log = log | { s: log[s] ++ [globalCurrentTerm] };
}

// At most one leader at a time
invariant AtMostOneLeader {
    len({ s in 0..2 if state[s] == 1 }) <= 1
}
