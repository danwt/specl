// =============================================================================
// Producer-Consumer (Bounded Buffer)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 4.1: Producer-consumer problem (pages 55-63)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// In multithreaded programs there is often a division of labor between threads.
// In one common pattern, some threads are producers and some are consumers.
// Producers create items of some kind and add them to a data structure;
// consumers remove the items and process them.
//
// Event-driven programs are a good example. An "event" is something that
// happens that requires the program to respond: the user presses a key or
// moves the mouse, a block of data arrives from the disk, a packet arrives
// from the network, a pending operation completes.
//
// Whenever an event occurs, a producer thread creates an event object and
// adds it to the event buffer. Concurrently, consumer threads take events out
// of the buffer and process them. In this case, the consumers are called
// "event handlers."
//
// There are several synchronization constraints that we need to enforce to
// make this system work correctly:
//
// • While an item is being added to or removed from the buffer, the buffer is
//   in an inconsistent state. Therefore, threads must have exclusive access to
//   the buffer.
//
// • If a consumer thread arrives while the buffer is empty, it blocks until a
//   producer adds a new item.
//
// Assume that producers perform the following operations:
//
//   event = waitForEvent()
//   buffer.add(event)
//
// And consumers perform:
//
//   event = buffer.get()
//   event.process()
//
// Puzzle: Add synchronization statements to enforce the synchronization
// constraints.
//
// =============================================================================
// SOLUTION (Infinite Buffer)
// =============================================================================
//
// Variables:
//   mutex = Semaphore(1)   // Protects buffer access
//   items = Semaphore(0)   // Tracks number of items in buffer
//
// Producer code:
//   event = waitForEvent()
//   mutex.wait()
//     buffer.add(event)
//     items.signal()
//   mutex.signal()
//
// Consumer code:
//   items.wait()
//   mutex.wait()
//     event = buffer.get()
//   mutex.signal()
//   event.process()
//
// The items semaphore keeps track of the number of items in the buffer.
// Each time the producer adds an item, it signals items, incrementing it by
// one. The consumer code is similar.
//
// Again, the buffer operation is protected by a mutex, but before the
// consumer gets to it, it has to decrement items. If items is zero or
// negative, the consumer blocks until a producer signals.
//
// =============================================================================
// DEADLOCK #4: Broken Consumer Solution
// =============================================================================
//
// This broken solution can deadlock:
//
//   mutex.wait()
//   items.wait()
//   event = buffer.get()
//   mutex.signal()
//   event.process()
//
// If the consumer is running this code, it can cause a deadlock. Imagine that
// the buffer is empty. A consumer arrives, gets the mutex, and then blocks on
// items. When the producer arrives, it blocks on mutex and the system comes to
// a grinding halt.
//
// This is a common error in synchronization code: any time you wait for a
// semaphore while holding a mutex, there is a danger of deadlock. When you are
// checking a solution to a synchronization problem, you should check for this
// kind of deadlock.
//
// =============================================================================
// FINITE BUFFER EXTENSION
// =============================================================================
//
// In the example above, the shared buffer is usually infinite (unbounded).
// In the kernel of the operating system, though, there are limits on available
// space. Buffers for things like disk requests and network packets are usually
// fixed size. In situations like these, we have an additional synchronization
// constraint:
//
// • If a producer arrives when the buffer is full, it blocks until a consumer
//   removes an item.
//
// Assume that we know the size of the buffer. Call it bufferSize.
//
// Variables:
//   mutex = Semaphore(1)
//   items = Semaphore(0)
//   spaces = Semaphore(bufferSize)
//
// When a consumer removes an item it should signal spaces. When a producer
// arrives it should decrement spaces, at which point it might block until the
// next consumer signals.
//
// =============================================================================
// SPECL MODEL (FINITE BUFFER)
// =============================================================================

module ProducerConsumer
// Use: -c NUM_PRODUCERS=1 -c NUM_CONSUMERS=1 -c BUFFER_SIZE=2

const NUM_PRODUCERS: 0..3
const NUM_CONSUMERS: 0..3
const BUFFER_SIZE: 0..5

// Producer states: 0=not_started, 1=has_event, 2=waiting_mutex, 3=adding, 4=releasing, 5=done
var producers: Dict[Int, 0..5]

// Consumer states: 0=waiting_item, 1=waiting_mutex, 2=getting, 3=releasing, 4=done
var consumers: Dict[Int, 0..4]

// Buffer (modeled as item count for simplicity)
var buffer_count: 0..5

// Semaphores
var mutex: 0..1
var items: 0..5
var spaces: 0..5

init {
    producers = {i: 0 for i in 0..NUM_PRODUCERS} and
    consumers = {i: 0 for i in 0..NUM_CONSUMERS} and
    buffer_count = 0 and
    mutex = 1 and
    items = 0 and
    spaces = BUFFER_SIZE;
}

// === Producer actions ===

action Producer_Start(i: 0..NUM_PRODUCERS) {
    require producers[i] == 0;
    producers = producers | {i: 1};
}

action Producer_WaitSpace(i: 0..NUM_PRODUCERS) {
    require producers[i] == 1;
    require spaces > 0;
    spaces = spaces - 1 and
    producers = producers | {i: 2};
}

action Producer_GetMutex(i: 0..NUM_PRODUCERS) {
    require producers[i] == 2;
    require mutex == 1;
    mutex = 0 and
    producers = producers | {i: 3};
}

action Producer_Add(i: 0..NUM_PRODUCERS) {
    require producers[i] == 3;
    require buffer_count < BUFFER_SIZE;
    buffer_count = buffer_count + 1 and
    items = items + 1 and
    producers = producers | {i: 4};
}

action Producer_ReleaseMutex(i: 0..NUM_PRODUCERS) {
    require producers[i] == 4;
    require mutex == 0;
    mutex = 1 and
    producers = producers | {i: 5};
}

// === Consumer actions ===

action Consumer_WaitItem(i: 0..NUM_CONSUMERS) {
    require consumers[i] == 0;
    require items > 0;
    items = items - 1 and
    consumers = consumers | {i: 1};
}

action Consumer_GetMutex(i: 0..NUM_CONSUMERS) {
    require consumers[i] == 1;
    require mutex == 1;
    mutex = 0 and
    consumers = consumers | {i: 2};
}

action Consumer_Get(i: 0..NUM_CONSUMERS) {
    require consumers[i] == 2;
    require buffer_count > 0;
    buffer_count = buffer_count - 1 and
    spaces = spaces + 1 and
    consumers = consumers | {i: 3};
}

action Consumer_ReleaseMutex(i: 0..NUM_CONSUMERS) {
    require consumers[i] == 3;
    require mutex == 0;
    mutex = 1 and
    consumers = consumers | {i: 4};
}

// === Safety invariants ===

invariant MutexBinary {
    mutex <= 1
}

invariant BufferCapacity {
    buffer_count <= BUFFER_SIZE
}

invariant ItemsMatchBuffer {
    // items + spaces should equal BUFFER_SIZE + items consumed - items produced
    // Simplified: items semaphore tracks items in buffer
    items <= buffer_count
}

invariant SpacesBound {
    spaces <= BUFFER_SIZE
}

invariant BufferBounds {
    // Buffer count is within valid range
    buffer_count >= 0 and buffer_count <= BUFFER_SIZE
}

invariant NoNegativeBuffer {
    buffer_count >= 0
}

invariant Conservation {
    // items + spaces should equal BUFFER_SIZE (plus in-flight adjustments)
    items + spaces <= BUFFER_SIZE + 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check producer_consumer.specl -c NUM_PRODUCERS=2 -c NUM_CONSUMERS=2 -c BUFFER_SIZE=3 --no-deadlock
//      (2 producers, 2 consumers, buffer size 3)
//
// Run: specl check producer_consumer.specl -c NUM_PRODUCERS=1 -c NUM_CONSUMERS=1 -c BUFFER_SIZE=1 --no-deadlock
//      (minimal: 1 producer, 1 consumer, buffer size 1)
//
// Expected: OK with all invariants holding
//
// The model verifies that:
// 1. Mutex provides exclusive access to the buffer
// 2. Consumers block when buffer is empty (items semaphore)
// 3. Producers block when buffer is full (spaces semaphore)
// 4. Buffer count never exceeds capacity
// 5. The solution avoids Deadlock #4 (waiting for items BEFORE getting mutex)
//
// Key insight: The order of waits matters! Consumers must wait on `items`
// BEFORE acquiring the mutex, otherwise they can deadlock. The items semaphore
// acts as a signaling mechanism that prevents consumers from blocking while
// holding the mutex.
//
// The finite buffer variant uses a "spaces" semaphore initialized to
// bufferSize. Producers decrement spaces (blocking if full), consumers
// increment spaces. The invariant items + spaces = bufferSize holds
// (modulo in-flight operations).
//
// Common mistake: Checking buffer state with `if items >= bufferSize: block()`
// doesn't work - semaphores don't support value inspection, only wait/signal.
// =============================================================================
