module TicketLock

// Ticket lock: FIFO mutual exclusion.
// Each thread takes a ticket number and waits until the serving
// counter matches its ticket. Guarantees strict FIFO ordering.
//
// Use: specl check ticket-lock.specl -c N=3 --no-deadlock --no-auto --bfs
// Verified: N=3 -> OK (22.5K states, 0.0s)

const N: 0..4

// Shared state
var next_ticket: 0..10    // next ticket to dispense
var serving: 0..10        // currently serving ticket

// Per-thread state: 0=idle, 1=waiting, 2=in_cs
var pc: Dict[0..N, 0..2]

// Each thread's ticket
var ticket: Dict[0..N, 0..10]

init {
    next_ticket = 0;
    serving = 0;
    pc = {t: 0 for t in 0..N};
    ticket = {t: 0 for t in 0..N};
}

// Thread t takes a ticket (atomic fetch-and-increment)
action TakeTicket(t: 0..N) {
    require pc[t] == 0;
    require next_ticket < 10;
    ticket = ticket | {t: next_ticket};
    next_ticket = next_ticket + 1;
    pc = pc | {t: 1};
}

// Thread t enters CS when its ticket matches serving
action Enter(t: 0..N) {
    require pc[t] == 1;
    require ticket[t] == serving;
    pc = pc | {t: 2};
}

// Thread t exits CS and increments serving
action Exit(t: 0..N) {
    require pc[t] == 2;
    serving = serving + 1;
    pc = pc | {t: 0};
}

// Mutual exclusion
invariant MutualExclusion {
    all i in 0..N: all j in 0..N:
        (i != j) implies not (pc[i] == 2 and pc[j] == 2)
}

// Serving counter consistency: serving <= next_ticket
invariant ServingBound {
    serving <= next_ticket
}
