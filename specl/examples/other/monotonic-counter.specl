module MonotonicCounter

// Distributed Monotonic Counter (similar to G-Counter but tracks ordering).
// N+1 nodes each maintain a local counter. The global value is the sum.
// Counters are monotonically increasing — they never decrease.
// Nodes can increment locally and sync pairwise.
//
// Use: specl check monotonic-counter.specl -c N=2 -c MaxVal=2 --no-deadlock --no-auto --bfs
// Verified: N=2 MaxVal=2 -> OK (2.6K states)

const N: 0..3
const MaxVal: 1..4

var counter: Dict[0..N, Dict[0..N, 0..MaxVal]]

init {
    counter = {r: {s: 0 for s in 0..N} for r in 0..N};
}

// Replica r increments its own slot
action Increment(r: 0..N) {
    require counter[r][r] < MaxVal;
    counter = counter | {r: counter[r] | {r: counter[r][r] + 1}};
}

// Replica dst syncs from replica src: take max per slot
action Sync(src: 0..N, dst: 0..N) {
    require src != dst;
    counter = counter | {dst: {s:
        if counter[src][s] > counter[dst][s] then counter[src][s]
        else counter[dst][s]
    for s in 0..N}}
}

// Monotonicity: local view of any slot never decreases
// (enforced by construction — increment only adds, sync takes max)
invariant MonotonicSlots {
    all r in 0..N: all s in 0..N: counter[r][s] >= 0
}

// After full sync, all replicas agree on the value
invariant ConvergedAgreement {
    (all i in 0..N: all j in 0..N: all s in 0..N:
        counter[i][s] == counter[j][s])
    implies
    (all i in 0..N: all j in 0..N:
        counter[i][0] + counter[i][1] + counter[i][2] ==
        counter[j][0] + counter[j][1] + counter[j][2]
        or N < 2)
}
