module EPaxos

// Egalitarian Paxos (EPaxos) - core consensus with fast/slow paths
// From: Moraru, Andersen & Kaminsky, "There Is More Consensus in
//       Egalitarian Parliaments" (SOSP 2013)
// R+1 replicas (0..R), each owns instances in its column.
// MaxInst+1 instances per replica (0..MaxInst).
// Commands 0..Cmd. All commands interfere (conservative).
// Simplified: no recovery/prepare phase, crash-free.
// Use: specl check epaxos.specl -c R=2 -c MaxInst=1 -c Cmd=1 --no-deadlock
// Verified: R=2 MaxInst=0 Cmd=0 -> 756,663 states, Nontriviality + CommittedVisibility OK

const R: Int
const MaxInst: Int
const Cmd: Int

// Instance status: 0=none, 1=preaccepted, 2=accepted, 3=committed
var instCmd: Dict[Int, Dict[Int, Int]]
var instDeps: Dict[Int, Dict[Int, Dict[Int, Dict[Int, Bool]]]]
var instSeq: Dict[Int, Dict[Int, Int]]
var instStatus: Dict[Int, Dict[Int, Int]]

// Next instance counter per replica
var crtInst: Dict[Int, Int]

// Pre-accept reply tracking per (owner, slot, replica)
var preAcceptReplied: Dict[Int, Dict[Int, Dict[Int, Bool]]]
var preAcceptAgreed: Dict[Int, Dict[Int, Dict[Int, Bool]]]

// Accept reply tracking
var acceptReplied: Dict[Int, Dict[Int, Dict[Int, Bool]]]

func FastQuorum() {
    (3 * (R + 1)) / 4 + 1
}

func SlowQuorum() {
    (R + 1) / 2 + 1
}

init {
    instCmd = {o: {s: -1 for s in 0..MaxInst} for o in 0..R}
    and instDeps = {o: {s: {do2: {ds: false for ds in 0..MaxInst} for do2 in 0..R} for s in 0..MaxInst} for o in 0..R}
    and instSeq = {o: {s: 0 for s in 0..MaxInst} for o in 0..R}
    and instStatus = {o: {s: 0 for s in 0..MaxInst} for o in 0..R}
    and crtInst = {o: 0 for o in 0..R}
    and preAcceptReplied = {o: {s: {r: false for r in 0..R} for s in 0..MaxInst} for o in 0..R}
    and preAcceptAgreed = {o: {s: {r: false for r in 0..R} for s in 0..MaxInst} for o in 0..R}
    and acceptReplied = {o: {s: {r: false for r in 0..R} for s in 0..MaxInst} for o in 0..R}
}

// Leader proposes a command for its next instance slot
// Uses slot parameter and requires it equals crtInst for the leader
action Propose(leader: 0..R, slot: 0..MaxInst, cmd: 0..Cmd) {
    require crtInst[leader] == slot
    require instStatus[leader][slot] == 0
    instCmd = instCmd | {leader: (instCmd[leader] | {slot: cmd})}
    and instDeps = instDeps | {leader: (instDeps[leader] | {slot:
        {do2: {ds: (instStatus[do2][ds] != 0 and not (do2 == leader and ds == slot))
            for ds in 0..MaxInst} for do2 in 0..R}})}
    and instSeq = instSeq | {leader: (instSeq[leader] | {slot: 1})}
    and instStatus = instStatus | {leader: (instStatus[leader] | {slot: 1})}
    and crtInst = crtInst | {leader: slot + 1}
    and preAcceptReplied = preAcceptReplied | {leader: (preAcceptReplied[leader] | {slot: (preAcceptReplied[leader][slot] | {leader: true})})}
    and preAcceptAgreed = preAcceptAgreed | {leader: (preAcceptAgreed[leader] | {slot: (preAcceptAgreed[leader][slot] | {leader: true})})}
}

// Replica responds to pre-accept
action PreAcceptReply(replica: 0..R, owner: 0..R, slot: 0..MaxInst) {
    require replica != owner
    require instStatus[owner][slot] == 1
    require not preAcceptReplied[owner][slot][replica]
    // Check if replica knows of extra conflicts not in leader's deps
    preAcceptReplied = preAcceptReplied | {owner: (preAcceptReplied[owner] | {slot: (preAcceptReplied[owner][slot] | {replica: true})})}
    and preAcceptAgreed = preAcceptAgreed | {owner: (preAcceptAgreed[owner] | {slot: (preAcceptAgreed[owner][slot] | {replica:
        not (any do2 in 0..R: any ds in 0..MaxInst:
            instStatus[do2][ds] != 0 and not (do2 == owner and ds == slot)
            and not instDeps[owner][slot][do2][ds])})})}
}

// Fast path commit: all in fast quorum agreed on deps
action FastPathCommit(owner: 0..R, slot: 0..MaxInst) {
    require instStatus[owner][slot] == 1
    require len({r in 0..R if preAcceptAgreed[owner][slot][r]}) >= FastQuorum()
    instStatus = instStatus | {owner: (instStatus[owner] | {slot: 3})}
}

// Slow path: deps disagreed, leader merges and enters accept phase
action StartSlowPath(owner: 0..R, slot: 0..MaxInst) {
    require instStatus[owner][slot] == 1
    require len({r in 0..R if preAcceptReplied[owner][slot][r]}) >= SlowQuorum()
    require len({r in 0..R if preAcceptAgreed[owner][slot][r]}) < FastQuorum()
    // Merge deps: add all known conflicts
    instDeps = instDeps | {owner: (instDeps[owner] | {slot:
        {do2: {ds: (instDeps[owner][slot][do2][ds]
            or (instStatus[do2][ds] != 0 and not (do2 == owner and ds == slot)))
            for ds in 0..MaxInst} for do2 in 0..R}})}
    and instStatus = instStatus | {owner: (instStatus[owner] | {slot: 2})}
}

// Replica responds to accept
action AcceptReply(replica: 0..R, owner: 0..R, slot: 0..MaxInst) {
    require replica != owner
    require instStatus[owner][slot] == 2
    require not acceptReplied[owner][slot][replica]
    acceptReplied = acceptReplied | {owner: (acceptReplied[owner] | {slot: (acceptReplied[owner][slot] | {replica: true})})}
}

// Slow path commit: majority accepted
action SlowPathCommit(owner: 0..R, slot: 0..MaxInst) {
    require instStatus[owner][slot] == 2
    require len({r in 0..R if acceptReplied[owner][slot][r]}) + 1 >= SlowQuorum()
    instStatus = instStatus | {owner: (instStatus[owner] | {slot: 3})}
}

// No committed instance has empty command
invariant Nontriviality {
    all o in 0..R: all s in 0..MaxInst:
        instStatus[o][s] == 3 implies instCmd[o][s] != -1
}

// For any two committed instances, at least one is in the other's deps
invariant CommittedVisibility {
    all o1 in 0..R: all s1 in 0..MaxInst: all o2 in 0..R: all s2 in 0..MaxInst:
        (instStatus[o1][s1] == 3 and instStatus[o2][s2] == 3
         and not (o1 == o2 and s1 == s2)
         and instCmd[o1][s1] != -1 and instCmd[o2][s2] != -1)
        implies (instDeps[o1][s1][o2][s2] or instDeps[o2][s2][o1][s1])
}
