module ChandyMisra

// Chandy-Misra solution to the Dining Philosophers problem.
// N+1 philosophers sit around a table. Each fork starts dirty and held
// by the lower-numbered philosopher. A philosopher can eat only when
// holding both adjacent forks. After eating, forks become dirty.
// When a neighbor requests a fork, a dirty fork must be given up (cleaned).
// This prevents deadlock and starvation.
//
// Use: specl check chandy-misra.specl -c N=3 --no-deadlock --no-auto --bfs
// Verified: N=3 -> OK (17.7K states, 0.0s)

const N: 1..5

// Fork ownership: fork[i] is held by philosopher i's "left" holder
// fork[i] sits between philosopher i and (i+1)%N
// holder[i] = the philosopher who holds fork i (i or right neighbor)
var holder: Dict[0..N, 0..N]

// Fork state: true = dirty, false = clean
var dirty: Dict[0..N, Bool]

// Request flags: req[i] = true if the neighbor who doesn't hold fork i wants it
var req: Dict[0..N, Bool]

// Philosopher state: 0=thinking, 1=hungry, 2=eating
var state: Dict[0..N, 0..2]

func Right(i) {
    if i == 0 then N else i - 1
}

init {
    // Lower-numbered philosopher holds each fork, initially dirty
    holder = {i: i for i in 0..N};
    dirty = {i: true for i in 0..N};
    req = {i: false for i in 0..N};
    state = {i: 0 for i in 0..N};
}

// Philosopher p becomes hungry
action BecomeHungry(p: 0..N) {
    require state[p] == 0;
    state = state | {p: 1};
}

// Philosopher p requests their left fork (fork p)
// Only if they don't hold it and haven't already requested
action RequestLeft(p: 0..N) {
    require state[p] == 1;
    require holder[p] != p;
    require req[p] == false;
    req = req | {p: true};
}

// Philosopher p requests their right fork (fork Right(p))
// The right fork of p is fork Right(p), held by the right neighbor
action RequestRight(p: 0..N, r: 0..N) {
    require state[p] == 1;
    require (p == 0 and r == N) or (p > 0 and r == p - 1);
    require holder[r] != p;
    require req[r] == false;
    req = req | {r: true};
}

// Philosopher p gives up fork f (they hold it, it's dirty, someone requested)
action GiveFork(p: 0..N, f: 0..N) {
    require state[p] != 2;
    require holder[f] == p;
    require dirty[f] == true;
    require req[f] == true;
    // The other philosopher adjacent to fork f gets it (clean)
    // Fork f is between philosopher f and Right(f)
    // So the "other" is the one who isn't p
    require (f == p) or ((p == 0 and f == N) or (p > 0 and f == p - 1));
    holder = holder | {f: (if f == p then (if p < N then p + 1 else 0) else f)};
    dirty = dirty | {f: false};
    req = req | {f: false};
}

// Philosopher p eats (holds both adjacent forks)
action Eat(p: 0..N, r: 0..N) {
    require state[p] == 1;
    require (p == 0 and r == N) or (p > 0 and r == p - 1);
    // Holds left fork (fork p) and right fork (fork Right(p) = fork r)
    require holder[p] == p;
    require holder[r] == p;
    state = state | {p: 2};
}

// Philosopher p finishes eating (forks become dirty)
action StopEating(p: 0..N, r: 0..N) {
    require state[p] == 2;
    require (p == 0 and r == N) or (p > 0 and r == p - 1);
    dirty = dirty | {p: true, r: true};
    state = state | {p: 0};
}

// Mutual exclusion: no two adjacent philosophers eat simultaneously
invariant MutualExclusion {
    all p in 0..N: all q in 0..N:
        (p != q and (q == (if p < N then p + 1 else 0) or p == (if q < N then q + 1 else 0)))
        implies not (state[p] == 2 and state[q] == 2)
}
