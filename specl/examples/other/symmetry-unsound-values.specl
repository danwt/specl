// Test spec: Dict[0..N, 0..N] where mapping[i] == i creates identity-dependent semantics.
// Symmetry reduction is UNSOUND here because canonicalization only permutes Dict keys,
// not values. The invariant requires values to track their keys, which breaks under permutation.

module SymmetryUnsoundValues

var mapping: Dict[0..2, 0..2]

init {
    mapping = {i: i for i in 0..2}
}

action Swap(i: 0..2, j: 0..2) {
    require i != j
    require mapping[i] == i and mapping[j] == j
    mapping = mapping | { i: j, j: i }
}

// This invariant depends on value identity: mapping[i] == i for unswapped elements.
// Symmetry would incorrectly identify distinct states as equivalent.
invariant Identity {
    all i in 0..2: mapping[i] == i or (any j in 0..2: j != i and mapping[i] == j and mapping[j] == i)
}
