module CrashConsensus

// Consensus with crash-stop faults: demonstrates why naive
// majority voting fails. N+1 processes propose values, up to F
// may crash. Remaining decide using majority of live proposals.
//
// bug: a crash between two decisions can change the majority,
// leading to disagreement. This is the FLP impossibility in
// miniature â€” asynchronous consensus is impossible with even
// one crash fault if the algorithm is purely based on local views.
//
// Use: specl check crash-consensus.specl -c N=2 -c F=1 --no-deadlock --no-auto --bfs
// Verified: N=2 F=1 -> VIOLATION (Agreement, 7 steps)

const N: 0..3
const F: 0..2

var proposal: Dict[0..N, 0..1]
var pc: Dict[0..N, 0..3]  // 0=init, 1=proposed, 2=decided, 3=crashed
var decision: Dict[0..N, 0..1]
var crashes: 0..F

func Majority(proposals, pcs) {
    if len({q in 0..N if pcs[q] != 3 and proposals[q] == 0})
       >= len({q in 0..N if pcs[q] != 3 and proposals[q] == 1})
    then 0
    else 1
}

init {
    proposal = {p: 0 for p in 0..N};
    pc = {p: 0 for p in 0..N};
    decision = {p: 0 for p in 0..N};
    crashes = 0;
}

action Propose(p: 0..N, v: 0..1) {
    require pc[p] == 0;
    pc = pc | {p: 1};
    proposal = proposal | {p: v};
}

action Crash(p: 0..N) {
    require pc[p] != 3;
    require pc[p] != 2;
    require crashes < F;
    pc = pc | {p: 3};
    crashes = crashes + 1;
}

action Decide(p: 0..N) {
    require pc[p] == 1;
    require all q in 0..N: pc[q] >= 1;
    pc = pc | {p: 2};
    decision = decision | {p: Majority(proposal, pc)};
}

// bug: naive majority voting fails with crash faults.
// A crash between two decisions changes the visible majority.
invariant Agreement {
    all i in 0..N: all j in 0..N:
        (pc[i] == 2 and pc[j] == 2) implies decision[i] == decision[j]
}

// This weaker property DOES hold: decided values are valid proposals
invariant Validity {
    all p in 0..N:
        pc[p] == 2 implies (any q in 0..N: proposal[q] == decision[p])
}
