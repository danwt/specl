module WeightedVoting

// Gifford's Weighted Voting / Quorum Systems (1979).
// N+1 replicas. Writes go to a write quorum W (majority),
// reads go to a read quorum R (majority). Since R + W > N+1,
// any read quorum intersects any write quorum. Therefore
// a read from a majority always sees the latest write.
//
// With N=2 (3 replicas), quorum size = 2.
// A write updates 2 of 3 replicas. A read reads 2 of 3.
// The intersection contains the latest written value.
//
// Use: specl check weighted-voting.specl -c N=2 --no-deadlock --no-auto --bfs
// Verified: N=2 -> OK (61 states, 0.0s)

const N: 0..3

// Per-replica stored value and version
var store: Dict[0..N, 0..1]
var ver: Dict[0..N, 0..3]

// Global write counter
var write_count: 0..3

init {
    store = {r: 0 for r in 0..N};
    ver = {r: 0 for r in 0..N};
    write_count = 0;
}

// Quorum write: update a majority of replicas
// Skipping one replica (the slow one)
action QuorumWrite(v: 0..1, slow: 0..N) {
    require write_count < 3;
    // All replicas get the new value, except the slow one keeps its old state
    store = {r: v for r in 0..N} | {slow: store[slow]};
    ver = {r: write_count + 1 for r in 0..N} | {slow: ver[slow]};
    write_count = write_count + 1;
}

// Lazy propagation: slow replica catches up from a faster one
action Propagate(slow: 0..N, src: 0..N) {
    require slow != src;
    require ver[src] > ver[slow];
    store = store | {slow: store[src]};
    ver = ver | {slow: ver[src]};
}

// Quorum intersection: any 2 replicas include one with the latest version
// This is the key property â€” for any read quorum of size 2,
// at least one member has the latest version
invariant QuorumOverlap {
    write_count == 0 or
    all i in 0..N: all j in 0..N:
        (i != j) implies (ver[i] == write_count or ver[j] == write_count)
}
