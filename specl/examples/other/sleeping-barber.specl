module SleepingBarber

// Sleeping Barber problem (Dijkstra, 1965).
// One barber, N+1 customers, W waiting chairs.
// Barber sleeps when no customers. Arriving customer wakes barber
// or sits in waiting room. If waiting room full, customer leaves.
//
// Use: specl check sleeping-barber.specl -c N=2 -c W=2 --no-deadlock --no-auto --bfs
// Verified: N=2 W=2 -> OK (67 states, 0.0s)

const N: 0..3
const W: 1..3

// Barber state: 0=sleeping, 1=cutting
var barber: 0..1

// Customer in the chair (N+1 = nobody)
var in_chair: 0..N
var chair_occupied: Bool

// Waiting room: count of waiting customers
var waiting: 0..W

// Per-customer state: 0=outside, 1=waiting, 2=in_chair, 3=done, 4=left (room full)
var cust_pc: Dict[0..N, 0..4]

init {
    barber = 0;
    in_chair = 0;
    chair_occupied = false;
    waiting = 0;
    cust_pc = {c: 0 for c in 0..N};
}

// Customer arrives and barber is sleeping: wake barber, sit in chair
action ArriveWakeBarber(c: 0..N) {
    require cust_pc[c] == 0;
    require barber == 0;
    require chair_occupied == false;
    cust_pc = cust_pc | {c: 2};
    in_chair = c;
    chair_occupied = true;
    barber = 1;
}

// Customer arrives and barber is busy: sit in waiting room
action ArriveWait(c: 0..N) {
    require cust_pc[c] == 0;
    require barber == 1;
    require waiting < W;
    cust_pc = cust_pc | {c: 1};
    waiting = waiting + 1;
}

// Customer arrives but waiting room is full: leave
action ArriveLeave(c: 0..N) {
    require cust_pc[c] == 0;
    require barber == 1;
    require waiting == W;
    cust_pc = cust_pc | {c: 4};
}

// Barber finishes cutting: customer done
action FinishCut() {
    require barber == 1;
    require chair_occupied == true;
    cust_pc = cust_pc | {in_chair: 3};
    chair_occupied = false;
}

// Next waiting customer moves to chair
action NextCustomer(c: 0..N) {
    require barber == 1;
    require chair_occupied == false;
    require waiting > 0;
    require cust_pc[c] == 1;
    cust_pc = cust_pc | {c: 2};
    in_chair = c;
    chair_occupied = true;
    waiting = waiting - 1;
}

// Barber goes to sleep when no one is waiting and chair empty
action BarberSleep() {
    require barber == 1;
    require chair_occupied == false;
    require waiting == 0;
    barber = 0;
}

// At most one customer in the barber chair
invariant OneInChair {
    // Count customers with state 2 (in_chair)
    len({c in 0..N if cust_pc[c] == 2}) <= 1
}

// Waiting count matches actual waiting customers
invariant WaitingConsistency {
    waiting == len({c in 0..N if cust_pc[c] == 1})
}
