// =============================================================================
// Readers-Writers Problem (Writer Priority Solution)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 4.2: Readers-Writers Problem (pages 65-77)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// This problem is also widely known, at least among computer scientists. The
// problem is that there is a shared resource, like a database or file, that
// can be accessed by multiple readers, or by a single writer, but not both.
//
// Assume that threads can access the database by invoking the following
// methods:
//
//   def read_data():
//       # Access the database for reading
//
//   def write_data():
//       # Access the database for writing
//
// Your job is to write a synchronization solution that enforces the following
// constraints:
//
// • Any number of readers can be in the critical section simultaneously.
// • Writers must have exclusive access to the critical section.
// • Writers must have priority: once a writer arrives, no NEW readers should
//   be allowed to start reading (though readers already in the critical section
//   may finish).
//
// The first two constraints are fairly straightforward, and the third is more
// subtle. The danger is reader starvation: if readers arrive frequently enough,
// a writer might wait forever. The "writer priority" constraint prevents this.
//
// =============================================================================
// SOLUTION #3: Writer Priority (No Starvation)
// =============================================================================
//
// The writer-priority solution uses three semaphores and a counter:
//
//   readers = 0              # Count of active readers
//   mutex = Semaphore(1)     # Protects 'readers' counter
//   roomEmpty = Semaphore(1) # Ensures writers get exclusive access
//   turnstile = Semaphore(1) # Gives writers priority
//
// Reader code:
//   turnstile.wait()         # Check if writer is waiting
//   turnstile.signal()       # Let other readers through
//
//   mutex.wait()
//   readers += 1
//   if readers == 1:
//       roomEmpty.wait()     # First reader locks out writers
//   mutex.signal()
//
//   read_data()
//
//   mutex.wait()
//   readers -= 1
//   if readers == 0:
//       roomEmpty.signal()   # Last reader unlocks for writers
//   mutex.signal()
//
// Writer code:
//   turnstile.wait()         # Lock the turnstile
//   roomEmpty.wait()         # Wait for room to be empty
//
//   write_data()
//
//   turnstile.signal()       # Unlock turnstile
//   roomEmpty.signal()       # Release room
//
// Key insight: When a writer arrives, it locks the turnstile. This prevents
// NEW readers from entering (they block at turnstile.wait()). Readers already
// in the room can finish. When the last reader leaves, the writer enters.
// This gives writers priority and prevents writer starvation.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module ReadersWriters
// Use: -c NUM_READERS=2 -c NUM_WRITERS=1

const NUM_READERS: 0..5
const NUM_WRITERS: 0..5

// Reader states: 0=thinking, 1=passed_turnstile, 2=reading
var readers: Dict[Int, 0..2]

// Writer states: 0=thinking, 1=acquiring_turnstile, 2=acquiring_room, 3=writing
var writers: Dict[Int, 0..3]

// Shared state
var readers_count: 0..5
var mutex: 0..1
var roomEmpty: 0..1
var turnstile: 0..1

init {
    readers = {i: 0 for i in 0..NUM_READERS} and
    writers = {i: 0 for i in 0..NUM_WRITERS} and
    readers_count = 0 and
    mutex = 1 and
    roomEmpty = 1 and
    turnstile = 1
}

// === Reader actions ===

// Turnstile: pass through (atomic wait+signal)
action Reader_PassTurnstile(i: 0..NUM_READERS) {
    require readers[i] == 0
    require turnstile > 0
    readers = readers | {i: 1}
}

// Lightswitch lock (first reader): acquire room
action Reader_EnterFirst(i: 0..NUM_READERS) {
    require readers[i] == 1
    require mutex > 0
    require readers_count == 0
    require roomEmpty > 0
    readers_count = 1 and
    roomEmpty = roomEmpty - 1 and
    readers = readers | {i: 2}
}

// Lightswitch lock (not first reader)
action Reader_EnterNotFirst(i: 0..NUM_READERS) {
    require readers[i] == 1
    require mutex > 0
    require readers_count > 0
    readers_count = readers_count + 1 and
    readers = readers | {i: 2}
}

// Lightswitch unlock (last reader): release room
action Reader_ExitLast(i: 0..NUM_READERS) {
    require readers[i] == 2
    require mutex > 0
    require readers_count == 1
    readers_count = 0 and
    roomEmpty = roomEmpty + 1 and
    readers = readers | {i: 0}
}

// Lightswitch unlock (not last reader)
action Reader_ExitNotLast(i: 0..NUM_READERS) {
    require readers[i] == 2
    require mutex > 0
    require readers_count > 1
    readers_count = readers_count - 1 and
    readers = readers | {i: 0}
}

// === Writer actions ===

action Writer_AcquireTurnstile(i: 0..NUM_WRITERS) {
    require writers[i] == 0
    require turnstile > 0
    turnstile = turnstile - 1 and
    writers = writers | {i: 1}
}

action Writer_AcquireRoom(i: 0..NUM_WRITERS) {
    require writers[i] == 1
    require roomEmpty > 0
    roomEmpty = roomEmpty - 1 and
    writers = writers | {i: 2}
}

action Writer_Write(i: 0..NUM_WRITERS) {
    require writers[i] == 2
    writers = writers | {i: 3}
}

action Writer_Release(i: 0..NUM_WRITERS) {
    require writers[i] == 3
    turnstile = turnstile + 1 and
    roomEmpty = roomEmpty + 1 and
    writers = writers | {i: 0}
}

// === Safety invariants ===

invariant MutualExclusion {
    // Cannot have active readers and active writers simultaneously
    let reading = len({i in 0..NUM_READERS if readers[i] == 2}) in
    let writing = len({i in 0..NUM_WRITERS if writers[i] >= 2 and writers[i] <= 3}) in
    not (reading > 0 and writing > 0)
}

invariant ExclusiveWriter {
    // At most one writer in critical section
    let writing = len({i in 0..NUM_WRITERS if writers[i] >= 2 and writers[i] <= 3}) in
    writing <= 1
}

invariant SemaphoreBounds {
    mutex <= 1 and roomEmpty <= 1 and turnstile <= 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check readers_writers.specl -c NUM_READERS=2 -c NUM_WRITERS=2
//      (2 readers, 2 writers - medium state space)
//
// Run: specl check readers_writers.specl -c NUM_READERS=3 -c NUM_WRITERS=2 --fast
//      (3 readers, 2 writers - larger state space, use fingerprinting)
//
// Expected: OK with no violations
//
// The model verifies that:
// 1. Readers and writers never access the database simultaneously (MutualExclusion)
// 2. At most one writer can write at a time (ExclusiveWriter)
// 3. Multiple readers can read concurrently
// 4. Writers get priority via the turnstile mechanism (prevents reader starvation)
//
// Key insight: The turnstile acts as a gate. When a writer arrives, it closes
// the gate (locks turnstile), preventing new readers from entering. Readers
// already inside can finish. When the last reader leaves, the writer enters.
// This guarantees writer priority and prevents writer starvation.
//
// Alternative solutions in the book:
// - Solution #1: No writer priority (writers can starve)
// - Solution #2: No reader priority (readers can starve)
// - Solution #3 (THIS ONE): Writer priority (balanced fairness)
// =============================================================================
