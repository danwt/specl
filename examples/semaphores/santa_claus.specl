// =============================================================================
// Santa Claus Problem
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 5.5: Santa Claus Problem (pages 137-145)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// Stand Claus sleeps in his shop at the North Pole and can only be awakened
// by either (1) all nine reindeer being back from their vacation in the South
// Pacific, or (2) some of the elves having difficulty making toys; to allow
// Santa to get some sleep, the elves can only wake him when three of them have
// problems. When three elves are having their problems solved, any other elves
// wishing to visit Santa must wait for those elves to return. If Santa wakes
// up to find three elves waiting at his shop's door, along with the last
// reindeer having come back from the tropics, Santa has decided that the
// elves can wait until after Christmas, because it is more important to get
// his sleigh ready. (It is assumed that the reindeer do not want to leave the
// tropics, and therefore they stay there until the last possible moment.)
// The last reindeer to arrive must get Santa while the others wait in a
// warming hut before being harnessed to the sleigh.
//
// Constraints:
// • Santa sleeps unless awakened by either all 9 reindeer or 3 elves
// • If awakened by reindeer, Santa harnesses the sleigh (reindeer take priority)
// • If awakened by elves, Santa helps exactly 3 elves, then goes back to sleep
// • Elves must wait if Santa is already helping other elves
// • When the 9th reindeer arrives, it must wake Santa
//
// =============================================================================
// SOLUTION
// =============================================================================
//
// Variables:
//   elves = 0
//   reindeer = 0
//   santaSem = Semaphore(0)
//   reindeerSem = Semaphore(0)
//   elfTex = Semaphore(1)        # Elf mutex
//   elf0, elf1, elf2 = Semaphore(0)
//   mutex = Semaphore(1)
//
// Santa:
//   while True:
//       santaSem.wait()
//       mutex.wait()
//       if reindeer >= 9:
//           prepareSleigh()
//           reindeerSem.signal(9)    # Wake all 9 reindeer
//           reindeer = 0
//       elif elves == 3:
//           helpElves()
//       mutex.signal()
//
// Reindeer:
//   mutex.wait()
//   reindeer += 1
//   if reindeer == 9:
//       santaSem.signal()
//   mutex.signal()
//   reindeerSem.wait()
//   getHarnessed()
//
// Elf:
//   elfTex.wait()
//   mutex.wait()
//   elves += 1
//   if elves == 3:
//       santaSem.signal()
//   else:
//       elfTex.signal()
//   mutex.signal()
//
//   # Wait to be called (elf 0, 1, or 2)
//   elf[id].wait()
//   getHelp()
//
//   mutex.wait()
//   elves -= 1
//   if elves == 0:
//       elfTex.signal()
//   mutex.signal()
//
// Key insight: Reindeer have priority via the Santa check (reindeer >= 9 before
// elves == 3). The elfTex semaphore ensures only one group of 3 elves can queue
// at a time.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module SantaClaus

const NUM_REINDEER: 0..9
const NUM_ELVES: 0..10
const MAX_ROUNDS: 0..3  // Limit rounds to keep state space manageable

// Santa states: 0=sleeping, 1=woken, 2=preparing_sleigh, 3=helping_elves
var santa: 0..3

// Reindeer states: 0=away, 1=arrived, 2=waiting, 3=harnessed
var reindeer_state: Dict[Int, 0..3]

// Elf states: 0=working, 1=need_help, 2=waiting, 3=getting_help, 4=done
var elf_state: Dict[Int, 0..4]

// Counters
var reindeer_count: 0..9
var elf_count: 0..3

// Semaphores
var santa_sem: 0..1
var reindeer_sem: 0..9
var elf_tex: 0..1
var elf_sems: Dict[Int, 0..1]  // Individual elf semaphores (0, 1, 2)
var mutex: 0..1

// Tracking
var rounds: 0..10
var sleigh_prepared: 0..10

init {
    santa = 0 and
    reindeer_state = {i: 0 for i in 0..NUM_REINDEER} and
    elf_state = {i: 0 for i in 0..NUM_ELVES} and
    reindeer_count = 0 and
    elf_count = 0 and
    santa_sem = 0 and
    reindeer_sem = 0 and
    elf_tex = 1 and
    elf_sems = {0: 0, 1: 0, 2: 0} and
    mutex = 1 and
    rounds = 0 and
    sleigh_prepared = 0
}

// === Santa actions ===

action Santa_Sleep() {
    require santa == 0
    require santa_sem > 0
    santa_sem = santa_sem - 1 and
    santa = 1
}

action Santa_CheckReindeer() {
    require santa == 1
    require mutex > 0
    require reindeer_count >= 9
    mutex = mutex - 1 and
    santa = 2
}

action Santa_PrepareSleigh() {
    require santa == 2
    reindeer_sem = reindeer_sem + 9 and
    reindeer_count = 0 and
    mutex = mutex + 1 and
    sleigh_prepared = sleigh_prepared + 1 and
    santa = 0 and
    rounds = rounds + 1
}

action Santa_CheckElves() {
    require santa == 1
    require mutex > 0
    require reindeer_count < 9  // Reindeer have priority
    require elf_count == 3
    mutex = mutex - 1 and
    santa = 3
}

action Santa_HelpElves() {
    require santa == 3
    elf_sems = elf_sems | {0: 1, 1: 1, 2: 1} and
    mutex = mutex + 1 and
    santa = 0
}

// === Reindeer actions ===

action Reindeer_Arrive(i: 0..NUM_REINDEER) {
    require reindeer_state[i] == 0
    require mutex > 0
    mutex = mutex - 1 and
    reindeer_count = reindeer_count + 1 and
    reindeer_state = reindeer_state | {i: 1}
}

action Reindeer_WakeSanta(i: 0..NUM_REINDEER) {
    require reindeer_state[i] == 1
    require reindeer_count == 9
    santa_sem = santa_sem + 1 and
    mutex = mutex + 1 and
    reindeer_state = reindeer_state | {i: 2}
}

action Reindeer_ReleaseMutexNotNinth(i: 0..NUM_REINDEER) {
    require reindeer_state[i] == 1
    require reindeer_count < 9
    mutex = mutex + 1 and
    reindeer_state = reindeer_state | {i: 2}
}

action Reindeer_GetHarnessed(i: 0..NUM_REINDEER) {
    require reindeer_state[i] == 2
    require reindeer_sem > 0
    reindeer_sem = reindeer_sem - 1 and
    reindeer_state = reindeer_state | {i: 3}
}

action Reindeer_LeaveForTropics(i: 0..NUM_REINDEER) {
    require reindeer_state[i] == 3
    require rounds < MAX_ROUNDS
    reindeer_state = reindeer_state | {i: 0}
}

// === Elf actions ===

action Elf_AcquireTex(i: 0..NUM_ELVES) {
    require elf_state[i] == 0
    require elf_tex > 0
    elf_tex = elf_tex - 1 and
    elf_state = elf_state | {i: 1}
}

action Elf_IncrementCount(i: 0..NUM_ELVES) {
    require elf_state[i] == 1
    require mutex > 0
    mutex = mutex - 1 and
    elf_count = elf_count + 1 and
    elf_state = elf_state | {i: 2}
}

action Elf_WakeSantaAsThird(i: 0..NUM_ELVES) {
    require elf_state[i] == 2
    require elf_count == 3
    santa_sem = santa_sem + 1 and
    mutex = mutex + 1 and
    elf_state = elf_state | {i: 3}
}

action Elf_ReleaseTex(i: 0..NUM_ELVES) {
    require elf_state[i] == 2
    require elf_count < 3
    elf_tex = elf_tex + 1 and
    mutex = mutex + 1 and
    elf_state = elf_state | {i: 3}
}

action Elf_WaitForHelp(i: 0..NUM_ELVES, slot: 0..2) {
    require elf_state[i] == 3
    require elf_sems[slot] > 0
    elf_sems = elf_sems | {slot: 0} and
    elf_state = elf_state | {i: 4}
}

action Elf_DecrementCount(i: 0..NUM_ELVES) {
    require elf_state[i] == 4
    require mutex > 0
    mutex = mutex - 1 and
    elf_count = elf_count - 1 and
    elf_state = elf_state | {i: 0}
}

action Elf_ReleaseTex_LastElf(i: 0..NUM_ELVES) {
    require elf_state[i] == 0
    require elf_count == 0
    require elf_tex == 0
    elf_tex = elf_tex + 1 and
    mutex = mutex + 1
}

action Elf_ReleaseMutex_NotLast(i: 0..NUM_ELVES) {
    require elf_state[i] == 0
    require elf_count > 0
    mutex = mutex + 1
}

// === Safety invariants ===

invariant ReindeerPriority {
    // If reindeer ready, Santa doesn't help elves
    not (reindeer_count >= 9 and santa == 3)
}

invariant ExactlyThreeElves {
    // If Santa helping elves, exactly 3 are queued
    santa == 3 implies elf_count == 3
}

invariant ReindeerCountCorrect {
    reindeer_count >= 0 and reindeer_count <= 9
}

invariant ElfCountCorrect {
    elf_count >= 0 and elf_count <= 3
}

invariant SemaphoreBounds {
    santa_sem <= 1 and elf_tex <= 1 and mutex <= 1 and
    reindeer_sem <= 9
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check santa_claus.specl -c NUM_REINDEER=9 -c NUM_ELVES=4 -c MAX_ROUNDS=1 --no-deadlock
//      (Full problem: 9 reindeer, 4 elves, 1 round)
//
// Run: specl check santa_claus.specl -c NUM_REINDEER=5 -c NUM_ELVES=4 -c MAX_ROUNDS=2 --fast --no-deadlock
//      (Smaller: 5 reindeer, 4 elves, 2 rounds - larger state space)
//
// Expected: OK with no violations
//
// The model verifies that:
// 1. Reindeer have priority over elves (ReindeerPriority)
// 2. Santa helps exactly 3 elves when woken by elves (ExactlyThreeElves)
// 3. Counters stay within bounds
// 4. The elfTex pattern ensures only one group of 3 elves queues at a time
// 5. The solution handles complex scheduling with two types of wake conditions
//
// Key insight: This is a complex scheduling problem with priority handling.
// Reindeer always have priority (checked first by Santa). The elfTex semaphore
// ensures mutual exclusion between elf groups. This demonstrates Specl's
// ability to handle production-complexity synchronization patterns.
//
// State space: With full parameters (9 reindeer, 10 elves), expect 1M-10M states.
// Use --fast for larger configurations.
// =============================================================================
