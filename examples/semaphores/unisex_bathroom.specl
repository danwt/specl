// =============================================================================
// Unisex Bathroom Problem
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 5.3: Unisex Bathroom Problem (pages 131-136)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// Suppose there is a bathroom with a maximum capacity of 3 people. People can
// be categorized as men and women. Men and women should not be in the bathroom
// at the same time, but multiple men or multiple women can be in the bathroom
// simultaneously (up to capacity).
//
// To make the problem interesting, we impose the additional constraint that
// there should be no starvation. That is, if a man is waiting, women should
// not be allowed to enter the bathroom indefinitely, and vice versa.
//
// Constraints:
// • Men and women cannot be in the bathroom simultaneously
// • Multiple men (or multiple women) can be in the bathroom, up to capacity
// • No gender should starve waiting to enter
//
// =============================================================================
// SOLUTION
// =============================================================================
//
// This solution uses a turnstile pattern to prevent starvation:
//
// Variables:
//   empty = Semaphore(1)         # Signals bathroom is empty
//   maleMultiplex = Semaphore(3) # Limits males in bathroom
//   femaleMultiplex = Semaphore(3)
//   maleMutex = Semaphore(1)     # Protects male counter
//   femaleMutex = Semaphore(1)   # Protects female counter
//   maleSwitch = Lightswitch()   # First male locks, last unlocks
//   femaleSwitch = Lightswitch()
//   turnstile = Semaphore(1)     # Prevents starvation
//
// Male:
//   turnstile.wait()
//   turnstile.signal()
//
//   maleMultiplex.wait()
//   maleSwitch.lock(empty)
//   # Use bathroom
//   maleMultiplex.signal()
//   maleSwitch.unlock(empty)
//
// Female:
//   turnstile.wait()
//   turnstile.signal()
//
//   femaleMultiplex.wait()
//   femaleSwitch.lock(empty)
//   # Use bathroom
//   femaleMultiplex.signal()
//   femaleSwitch.unlock(empty)
//
// Lightswitch pattern (for maleSwitch):
//   lock(semaphore):
//       maleMutex.wait()
//       males += 1
//       if males == 1:
//           semaphore.wait()
//       maleMutex.signal()
//
//   unlock(semaphore):
//       maleMutex.wait()
//       males -= 1
//       if males == 0:
//           semaphore.signal()
//       maleMutex.signal()
//
// Key insight: The turnstile ensures fairness - both genders must pass through
// it. The lightswitch pattern ensures the first person of a gender locks the
// bathroom for that gender, and the last person unlocks it. The multiplex
// semaphores enforce the capacity limit.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module UnisexBathroom

const NUM_MALES: 0..5
const NUM_FEMALES: 0..5
const CAPACITY: 0..10

// Male states: 0=outside, 1=at_turnstile, 2=passed_turnstile,
//              3=acquiring_multiplex, 4=locking, 5=in_bathroom, 6=unlocking
var males_state: Dict[Int, 0..6]

// Female states: 0=outside, 1=at_turnstile, 2=passed_turnstile,
//                3=acquiring_multiplex, 4=locking, 5=in_bathroom, 6=unlocking
var females_state: Dict[Int, 0..6]

// Counters
var males_count: 0..10
var females_count: 0..10

// Semaphores
var empty: 0..1
var male_multiplex: 0..10
var female_multiplex: 0..10
var male_mutex: 0..1
var female_mutex: 0..1
var turnstile: 0..1

init {
    males_state = {i: 0 for i in 0..NUM_MALES} and
    females_state = {i: 0 for i in 0..NUM_FEMALES} and
    males_count = 0 and
    females_count = 0 and
    empty = 1 and
    male_multiplex = CAPACITY and
    female_multiplex = CAPACITY and
    male_mutex = 1 and
    female_mutex = 1 and
    turnstile = 1
}

// === Male actions ===

action Male_EnterTurnstile(i: 0..NUM_MALES) {
    require males_state[i] == 0
    require turnstile > 0
    males_state = males_state | {i: 1}
}

action Male_LeaveTurnstile(i: 0..NUM_MALES) {
    require males_state[i] == 1
    males_state = males_state | {i: 2}
}

action Male_AcquireMultiplex(i: 0..NUM_MALES) {
    require males_state[i] == 2
    require male_multiplex > 0
    male_multiplex = male_multiplex - 1 and
    males_state = males_state | {i: 3}
}

action Male_LockIfFirst(i: 0..NUM_MALES) {
    require males_state[i] == 3
    require male_mutex > 0
    require males_count == 0  // I will be first
    require empty > 0
    // Atomically: acquire mutex, increment count, lock empty, release mutex
    males_count = males_count + 1 and
    empty = empty - 1 and
    males_state = males_state | {i: 4}
}

action Male_LockNotFirst(i: 0..NUM_MALES) {
    require males_state[i] == 3
    require male_mutex > 0
    require males_count > 0  // Not first
    // Atomically: acquire mutex, increment count, release mutex
    males_count = males_count + 1 and
    males_state = males_state | {i: 4}
}

action Male_UseBathroom(i: 0..NUM_MALES) {
    require males_state[i] == 4
    males_state = males_state | {i: 5}
}

action Male_ReleaseMultiplex(i: 0..NUM_MALES) {
    require males_state[i] == 5
    male_multiplex = male_multiplex + 1 and
    males_state = males_state | {i: 6}
}

action Male_UnlockIfLast(i: 0..NUM_MALES) {
    require males_state[i] == 6
    require male_mutex > 0
    require males_count == 1  // I will be last
    // Atomically: acquire mutex, decrement count, release empty, release mutex
    males_count = males_count - 1 and
    empty = empty + 1 and
    males_state = males_state | {i: 0}
}

action Male_UnlockNotLast(i: 0..NUM_MALES) {
    require males_state[i] == 6
    require male_mutex > 0
    require males_count > 1  // Not last
    // Atomically: acquire mutex, decrement count, release mutex
    males_count = males_count - 1 and
    males_state = males_state | {i: 0}
}

// === Female actions ===

action Female_EnterTurnstile(i: 0..NUM_FEMALES) {
    require females_state[i] == 0
    require turnstile > 0
    females_state = females_state | {i: 1}
}

action Female_LeaveTurnstile(i: 0..NUM_FEMALES) {
    require females_state[i] == 1
    females_state = females_state | {i: 2}
}

action Female_AcquireMultiplex(i: 0..NUM_FEMALES) {
    require females_state[i] == 2
    require female_multiplex > 0
    female_multiplex = female_multiplex - 1 and
    females_state = females_state | {i: 3}
}

action Female_LockIfFirst(i: 0..NUM_FEMALES) {
    require females_state[i] == 3
    require female_mutex > 0
    require females_count == 0  // I will be first
    require empty > 0
    // Atomically: acquire mutex, increment count, lock empty, release mutex
    females_count = females_count + 1 and
    empty = empty - 1 and
    females_state = females_state | {i: 4}
}

action Female_LockNotFirst(i: 0..NUM_FEMALES) {
    require females_state[i] == 3
    require female_mutex > 0
    require females_count > 0  // Not first
    // Atomically: acquire mutex, increment count, release mutex
    females_count = females_count + 1 and
    females_state = females_state | {i: 4}
}

action Female_UseBathroom(i: 0..NUM_FEMALES) {
    require females_state[i] == 4
    females_state = females_state | {i: 5}
}

action Female_ReleaseMultiplex(i: 0..NUM_FEMALES) {
    require females_state[i] == 5
    female_multiplex = female_multiplex + 1 and
    females_state = females_state | {i: 6}
}

action Female_UnlockIfLast(i: 0..NUM_FEMALES) {
    require females_state[i] == 6
    require female_mutex > 0
    require females_count == 1  // I will be last
    // Atomically: acquire mutex, decrement count, release empty, release mutex
    females_count = females_count - 1 and
    empty = empty + 1 and
    females_state = females_state | {i: 0}
}

action Female_UnlockNotLast(i: 0..NUM_FEMALES) {
    require females_state[i] == 6
    require female_mutex > 0
    require females_count > 1  // Not last
    // Atomically: acquire mutex, decrement count, release mutex
    females_count = females_count - 1 and
    females_state = females_state | {i: 0}
}

// === Safety invariants ===

invariant NoMixedGenders {
    // Males and females cannot be in bathroom simultaneously
    not (males_count > 0 and females_count > 0)
}

invariant CapacityLimit {
    // Total occupancy never exceeds capacity
    males_count + females_count <= CAPACITY
}

invariant MaleCountCorrect {
    let actual = len({i in 0..NUM_MALES if males_state[i] >= 4 and males_state[i] <= 6}) in
    males_count == actual
}

invariant FemaleCountCorrect {
    let actual = len({i in 0..NUM_FEMALES if females_state[i] >= 4 and females_state[i] <= 6}) in
    females_count == actual
}

invariant SemaphoreBounds {
    empty <= 1 and
    male_mutex <= 1 and female_mutex <= 1 and
    turnstile <= 1 and
    male_multiplex <= CAPACITY and
    female_multiplex <= CAPACITY
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check unisex_bathroom.specl -c NUM_MALES=2 -c NUM_FEMALES=2 -c CAPACITY=3 --no-deadlock
//      (2 males, 2 females, capacity 3)
//
// Run: specl check unisex_bathroom.specl -c NUM_MALES=3 -c NUM_FEMALES=3 -c CAPACITY=4 --no-deadlock
//      (3 males, 3 females, capacity 4 - larger state space)
//
// Expected: OK with no violations
//
// The model verifies that:
// 1. Males and females are never in the bathroom simultaneously (NoMixedGenders)
// 2. Total occupancy respects the capacity limit (CapacityLimit)
// 3. Counters match actual bathroom occupancy
// 4. The turnstile pattern prevents gender starvation
// 5. The lightswitch pattern correctly locks/unlocks for first/last person
//
// Key insight: This problem demonstrates GROUP mutual exclusion - multiple
// threads from the same group (gender) can proceed concurrently, but different
// groups must be mutually exclusive. The turnstile ensures fairness, and the
// lightswitch pattern (first locks, last unlocks) elegantly coordinates group
// entry/exit. The multiplex semaphores enforce capacity within each group.
//
// This is an excellent test of Specl's ability to express complex synchronization
// patterns using quantifiers (all people in bathroom have same gender) and
// coordination across multiple semaphores.
// =============================================================================
