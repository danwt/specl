// =============================================================================
// Queue (Leader-Follower Pairing)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 3.8: Queue (pages 45-49)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// Semaphores can also be used to represent a queue. In this case, the initial
// value is 0, and usually the code is written so that it is not possible to
// signal unless there is a thread waiting, so the value of the semaphore is
// never positive.
//
// For example, imagine that threads represent ballroom dancers and that two
// kinds of dancers, leaders and followers, wait in two queues before entering
// the dance floor. When a leader arrives, it checks to see if there is a
// follower waiting. If so, they can both proceed. Otherwise it waits.
//
// Similarly, when a follower arrives, it checks for a leader and either
// proceeds or waits, accordingly.
//
// Puzzle: write code for leaders and followers that enforces these constraints.
//
// =============================================================================
// SOLUTION
// =============================================================================
//
// Variables:
//   leaderQueue = Semaphore(0)    // Queue where leaders wait
//   followerQueue = Semaphore(0)  // Queue where followers wait
//
// Leader code:
//   followerQueue.signal()
//   leaderQueue.wait()
//   dance()
//
// Follower code:
//   leaderQueue.signal()
//   followerQueue.wait()
//   dance()
//
// This solution is about as simple as it gets; it is just a Rendezvous. Each
// leader signals exactly one follower, and each follower signals one leader,
// so it is guaranteed that leaders and followers are allowed to proceed in
// pairs.
//
// But whether they actually proceed in pairs is not clear. It is possible for
// any number of threads to accumulate before executing dance, and so it is
// possible for any number of leaders to dance before any followers do.
// Depending on the semantics of dance, that behavior may or may not be
// problematic.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module Queue

const NUM_LEADERS: 0..5     // Number of leader threads
const NUM_FOLLOWERS: 0..5   // Number of follower threads

// Leader states: 0=not_arrived, 1=signaled, 2=waiting, 3=dancing
var leaders: Dict[Int, 0..3]

// Follower states: 0=not_arrived, 1=signaled, 2=waiting, 3=dancing
var followers: Dict[Int, 0..3]

// Queue semaphores
var leaderQueue: 0..5
var followerQueue: 0..5

init {
    leaders = {i: 0 for i in 0..NUM_LEADERS} and
    followers = {i: 0 for i in 0..NUM_FOLLOWERS} and
    leaderQueue = 0 and
    followerQueue = 0
}

// === Leader actions ===

action Leader_Arrive(i: 0..NUM_LEADERS) {
    require leaders[i] == 0
    leaders = leaders | {i: 1} and
    followerQueue = followerQueue + 1
}

action Leader_Wait(i: 0..NUM_LEADERS) {
    require leaders[i] == 1
    require leaderQueue > 0
    leaders = leaders | {i: 2} and
    leaderQueue = leaderQueue - 1
}

action Leader_Dance(i: 0..NUM_LEADERS) {
    require leaders[i] == 2
    leaders = leaders | {i: 3}
}

// === Follower actions ===

action Follower_Arrive(i: 0..NUM_FOLLOWERS) {
    require followers[i] == 0
    followers = followers | {i: 1} and
    leaderQueue = leaderQueue + 1
}

action Follower_Wait(i: 0..NUM_FOLLOWERS) {
    require followers[i] == 1
    require followerQueue > 0
    followers = followers | {i: 2} and
    followerQueue = followerQueue - 1
}

action Follower_Dance(i: 0..NUM_FOLLOWERS) {
    require followers[i] == 2
    followers = followers | {i: 3}
}

// === Safety invariants ===

invariant LeaderQueueBound {
    leaderQueue <= NUM_FOLLOWERS + 1
}

invariant FollowerQueueBound {
    followerQueue <= NUM_LEADERS + 1
}

invariant SemaphoreBalance {
    // Leaders signal followers, followers signal leaders
    // Total signals are balanced
    leaderQueue + followerQueue >= 0
}

invariant NoExcessDancing {
    // Can't have more leaders dancing than exist
    let dancing = len({i in 0..NUM_LEADERS if leaders[i] == 3}) in
    dancing <= NUM_LEADERS + 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check queue.specl -c NUM_LEADERS=2 -c NUM_FOLLOWERS=2 --no-deadlock
//      (2 leaders, 2 followers)
//
// Run: specl check queue.specl -c NUM_LEADERS=3 -c NUM_FOLLOWERS=2 --no-deadlock
//      (asymmetric: 3 leaders, 2 followers)
//
// Expected: OK with PairingConstraint holding
//
// The model verifies that:
// 1. Leaders and followers are paired correctly
// 2. Queue semaphores stay within bounds
// 3. The simple rendezvous pattern ensures synchronization
// 4. Works correctly even with asymmetric numbers
//
// Key insight: This is just a rendezvous pattern - each leader signals exactly
// one follower and vice versa. The solution guarantees pairing at the
// synchronization point, though multiple threads may accumulate before dancing.
//
// Note: The book mentions an "exclusive queue" puzzle where each leader must
// dance with only ONE follower concurrently (mutual exclusion during dance).
// This basic solution does not enforce that stronger constraint.
// =============================================================================
