// =============================================================================
// Barrier (N-Thread Synchronization)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 3.6: Barrier (pages 21-29)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// Consider again the Rendezvous problem from Section 3.3. A limitation of the
// solution we presented is that it does not work with more than two threads.
//
// Puzzle: Generalize the rendezvous solution. Every thread should run the
// following code:
//
//   rendezvous
//   critical point
//
// The synchronization requirement is that no thread executes critical point
// until after all threads have executed rendezvous.
//
// You can assume that there are n threads and that this value is stored in a
// variable, n, that is accessible from all threads.
//
// When the first n-1 threads arrive they should block until the nth thread
// arrives, at which point all the threads may proceed.
//
// =============================================================================
// SOLUTION (Turnstile Pattern)
// =============================================================================
//
// Variables:
//   n = the number of threads
//   count = 0                     // Tracks how many threads have arrived
//   mutex = Semaphore(1)          // Protects count
//   barrier = Semaphore(0)        // Turnstile for all threads
//
// Code (all threads run the same code):
//   rendezvous
//
//   mutex.wait()
//   count = count + 1
//   mutex.signal()
//
//   if count == n: barrier.signal()
//
//   barrier.wait()
//   barrier.signal()
//
//   critical point
//
// How it works:
// - Each thread increments count (protected by mutex)
// - The nth thread signals the barrier (opens the "turnstile")
// - Each thread waits at the barrier, then signals it for the next thread
// - This creates a chain: each thread that passes signals the next
// - After all n threads pass, the barrier is locked again (count can be reset)
//
// This pattern (wait followed by signal) is called a "turnstile" because it
// allows one thread to pass at a time, and it can be locked to bar all threads.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module Barrier

const N: 0..10  // Number of threads

// Thread states: 0=before_rendezvous, 1=at_barrier, 2=waiting, 3=passed, 4=at_critical
var threads: Dict[Int, 0..4]

// Shared counter (protected by mutex)
var count: 0..10

// Mutex semaphore (0=locked, 1=unlocked)
var mutex: 0..1

// Barrier semaphore (turnstile)
var barrier: 0..10

init {
    threads = {} and
    count = 0 and
    mutex = 1 and
    barrier = 0
}

// === Thread actions ===

action Thread_Rendezvous(i: 0..N) {
    require not has_key(threads, i)
    threads = threads | {i: 1}
}

action Thread_IncrementCount(i: 0..N) {
    require has_key(threads, i) and threads[i] == 1
    require mutex == 1
    threads = threads | {i: 2} and
    count = count + 1 and
    mutex = 0
}

action Thread_OpenBarrier(i: 0..N) {
    require has_key(threads, i) and threads[i] == 2
    require count == N
    barrier = barrier + 1
}

action Thread_WaitAndSignal(i: 0..N) {
    require has_key(threads, i) and threads[i] == 2
    require barrier > 0
    threads = threads | {i: 3} and
    barrier = barrier  // Wait consumes one, signal adds one (net: same)
}

action Thread_Critical(i: 0..N) {
    require has_key(threads, i) and threads[i] == 3
    threads = threads | {i: 4}
}

// === Safety invariants ===

invariant BarrierConstraint {
    // No thread reaches critical point until all have done rendezvous
    let at_or_past_critical = len({i in 0..N if has_key(threads, i) and threads[i] >= 4}) in
    let before_rendezvous = N - len({i in 0..N if has_key(threads, i)}) in
    at_or_past_critical > 0 implies before_rendezvous == 0
}

invariant CountBound {
    // Count never exceeds number of threads
    count <= N
}

invariant MutexBinary {
    mutex <= 1
}

invariant BarrierBound {
    // Barrier semaphore never exceeds N
    barrier <= N
}

invariant AllOrNone {
    // Either all threads have passed or none have reached critical point
    let passed = len({i in 0..N if has_key(threads, i) and threads[i] >= 3}) in
    passed == 0 or count == N
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check barrier.specl -c N=3 --no-deadlock
//      (3 threads synchronizing at barrier)
//
// Run: specl check barrier.specl -c N=4 --no-deadlock
//      (4 threads synchronizing at barrier)
//
// Expected: OK with BarrierConstraint holding
//
// The model verifies that:
// 1. No thread reaches the critical point until all threads have done rendezvous
// 2. The turnstile pattern correctly sequences all threads through the barrier
// 3. Count and barrier semaphore stay within bounds
// 4. Once threads start passing, all N have arrived (AllOrNone invariant)
//
// Key insight: The turnstile pattern (barrier.wait() followed by barrier.signal())
// creates a chain reaction - the nth thread opens the gate, and each passing
// thread signals the next. This is more elegant than having the nth thread
// signal n-1 times.
//
// Common bug (Deadlock #2): Forgetting the barrier.signal() after barrier.wait()
// causes all but one thread to deadlock at the barrier.
// =============================================================================
