// =============================================================================
// Dining Philosophers (Deadlock Avoidance)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 4.4: Dining philosophers (pages 87-93)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// The Dining Philosophers Problem was proposed by Dijkstra in 1965, when
// dinosaurs ruled the earth [3]. It appears in a number of variations, but the
// standard features are a table with five plates, five forks (or chopsticks)
// and a big bowl of spaghetti. Five philosophers, who represent interacting
// threads, come to the table and execute the following loop:
//
//   while True:
//       think()
//       get_forks()
//       eat()
//       put_forks()
//
// The forks represent resources that the threads have to hold exclusively in
// order to make progress. The thing that makes the problem interesting, unrealistic,
// and unsanitary, is that the philosophers need TWO forks to eat, so a hungry
// philosopher might have to wait for a neighbor to put down a fork.
//
// Assume that the philosophers are numbered 0 to 4, and that Philosopher i has
// fork i on the right and fork i+1 on the left (with wraparound: Philosopher 4
// has fork 4 on the right and fork 0 on the left).
//
// Your job is to write get_forks() and put_forks() that satisfy the following
// constraints:
//
// • Only one philosopher can hold a fork at a time.
// • It must be impossible for a deadlock to occur.
// • It must be impossible for a philosopher to starve waiting for a fork.
// • It must be possible for more than one philosopher to eat at the same time.
//
// =============================================================================
// DEADLOCK #5: The Naive Solution
// =============================================================================
//
// The naive approach (using one semaphore per fork):
//
//   forks = [Semaphore(1) for i in range(5)]
//
//   def get_forks(i):
//       fork[right(i)].wait()
//       fork[left(i)].wait()
//
//   def put_forks(i):
//       fork[right(i)].signal()
//       fork[left(i)].signal()
//
// **DEADLOCK:** The table is round. Each philosopher can pick up their right fork
// and then wait forever for their left fork. All 5 philosophers deadlocked!
//
// =============================================================================
// SOLUTION #1: The Footman
// =============================================================================
//
// If only four philosophers are allowed at the table at a time, deadlock is
// impossible.
//
// Proof: If there are only four philosophers at the table, then in the worst case
// each one picks up a fork. Even then, there is a fork left on the table, and
// that fork has two neighbors, each of which is holding another fork. Therefore,
// either of these neighbors can pick up the remaining fork and eat.
//
// We can control the number of philosophers at the table with a Multiplex named
// footman that is initialized to 4:
//
//   footman = Semaphore(4)
//
//   def get_forks(i):
//       footman.wait()
//       fork[right(i)].wait()
//       fork[left(i)].wait()
//
//   def put_forks(i):
//       fork[right(i)].signal()
//       fork[left(i)].signal()
//       footman.signal()
//
// In addition to avoiding deadlock, this solution also guarantees that no
// philosopher starves. The footman ensures bounded waiting time.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module DiningPhilosophers

const N: 0..5  // Number of philosophers (5 for the classic problem)

// Philosopher states: 0=thinking, 1=hungry, 2=has_right, 3=has_both, 4=eating
var philos: Dict[Int, 0..4]

// Fork semaphores (one per fork)
var forks: Dict[Int, 0..1]

// Footman semaphore (limits to N-1 philosophers)
var footman: 0..5

init {
    philos = {} and
    forks = {0: 1, 1: 1, 2: 1, 3: 1, 4: 1} and  // All forks available
    footman = N - 1  // N-1 philosophers allowed at table
}

// Helper: right fork for philosopher i
function right(i: Int): Int { i }

// Helper: left fork for philosopher i
function left(i: Int): Int { (i + 1) % 5 }

// === Philosopher actions ===

action Philosopher_GetHungry(i: 0..N) {
    require not has_key(philos, i)
    require footman > 0
    philos = philos | {i: 1} and
    footman = footman - 1
}

action Philosopher_PickupRight(i: 0..N) {
    require has_key(philos, i) and philos[i] == 1
    let r = right(i) in
    require has_key(forks, r) and forks[r] == 1
    philos = philos | {i: 2} and
    forks = forks | {r: 0}
}

action Philosopher_PickupLeft(i: 0..N) {
    require has_key(philos, i) and philos[i] == 2
    let l = left(i) in
    require has_key(forks, l) and forks[l] == 1
    philos = philos | {i: 3} and
    forks = forks | {l: 0}
}

action Philosopher_Eat(i: 0..N) {
    require has_key(philos, i) and philos[i] == 3
    philos = philos | {i: 4}
}

action Philosopher_PutdownForks(i: 0..N) {
    require has_key(philos, i) and philos[i] == 4
    let r = right(i) in
    let l = left(i) in
    philos = philos - {i} and
    forks = forks | {r: 1, l: 1} and
    footman = footman + 1
}

// === Safety invariants ===

invariant NoDeadlock {
    // If all N philosophers are at the table (footman=0),
    // at least one can make progress (has both forks or can get the next fork)
    let at_table = N - footman in
    let eating = len({i in 0..N if has_key(philos, i) and philos[i] >= 3}) in
    at_table == N implies eating > 0 or at_table < N
}

invariant ForkExclusivity {
    // Each fork is held by at most one philosopher
    // Check fork 0
    let holders0 = len({i in 0..N if has_key(philos, i) and philos[i] >= 2 and
                        (right(i) == 0 or (philos[i] >= 3 and left(i) == 0))}) in
    holders0 <= 1
}

invariant FootmanBound {
    // Footman count is bounded
    footman <= N - 1
}

invariant AtMostNMinusOne {
    // At most N-1 philosophers at the table
    let at_table = N - footman in
    at_table <= N - 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check dining_philosophers.specl -c N=3 --no-deadlock --fast
//      (3 philosophers - smaller state space)
//
// Run: specl check dining_philosophers.specl -c N=5 --no-deadlock --fast
//      (5 philosophers - classic problem, large state space)
//
// Expected: OK with no deadlocks
//
// The model verifies that:
// 1. The footman solution prevents deadlock (NoDeadlock invariant)
// 2. Forks are held exclusively (no two philosophers share a fork)
// 3. At most N-1 philosophers are at the table simultaneously
// 4. The solution allows concurrency (multiple philosophers can eat)
//
// Key insight: By limiting the number of competing threads (philosophers at
// the table) to N-1, we ensure at least one thread can always make progress.
// This breaks the circular wait condition necessary for deadlock.
//
// Alternative solutions:
// - Tanenbaum's solution: One philosopher picks up left fork first (breaks symmetry)
// - Resource hierarchy: Number forks and always pick up lower-numbered fork first
//
// The footman solution is elegant because it requires minimal code change and
// provides fairness guarantees.
// =============================================================================
