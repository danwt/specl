// =============================================================================
// Readers-Writers Problem (Writer Priority Solution)
// =============================================================================
//
// Source: "The Little Book of Semaphores" (2nd Edition, v2.2.1)
//         by Allen B. Downey
//         Section 4.2: Readers-Writers Problem (pages 65-77)
//         https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf
//
// =============================================================================
// PUZZLE DESCRIPTION
// =============================================================================
//
// This problem is also widely known, at least among computer scientists. The
// problem is that there is a shared resource, like a database or file, that
// can be accessed by multiple readers, or by a single writer, but not both.
//
// Assume that threads can access the database by invoking the following
// methods:
//
//   def read_data():
//       # Access the database for reading
//
//   def write_data():
//       # Access the database for writing
//
// Your job is to write a synchronization solution that enforces the following
// constraints:
//
// â€¢ Any number of readers can be in the critical section simultaneously.
// â€¢ Writers must have exclusive access to the critical section.
// â€¢ Writers must have priority: once a writer arrives, no NEW readers should
//   be allowed to start reading (though readers already in the critical section
//   may finish).
//
// The first two constraints are fairly straightforward, and the third is more
// subtle. The danger is reader starvation: if readers arrive frequently enough,
// a writer might wait forever. The "writer priority" constraint prevents this.
//
// =============================================================================
// SOLUTION #3: Writer Priority (No Starvation)
// =============================================================================
//
// The writer-priority solution uses three semaphores and a counter:
//
//   readers = 0              # Count of active readers
//   mutex = Semaphore(1)     # Protects 'readers' counter
//   roomEmpty = Semaphore(1) # Ensures writers get exclusive access
//   turnstile = Semaphore(1) # Gives writers priority
//
// Reader code:
//   turnstile.wait()         # Check if writer is waiting
//   turnstile.signal()       # Let other readers through
//
//   mutex.wait()
//   readers += 1
//   if readers == 1:
//       roomEmpty.wait()     # First reader locks out writers
//   mutex.signal()
//
//   read_data()
//
//   mutex.wait()
//   readers -= 1
//   if readers == 0:
//       roomEmpty.signal()   # Last reader unlocks for writers
//   mutex.signal()
//
// Writer code:
//   turnstile.wait()         # Lock the turnstile
//   roomEmpty.wait()         # Wait for room to be empty
//
//   write_data()
//
//   turnstile.signal()       # Unlock turnstile
//   roomEmpty.signal()       # Release room
//
// Key insight: When a writer arrives, it locks the turnstile. This prevents
// NEW readers from entering (they block at turnstile.wait()). Readers already
// in the room can finish. When the last reader leaves, the writer enters.
// This gives writers priority and prevents writer starvation.
//
// =============================================================================
// SPECL MODEL
// =============================================================================

module ReadersWriters

const NUM_READERS: 0..5
const NUM_WRITERS: 0..5

// Reader states: 0=thinking, 1=at_turnstile, 2=acquiring_mutex,
//                3=reading, 4=releasing_mutex, 5=done
var readers: Dict[Int, 0..5]

// Writer states: 0=thinking, 1=acquiring_turnstile, 2=acquiring_room,
//                3=writing, 4=releasing, 5=done
var writers: Dict[Int, 0..5]

// Shared state
var readers_count: 0..10
var mutex: 0..1
var roomEmpty: 0..1
var turnstile: 0..1

init {
    readers = {i: 0 for i in 0..NUM_READERS} and
    writers = {i: 0 for i in 0..NUM_WRITERS} and
    readers_count = 0 and
    mutex = 1 and
    roomEmpty = 1 and
    turnstile = 1
}

// === Reader actions ===

action Reader_EnterTurnstile(i: 0..NUM_READERS) {
    require readers[i] == 0
    require turnstile > 0
    readers = readers | {i: 1}
    // Immediately pass through (signal follows wait)
}

action Reader_LeaveTurnstile(i: 0..NUM_READERS) {
    require readers[i] == 1
    readers = readers | {i: 2}
    // turnstile stays as is (we passed through)
}

action Reader_AcquireMutex(i: 0..NUM_READERS) {
    require readers[i] == 2
    require mutex > 0
    mutex = mutex - 1 and
    readers_count = readers_count + 1 and
    readers = readers | {i: 3}
}

action Reader_LockRoomIfFirst(i: 0..NUM_READERS) {
    require readers[i] == 3
    require readers_count == 1  // I am first reader
    require roomEmpty > 0
    roomEmpty = roomEmpty - 1 and
    mutex = mutex + 1 and
    readers = readers | {i: 4}
}

action Reader_ReleaseMutexNotFirst(i: 0..NUM_READERS) {
    require readers[i] == 3
    require readers_count > 1  // Not first reader
    mutex = mutex + 1 and
    readers = readers | {i: 4}
}

action Reader_FinishReading(i: 0..NUM_READERS) {
    require readers[i] == 4
    readers = readers | {i: 5}
}

action Reader_UnlockRoomIfLast(i: 0..NUM_READERS) {
    require readers[i] == 5
    require mutex > 0
    mutex = mutex - 1 and
    readers_count = readers_count - 1
    // Check if last reader
}

action Reader_ReleaseRoomIfLast(i: 0..NUM_READERS) {
    require readers[i] == 5
    require readers_count == 0  // I was the last reader
    roomEmpty = roomEmpty + 1 and
    mutex = mutex + 1 and
    readers = readers | {i: 0}  // Loop back to thinking
}

action Reader_ReleaseMutexNotLast(i: 0..NUM_READERS) {
    require readers[i] == 5
    require readers_count > 0  // Not last reader
    mutex = mutex + 1 and
    readers = readers | {i: 0}  // Loop back to thinking
}

// === Writer actions ===

action Writer_AcquireTurnstile(i: 0..NUM_WRITERS) {
    require writers[i] == 0
    require turnstile > 0
    turnstile = turnstile - 1 and
    writers = writers | {i: 1}
}

action Writer_AcquireRoom(i: 0..NUM_WRITERS) {
    require writers[i] == 1
    require roomEmpty > 0
    roomEmpty = roomEmpty - 1 and
    writers = writers | {i: 2}
}

action Writer_Write(i: 0..NUM_WRITERS) {
    require writers[i] == 2
    writers = writers | {i: 3}
}

action Writer_ReleaseTurnstile(i: 0..NUM_WRITERS) {
    require writers[i] == 3
    turnstile = turnstile + 1 and
    writers = writers | {i: 4}
}

action Writer_ReleaseRoom(i: 0..NUM_WRITERS) {
    require writers[i] == 4
    roomEmpty = roomEmpty + 1 and
    writers = writers | {i: 0}  // Loop back to thinking
}

// === Safety invariants ===

invariant MutualExclusion {
    // Cannot have active readers and active writers simultaneously
    let reading = len({i in 0..NUM_READERS if readers[i] == 4}) in
    let writing = len({i in 0..NUM_WRITERS if writers[i] == 3}) in
    not (reading > 0 and writing > 0)
}

invariant ExclusiveWriter {
    // At most one writer in critical section
    let writing = len({i in 0..NUM_WRITERS if writers[i] >= 2 and writers[i] <= 3}) in
    writing <= 1
}

invariant ReadersCountCorrect {
    // readers_count matches actual readers in/past critical section
    let actual = len({i in 0..NUM_READERS if readers[i] >= 3 and readers[i] <= 5}) in
    readers_count == actual
}

invariant SemaphoreBounds {
    mutex <= 1 and roomEmpty <= 1 and turnstile <= 1
}

// =============================================================================
// VERIFICATION
// =============================================================================
//
// Run: specl check readers_writers.specl -c NUM_READERS=2 -c NUM_WRITERS=2
//      (2 readers, 2 writers - medium state space)
//
// Run: specl check readers_writers.specl -c NUM_READERS=3 -c NUM_WRITERS=2 --fast
//      (3 readers, 2 writers - larger state space, use fingerprinting)
//
// Expected: OK with no violations
//
// The model verifies that:
// 1. Readers and writers never access the database simultaneously (MutualExclusion)
// 2. At most one writer can write at a time (ExclusiveWriter)
// 3. Multiple readers can read concurrently
// 4. Writers get priority via the turnstile mechanism (prevents reader starvation)
//
// Key insight: The turnstile acts as a gate. When a writer arrives, it closes
// the gate (locks turnstile), preventing new readers from entering. Readers
// already inside can finish. When the last reader leaves, the writer enters.
// This guarantees writer priority and prevents writer starvation.
//
// Alternative solutions in the book:
// - Solution #1: No writer priority (writers can starve)
// - Solution #2: No reader priority (readers can starve)
// - Solution #3 (THIS ONE): Writer priority (balanced fairness)
// =============================================================================
